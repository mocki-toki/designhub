File: /pubspec.yaml
Content:
```
name: designhub_monorepo
publish_to: "none"
version: 0.1.0

environment:
  sdk: ">=3.4.4 <4.0.0"

dev_dependencies:
  lint: ^2.3.0
  melos: ^6.1.0

```

File: /packages/shared_admin/pubspec.yaml
Content:
```
name: shared_admin
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  shared:

```

File: /packages/shared_admin/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/models/responses/admin_account_with_totp.dart';
export 'domain/models/responses/admin_account.dart';
export 'domain/exports.dart';
export 'domain/services/admin_session.dart';
export 'domain/services/admin_profile.dart';
export 'domain/services/admin_account_management.dart';
export 'domain/services/admin_collection_link.dart';
export 'domain/entities/failure.dart';
export 'domain/entities/admin_session.dart';
export 'domain/entities/admin_profile.dart';

```

File: /packages/shared_admin/lib/domain/models/responses/admin_account_with_totp.dart
Content:
```
import 'package:shared_admin/domain.dart';

final class AdminAccountWithTotp {
  AdminAccountWithTotp({
    required this.id,
    required this.email,
    required this.totp,
    required this.permissions,
  });

  final UuidValue id;
  final String email;
  final String totp;
  final List<AdminAccountPermission> permissions;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'email': email,
      'totp': totp,
      'permissions': permissions.map((e) => e.name).toList(),
    };
  }

  AdminAccount toEntity() {
    return AdminAccount(
      id: id,
      email: email,
      permissions: permissions,
    );
  }

  static AdminAccountWithTotp fromJson(Map<String, dynamic> json) {
    return AdminAccountWithTotp(
      id: UuidValue.fromString(json['id'] as String),
      email: json['email'] as String,
      totp: json['totp'] as String,
      permissions: (json['permissions'] as List)
          .map((e) => AdminAccountPermission.values.byName(e as String))
          .toList(),
    );
  }
}

```

File: /packages/shared_admin/lib/domain/models/responses/admin_account.dart
Content:
```
import 'package:shared_admin/domain.dart';

final class AdminAccount {
  AdminAccount({
    required this.id,
    required this.email,
    required this.permissions,
  });

  final UuidValue id;
  final String email;
  final List<AdminAccountPermission> permissions;

  bool hasPermissions(List<AdminAccountPermission> permissions) {
    return permissions.every(this.permissions.contains);
  }

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'email': email,
      'permissions': permissions.map((e) => e.name).toList(),
    };
  }

  static AdminAccount fromJson(Map<String, dynamic> json) {
    return AdminAccount(
      id: UuidValue.fromString(json['id'] as String),
      email: json['email'] as String,
      permissions: (json['permissions'] as List)
          .map((e) => AdminAccountPermission.values.byName(e as String))
          .toList(),
    );
  }
}

enum AdminAccountPermission {
  daily,
  posts,
  users,
  adminAccounts,
}

```

File: /packages/shared_admin/lib/domain/exports.dart
Content:
```
export 'package:shared/domain.dart';

```

File: /packages/shared_admin/lib/domain/services/admin_session.dart
Content:
```
import 'package:shared_admin/domain.dart';

abstract interface class AdminSessionService {
  Future<DataOrFailure<AdminSession>> signIn({
    required String email,
    required String totpCode,
  });

  Future<SuccessOrFailure> signOut();
}

```

File: /packages/shared_admin/lib/domain/services/admin_profile.dart
Content:
```
import 'package:shared_admin/domain.dart';

abstract interface class AdminProfileService {
  Future<DataOrFailure<AdminProfile>> getProfile({
    required UuidValue accountId,
  });
}

```

File: /packages/shared_admin/lib/domain/services/admin_account_management.dart
Content:
```
import 'package:shared_admin/domain.dart';

abstract interface class AdminAccountManagementService {
  Future<DataOrFailure<AdminAccountWithTotp>> createAccount({
    required String email,
    required List<AdminAccountPermission> permissions,
  });

  Future<ListDataOrFailure<AdminAccount>> getAccounts();

  Future<DataOrFailure<AdminAccount>> getAccount({
    required UuidValue id,
  });

  Future<DataOrFailure<AdminAccount>> updateAccount({
    required UuidValue id,
    required String email,
    required String password,
    required List<AdminAccountPermission> permissions,
  });

  Future<SuccessOrFailure> deleteAccount({
    required UuidValue id,
  });
}

```

File: /packages/shared_admin/lib/domain/services/admin_collection_link.dart
Content:
```
import 'package:shared_admin/domain.dart';

abstract interface class AdminDailyService implements CollectionLinkService {
  @override
  Future<ListDataOrFailure<Date>> getDates();

  @override
  Future<ListDataOrFailure<DailyLink>> getLinksByDate(Date date);

  Future<SuccessOrFailure> deleteByDate(Date date);

  Future<SuccessOrFailure> setLinksByDate(
    Date date,
    List<DailyLinkRequest> links,
  );
}

```

File: /packages/shared_admin/lib/domain/entities/failure.dart
Content:
```
import 'package:shared_admin/domain.dart';

final class AdminBackendFailure extends BackendFailure {
  AdminBackendFailure(int statusCode) : super(statusCode);

  static BackendFailure fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    switch (type) {
      default:
        return BackendFailure.fromJson(json);
    }
  }
}

```

File: /packages/shared_admin/lib/domain/entities/admin_session.dart
Content:
```
import 'package:shared_admin/domain.dart';

final class AdminSession {
  AdminSession({
    required this.accountId,
    required this.token,
    required this.expires,
  });

  final UuidValue accountId;
  final Token token;
  final DateTime expires;

  Map<String, dynamic> toJson() {
    return {
      'account_id': '$accountId',
      'token': '$token',
      'expires': expires.toIso8601String(),
    };
  }

  static AdminSession fromJson(Map<String, dynamic> json) {
    return AdminSession(
      accountId: UuidValue.fromString(json['account_id'] as String),
      token: json['token'] as Token,
      expires: DateTime.parse(json['expires'] as String),
    );
  }
}

```

File: /packages/shared_admin/lib/domain/entities/admin_profile.dart
Content:
```
import 'package:shared_admin/domain.dart';

final class AdminProfile {
  AdminProfile({
    required this.accountId,
    required this.name,
  });

  final UuidValue accountId;
  final String name;

  Map<String, dynamic> toJson() {
    return {
      'account_id': '$accountId',
      'name': '$name',
    };
  }

  static AdminProfile fromJson(Map<String, dynamic> json) {
    return AdminProfile(
      accountId: UuidValue.fromString(json['account_id'] as String),
      name: json['name'] as String,
    );
  }
}

```

File: /packages/shared_main/pubspec.yaml
Content:
```
name: shared_main
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  shared:

```

File: /packages/admin_backend/test/routes/sign-up/index_test.dart
Content:
```
import 'dart:convert';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../../routes/sign-up/index.dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

final class _AdminAccountManager extends Mock implements AdminAccountManager {}

void main() {
  group('POST /sign-up', () {
    final uri = Uri.parse('http://localhost/sign-up');

    final context = _MockRequestContext();
    final accountManager = _AdminAccountManager();

    final accountId = const Uuid().v4obj();
    const email = 'test_email';
    final permissions = [AdminAccountPermission.adminAccounts];
    const token = 'test_token';

    final account = AdminAccountWithTotp(
      id: accountId,
      email: email,
      totp: '',
      permissions: permissions,
    );

    when(() => accountManager.create(email: email, permissions: permissions))
        .thenAnswer((_) => Future.value(account));

    when(() => accountManager.getByEmailOrNull(email))
        .thenAnswer((_) => Future.value(null));

    test('Sign up', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          null,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          'POST',
          Uri.parse('http://localhost/sign-up'),
          body: jsonEncode({
            'email': email,
            'permissions': permissions.map((e) => e.name).toList(),
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.ok));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'data': {
                'id': '$accountId',
                'email': email,
                'totp': '',
                'permissions': permissions.map((e) => e.name).toList(),
              }
            }),
          ),
        ),
      );
    });

    test('Sign up with token', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          AdminAccount(
            id: accountId,
            email: email,
            permissions: permissions,
          ),
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          'POST',
          uri,
          headers: {
            'Authorization': 'Bearer $token',
          },
          body: jsonEncode({
            'email': email,
            'permissions': permissions.map((e) => e.name).toList(),
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.conflict));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': AlreadySignedInFailure.type}
            }),
          ),
        ),
      );
    });

    test('Sign up with conflict data', () async {
      // Arrange
      when(() => accountManager.getByEmailOrNull(email))
          .thenAnswer((_) => Future.value(account.toEntity()));

      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          null,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          'POST',
          Uri.parse('http://localhost/sign-up'),
          body: jsonEncode({
            'email': email,
            'permissions': permissions.map((e) => e.name).toList(),
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.conflict));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': AccountAlreadyExistsFailure.type}
            }),
          ),
        ),
      );
    });
  });
}

```

File: /packages/admin_backend/test/routes/profile/[account_id]_test.dart
Content:
```
import 'dart:convert';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../../routes/profile/[account_id].dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

final class _AdminAccountManager extends Mock implements AdminAccountManager {}

final class _AdminProfileManager extends Mock implements AdminProfileManager {}

void main() {
  group('GET /profile/[account_id]', () {
    final accountId = const Uuid().v4obj();

    const method = 'GET';
    final uri = Uri.parse('http://localhost/profile/$accountId');

    final context = _MockRequestContext();
    final accountManager = _AdminAccountManager();
    final profileManager = _AdminProfileManager();

    const name = 'test_name';

    test('Get existing profile', () async {
      // Arrange

      when(() => context.read<AdminAccount>()).thenReturn(AdminAccount(
        id: const Uuid().v4obj(),
        email: 'test_email',
        permissions: [],
      ));

      when(() => context.read<AdminProfileService>()).thenReturn(
        AdminProfileEndpoint(
          accountManager,
          profileManager,
        ),
      );

      when(() => accountManager.getByIdOrNull(accountId)).thenAnswer(
        (_) async => AdminAccount(
          id: accountId,
          email: 'test_email',
          permissions: [],
        ),
      );

      when(() => profileManager.getByAccountIdOrCreate(accountId)).thenAnswer(
        (_) async => AdminProfile(
          accountId: accountId,
          name: name,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.ok));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'data': {
                'account_id': '$accountId',
                'name': name,
              }
            }),
          ),
        ),
      );
    });

    test('Get non existing profile', () async {
      // Arrange

      when(() => context.readOrNull<AdminAccount>()).thenReturn(AdminAccount(
        id: const Uuid().v4obj(),
        email: 'test_email',
        permissions: [],
      ));

      when(() => context.read<AdminProfileService>()).thenReturn(
        AdminProfileEndpoint(
          accountManager,
          profileManager,
        ),
      );

      when(() => accountManager.getByIdOrNull(accountId))
          .thenAnswer((_) async => null);

      when(() => profileManager.getByAccountIdOrCreate(accountId)).thenAnswer(
        (_) async => AdminProfile(
          accountId: accountId,
          name: name,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.notFound));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': 'account_not_found_failure'}
            }),
          ),
        ),
      );
    });

    test('Get without authentication', () async {
      // Arrange

      when(() => context.readOrNull<AdminAccount>()).thenReturn(null);

      when(() => context.read<AdminProfileService>()).thenReturn(
        AdminProfileEndpoint(
          accountManager,
          profileManager,
        ),
      );

      when(() => accountManager.getByIdOrNull(accountId))
          .thenAnswer((_) async => null);

      when(() => profileManager.getByAccountIdOrCreate(accountId)).thenAnswer(
        (_) async => AdminProfile(
          accountId: accountId,
          name: name,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.unauthorized));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': 'not_signed_in_failure'}
            }),
          ),
        ),
      );
    });
  });
}

```

File: /packages/admin_backend/test/routes/sign-in/index_test.dart
Content:
```
import 'dart:convert';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../../routes/sign-in/index.dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

final class _AdminAccountManager extends Mock implements AdminAccountManager {}

final class _AdminSessionManager extends Mock implements AdminSessionManager {}

/// TODO: totp никак не проверяется, нужно сделать фейки для менеджеров
void main() {
  group('POST /sign-in', () {
    const method = 'POST';
    final uri = Uri.parse('http://localhost/sign-in');

    final context = _MockRequestContext();
    final accountManager = _AdminAccountManager();
    final sessionManager = _AdminSessionManager();

    final accountId = const Uuid().v4obj();
    const email = 'test_email';
    const totp_code = 'test_code';
    final permissions = [AdminAccountPermission.adminAccounts];
    const token = 'test_token';
    final expires = DateTime.now().add(const Duration(hours: 8));

    when(() => accountManager.getByCredentialsOrNull(email, totp_code))
        .thenAnswer(
      (_) => Future.value(
        AdminAccount(
          id: accountId,
          email: email,
          permissions: permissions,
        ),
      ),
    );

    when(() => sessionManager.deleteByAccountId(accountId)).thenAnswer(
      (_) => Future.value(
        AdminAccount(
          id: accountId,
          email: email,
          permissions: permissions,
        ),
      ),
    );

    when(() => sessionManager.create(accountId)).thenAnswer(
      (_) => Future.value(
        AdminSession(
          accountId: accountId,
          token: token,
          expires: expires,
        ),
      ),
    );

    test('Sign In without totp code', () async {
      // Arrange
      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          null,
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
          body: jsonEncode({
            'email': email,
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.badRequest));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {
                'type': 'missing_parameters_failure',
                'parameters': ['totp_code'],
              },
            }),
          ),
        ),
      );
    });

    test('Sign In without token', () async {
      // Arrange
      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          null,
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
          body: jsonEncode({
            'email': email,
            'totp_code': totp_code,
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.ok));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'data': {
                'account_id': '$accountId',
                'token': token,
                'expires': expires.toIso8601String(),
              }
            }),
          ),
        ),
      );
    });

    test('Sign In with token', () async {
      // Arrange
      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          AdminAccount(
            id: accountId,
            email: email,
            permissions: permissions,
          ),
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
          headers: {
            'Authorization': 'Bearer $token',
          },
          body: jsonEncode({
            'email': email,
            'totp_code': totp_code,
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.conflict));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {
                'type': AlreadySignedInFailure.type,
              },
            }),
          ),
        ),
      );
    });

    test('Sign In with invalid credentials', () async {
      // Arrange
      when(() => accountManager.getByCredentialsOrNull(email, totp_code))
          .thenAnswer((_) => Future.value(null));

      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          null,
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
          body: jsonEncode({
            'email': email,
            'totp_code': totp_code,
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.unauthorized));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {
                'type': InvalidCredentialsFailure.type,
              },
            }),
          ),
        ),
      );
    });
  });
}

```

File: /packages/admin_backend/test/routes/index_test.dart
Content:
```
import 'dart:io';

import 'package:dart_frog/dart_frog.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../routes/index.dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

void main() {
  group('GET /', () {
    test('Index', () {
      final context = _MockRequestContext();
      final response = route.onRequest(context);

      expect(response.statusCode, equals(HttpStatus.ok));
      expect(
        response.body(),
        completion(equals('root route')),
      );
    });
  });
}

```

File: /packages/admin_backend/test/routes/account/[account_id]_test.dart
Content:
```
import 'dart:convert';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../../routes/account/[account_id].dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

final class _AdminAccountManager extends Mock implements AdminAccountManager {}

void main() {
  group('GET /account/[account_id]', () {
    final accountId = const Uuid().v4obj();

    const method = 'GET';
    final uri = Uri.parse('http://localhost/account/$accountId');

    final context = _MockRequestContext();
    final accountManager = _AdminAccountManager();

    final loggedAccount = AdminAccount(
      id: const Uuid().v4obj(),
      email: 'current_account_email',
      permissions: [AdminAccountPermission.adminAccounts],
    );

    final resultAccount = AdminAccount(
      id: accountId,
      email: 'test_email',
      permissions: [],
    );

    test('Get existing profile', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          loggedAccount,
          accountManager,
        ),
      );
      when(() => accountManager.getByIdOrNull(accountId))
          .thenAnswer((_) async => resultAccount);
      when(() => context.request).thenReturn(Request(method, uri));

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.ok));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'data': {
                'id': '$accountId',
                'email': resultAccount.email,
                'permissions':
                    resultAccount.permissions.map((e) => e.toString()).toList(),
              }
            }),
          ),
        ),
      );
    });

    test('Get non existing profile', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          loggedAccount,
          accountManager,
        ),
      );

      when(() => accountManager.getByIdOrNull(accountId))
          .thenAnswer((_) async => null);

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.notFound));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': AccountNotFoundFailure.type}
            }),
          ),
        ),
      );
    });

    test('Get without authentication', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          null,
          accountManager,
        ),
      );

      when(() => accountManager.getByIdOrNull(accountId))
          .thenAnswer((_) async => null);

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.unauthorized));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': NotSignedInFailure.type}
            }),
          ),
        ),
      );
    });

    test('Get without permission', () async {
      // Arrange
      when(() => context.read<AdminAccountManagementService>()).thenReturn(
        AdminAccountManagementEndpoint(
          AdminAccount(
            id: loggedAccount.id,
            email: loggedAccount.email,
            permissions: [],
          ),
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          method,
          uri,
        ),
      );

      // Act
      final response = await route.onRequest(context, '$accountId');

      // Assert
      expect(response.statusCode, equals(HttpStatus.forbidden));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': AccessDeniedFailure.type}
            }),
          ),
        ),
      );
    });
  });
}

```

File: /packages/admin_backend/test/routes/sign-out/index_test.dart
Content:
```
import 'dart:convert';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';
import 'package:mocktail/mocktail.dart';
import 'package:test/test.dart';

import '../../../routes/sign-out/index.dart' as route;

final class _MockRequestContext extends Mock implements RequestContext {}

final class _AdminAccountManager extends Mock implements AdminAccountManager {}

final class _AdminSessionManager extends Mock implements AdminSessionManager {}

void main() {
  group('POST /sign-out', () {
    final uri = Uri.parse('http://localhost/sign-out');

    final context = _MockRequestContext();
    final accountManager = _AdminAccountManager();
    final sessionManager = _AdminSessionManager();

    final accountId = const Uuid().v4obj();
    const email = 'test_email';
    const password = 'test_password';
    final permissions = [AdminAccountPermission.adminAccounts];
    const token = 'test_token';

    when(() => sessionManager.deleteByAccountId(accountId))
        .thenAnswer((_) => Future<void>(() => null));

    test('Sign Out', () async {
      // Arrange
      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          AdminAccount(
            id: accountId,
            email: email,
            permissions: permissions,
          ),
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          'POST',
          uri,
          headers: {
            'Authorization': 'Bearer $token',
          },
          body: jsonEncode({
            'email': email,
            'password': password,
          }),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.ok));
    });

    test('Sign Out without token', () async {
      // Arrange
      when(() => context.read<AdminSessionService>()).thenReturn(
        AdminSessionEndpoint(
          null,
          sessionManager,
          accountManager,
        ),
      );

      when(() => context.request).thenReturn(
        Request(
          'POST',
          Uri.parse('http://localhost/sign-out'),
        ),
      );

      // Act
      final response = await route.onRequest(context);

      // Assert
      expect(response.statusCode, equals(HttpStatus.unauthorized));
      expect(
        response.body(),
        completion(
          equals(
            jsonEncode({
              'failure': {'type': NotSignedInFailure.type}
            }),
          ),
        ),
      );
    });
  });
}

```

File: /packages/admin_backend/prisma/schema.prisma
Content:
```
generator client {
  provider = "dart run orm"
  output   = "../lib/generated/prisma_client"
}

datasource db {
  provider = "postgresql"
  url      = env("ADMIN_DATABASE_URL")
}

model AdminAccountDB {
  id             String          @id @default(uuid())
  email          String          @unique
  totp           String          @unique
  permissions    PermissionsDB[]
  createdAt      DateTime
  updatedAt      DateTime
  AdminProfileDB AdminProfileDB?
  AdminSessionDB AdminSessionDB?

  @@map("AdminAccount")
}

model AdminProfileDB {
  id        String         @id @default(uuid())
  accountId String         @unique
  name      String         @unique
  createdAt DateTime
  updatedAt DateTime
  account   AdminAccountDB @relation(fields: [accountId], references: [id])

  @@map("AdminProfile")
}

model AdminSessionDB {
  id        String         @id @default(uuid())
  accountId String         @unique
  token     String         @unique
  expires   DateTime
  createdAt DateTime
  account   AdminAccountDB @relation(fields: [accountId], references: [id])

  @@map("AdminSession")
}

enum PermissionsDB {
  daily
  posts
  users
  adminAccounts

  @@map("Permissions")
}

```

File: /packages/admin_backend/main.dart
Content:
```
import 'dart:async';
import 'dart:io';
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

final _prismaSharedClient = PrismaSharedClient();
@protected
PrismaSharedClient get prismaSharedClient => _prismaSharedClient;

final _prismaAdminClient = PrismaAdminClient();
@protected
PrismaAdminClient get prismaAdminClient => _prismaAdminClient;

Future<HttpServer> run(Handler handler, InternetAddress ip, int port) async {
  final server = await serve(handler, ip, port);

  await _prismaSharedClient.$connect();
  await _prismaAdminClient.$connect();

  print('Server started on ${server.address.address}:${server.port}');

  ProcessSignal.sigint.watch().listen((_) => _shutdown(server));
  ProcessSignal.sigterm.watch().listen((_) => _shutdown(server));

  return server;
}

Future<void> _shutdown(HttpServer server) async {
  print('Stopping server...');
  await server.close(force: true);

  await _prismaAdminClient.$disconnect();
  await _prismaSharedClient.$disconnect();

  print('Server stopped');
  exit(0);
}

```

File: /packages/admin_backend/pubspec.yaml
Content:
```
name: admin_backend
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  shared_admin:
  shared_backend:

  dart_frog: ^1.0.0
  crypto: ^3.0.3
  orm: ^5.0.4
dev_dependencies:
  test: ^1.25.2
  mocktail: ^1.0.3

```

File: /packages/admin_backend/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/clients/prisma.dart';
export 'infrastructure/endpoints/admin_session.dart';
export 'infrastructure/endpoints/admin_profile.dart';
export 'infrastructure/endpoints/admin_account_management.dart';
export 'infrastructure/endpoints/admin_collection_link.dart';
export 'infrastructure/managers/admin_session.dart';
export 'infrastructure/managers/admin_profile.dart';
export 'infrastructure/managers/admin_account.dart';
export 'infrastructure/middlewares/admin_authentication_middleware.dart';
export 'infrastructure/extensions/request_context_extension.dart';
export 'infrastructure/exports.dart';
export 'infrastructure/environments.dart';

```

File: /packages/admin_backend/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/exports.dart';

```

File: /packages/admin_backend/lib/infrastructure/clients/prisma.dart
Content:
```
import 'package:admin_backend/generated/prisma_client/client.dart';
export 'package:admin_backend/generated/prisma_client/model.dart';
export 'package:admin_backend/generated/prisma_client/prisma.dart'
    hide
        QueryMode,
        NestedStringFilter,
        StringFilter,
        NestedDateTimeFilter,
        DateTimeFilter,
        SortOrder,
        AffectedRowsOutput,
        StringFieldUpdateOperationsInput,
        DateTimeFieldUpdateOperationsInput,
        NestedIntFilter,
        NestedStringWithAggregatesFilter,
        StringWithAggregatesFilter,
        NestedDateTimeWithAggregatesFilter,
        DateTimeWithAggregatesFilter;

final class PrismaAdminClient extends PrismaClient {}

```

File: /packages/admin_backend/lib/infrastructure/endpoints/admin_session.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

final class AdminSessionEndpoint implements AdminSessionService {
  AdminSessionEndpoint(
    this._account,
    this._sessionManager,
    this._accountManager,
  );

  final AdminAccount? _account;
  final AdminSessionManager _sessionManager;
  final AdminAccountManager _accountManager;

  @override
  Future<DataOrFailure<AdminSession>> signIn({
    required String email,
    required String totpCode,
  }) async {
    if (_account != null) return failed(AlreadySignedInFailure());

    final account =
        await _accountManager.getByCredentialsOrNull(email, totpCode);
    if (account == null) return failed(InvalidCredentialsFailure());

    await _sessionManager.deleteByAccountId(account.id);
    return successful(await _sessionManager.create(account.id));
  }

  @override
  Future<SuccessOrFailure> signOut() async {
    if (_account == null) return failed(NotSignedInFailure());
    return successful(await _sessionManager.deleteByAccountId(_account.id));
  }
}

```

File: /packages/admin_backend/lib/infrastructure/endpoints/admin_profile.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

final class AdminProfileEndpoint implements AdminProfileService {
  AdminProfileEndpoint(
    this._accountManager,
    this._profileManager,
  );

  final AdminAccountManager _accountManager;
  final AdminProfileManager _profileManager;

  Future<DataOrFailure<AdminProfile>> getProfile({
    required UuidValue accountId,
  }) async {
    if (await _accountManager.getByIdOrNull(accountId) == null) {
      return failed(AccountNotFoundFailure());
    }

    return successful(await _profileManager.getByAccountIdOrCreate(accountId));
  }
}

```

File: /packages/admin_backend/lib/infrastructure/endpoints/admin_account_management.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

final class AdminAccountManagementEndpoint
    implements AdminAccountManagementService {
  AdminAccountManagementEndpoint(
    this._account,
    this._accountManager,
  );

  final AdminAccount? _account;
  final AdminAccountManager _accountManager;

  @override
  Future<DataOrFailure<AdminAccountWithTotp>> createAccount({
    required String email,
    required List<AdminAccountPermission> permissions,
  }) async {
    if (_account != null) return failed(AlreadySignedInFailure());

    final account = await _accountManager.getByEmailOrNull(email);
    if (account != null) return failed(AccountAlreadyExistsFailure());

    return successful(await _accountManager.create(
      email: email,
      permissions: permissions,
    ));
  }

  @override
  Future<ListDataOrFailure<AdminAccount>> getAccounts() async {
    if (_account == null) return failed(NotSignedInFailure());
    if (!_account.hasPermissions([AdminAccountPermission.adminAccounts])) {
      return failed(AccessDeniedFailure());
    }

    return successful(await _accountManager.getAll());
  }

  @override
  Future<DataOrFailure<AdminAccount>> getAccount({
    required UuidValue id,
  }) async {
    if (_account == null) return failed(NotSignedInFailure());
    if (!_account.hasPermissions([AdminAccountPermission.adminAccounts])) {
      return failed(AccessDeniedFailure());
    }

    if (_account.id == id) return successful(_account);

    final account = await _accountManager.getByIdOrNull(id);
    if (account == null) return failed(AccountNotFoundFailure());

    return successful(account);
  }

  @override
  Future<DataOrFailure<AdminAccount>> updateAccount({
    required UuidValue id,
    required String? email,
    required String? password,
    required List<AdminAccountPermission>? permissions,
  }) async {
    if (_account == null) return failed(NotSignedInFailure());
    if (!_account.hasPermissions([AdminAccountPermission.adminAccounts])) {
      return failed(AccessDeniedFailure());
    }

    final account = await _accountManager.getByIdOrNull(id);
    if (account == null) return failed(AccountNotFoundFailure());

    return successful(await _accountManager.of(account.id).update(
          email: email ?? account.email,
          permissions: permissions ?? account.permissions,
        ));
  }

  @override
  Future<SuccessOrFailure> deleteAccount({
    required UuidValue id,
  }) async {
    if (_account == null) return failed(NotSignedInFailure());
    if (!_account.hasPermissions([AdminAccountPermission.adminAccounts])) {
      return failed(AccessDeniedFailure());
    }

    final account = await _accountManager.getByIdOrNull(id);
    if (account == null) return failed(AccountNotFoundFailure());

    return successful(await _accountManager.of(account.id).delete());
  }
}

```

File: /packages/admin_backend/lib/infrastructure/endpoints/admin_collection_link.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

final class AdminCollectionLinkEndpoint implements AdminDailyService {
  AdminCollectionLinkEndpoint(
    this._collectionLinkManager,
  );

  final DailyLinkManager _collectionLinkManager;

  @override
  Future<ListDataOrFailure<Date>> getDates() async =>
      successful(await _collectionLinkManager.getDates());

  @override
  Future<ListDataOrFailure<DailyLink>> getLinksByDate(
    Date date,
  ) async {
    if (!await _collectionLinkManager.existsDate(date)) {
      return failed(DateNotFoundFailure());
    }

    return successful(await _collectionLinkManager.getLinksByDate(date));
  }

  @override
  Future<DataOrFailure<void>> deleteByDate(Date date) async {
    if (!await _collectionLinkManager.existsDate(date)) {
      return failed(DateNotFoundFailure());
    }

    return successful(await _collectionLinkManager.deleteByDate(date));
  }

  @override
  Future<DataOrFailure<void>> setLinksByDate(
    Date date,
    List<DailyLinkRequest> links,
  ) async =>
      successful(await _collectionLinkManager.setLinksByDate(date, links));
}

```

File: /packages/admin_backend/lib/infrastructure/managers/admin_session.dart
Content:
```
import 'dart:math';

import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

class AdminSessionManager {
  AdminSessionManager(this._client);

  final PrismaAdminClient _client;

  Future<AdminSession> create(UuidValue accountId) async {
    final token = _getRandomString();
    final expires = DateTime.now().add(const Duration(hours: 8)).toUtc();

    await _client.adminSessionDB.create(
      data: $1(
        AdminSessionDBCreateInput(
          createdAt: DateTime.now(),
          account: AdminAccountDBCreateNestedOneWithoutAdminSessionDBInput(
            connect: AdminAccountDBWhereUniqueInput(id: '$accountId'),
          ),
          token: token,
          expires: expires,
        ),
      ),
    );

    return AdminSession(
      accountId: accountId,
      token: token,
      expires: expires,
    );
  }

  Future<AdminSession?> getByTokenOrNull(Token token) async {
    final adminSession = await _client.adminSessionDB.findUnique(
      select: AdminSessionDBSelect(
        accountId: true,
        token: true,
        expires: true,
      ),
      where: AdminSessionDBWhereUniqueInput(token: '$token'),
    );
    if (adminSession == null) return null;

    return AdminSession(
      accountId: adminSession.accountId.toUuidOrNull()!,
      token: adminSession.token!,
      expires: adminSession.expires!,
    );
  }

  Future<void> deleteByAccountId(UuidValue accountId) async {
    try {
      await _client.adminSessionDB.delete(
        where: AdminSessionDBWhereUniqueInput(accountId: '$accountId'),
      );
    } catch (e) {
      if (e is PrismaClientKnownRequestError && e.code == 'P2025') return;
      rethrow;
    }
  }
}

const _chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890';
Random _rnd = Random.secure();

String _getRandomString() => String.fromCharCodes(Iterable.generate(
    50, (_) => _chars.codeUnitAt(_rnd.nextInt(_chars.length))));

```

File: /packages/admin_backend/lib/infrastructure/managers/admin_profile.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

class AdminProfileManager {
  AdminProfileManager(this._client);

  final PrismaAdminClient _client;

  Future<AdminProfile> getByAccountIdOrCreate(UuidValue accountId) async {
    final existingProfile = await _client.adminProfileDB.findUnique(
      select: AdminProfileDBSelect(
        accountId: true,
        name: true,
      ),
      where: AdminProfileDBWhereUniqueInput(accountId: '$accountId'),
    );

    if (existingProfile != null) {
      return AdminProfile(
        accountId: existingProfile.accountId.toUuidOrNull()!,
        name: existingProfile.name!,
      );
    }

    const unnamedName = 'Unnamed Admin';

    await _client.adminProfileDB.create(
      data: $1(AdminProfileDBCreateInput(
        account: AdminAccountDBCreateNestedOneWithoutAdminProfileDBInput(
          connect: AdminAccountDBWhereUniqueInput(
            id: '$accountId',
          ),
        ),
        name: unnamedName,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      )),
    );

    return AdminProfile(
      accountId: accountId,
      name: unnamedName,
    );
  }
}

```

File: /packages/admin_backend/lib/infrastructure/managers/admin_account.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

// TODO: to extension and for TOTP model
AdminAccount _dbToAdminAccount(AdminAccountDB entity) {
  return AdminAccount(
    id: entity.id.toUuidOrNull()!,
    email: entity.email!,
    permissions: entity.permissions!
        .map((p) => AdminAccountPermission.values.byName(p.name))
        .toList(),
  );
}

class AdminAccountManager {
  AdminAccountManager(this._client);

  final PrismaAdminClient _client;

  _AdminAccountManagerOfEntity of(UuidValue id) {
    return _AdminAccountManagerOfEntity(_client, id);
  }

  Future<AdminAccountWithTotp> create({
    required String email,
    required List<AdminAccountPermission> permissions,
  }) async {
    final id = const Uuid().v4();
    final totpSecret = TOTP().generateTOTPSecret();

    await _client.adminAccountDB.create(
      data: $1(AdminAccountDBCreateInput(
        id: id,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        email: email,
        totp: TOTP().encryptSecret(totpSecret),
        permissions: $2(
          permissions.map((e) => PermissionsDB.values.byName(e.name)).toList(),
        ),
      )),
    );

    return AdminAccountWithTotp(
      id: id.toUuidOrNull()!,
      email: email,
      totp: totpSecret,
      permissions: permissions,
    );
  }

  Future<List<AdminAccount>> getAll() async {
    final accounts = await _client.adminAccountDB.findMany(
      select: AdminAccountDBSelect(
        id: true,
        email: true,
        permissions: true,
      ),
    );
    return accounts.map((entity) => _dbToAdminAccount(entity)).toList();
  }

  Future<AdminAccount?> getByCredentialsOrNull(
    String email,
    String totpCode,
  ) async {
    final adminAccount = await _client.adminAccountDB.findUnique(
      select: AdminAccountDBSelect(
        id: true,
        email: true,
        permissions: true,
        totp: true,
      ),
      where: AdminAccountDBWhereUniqueInput(email: email),
    );
    if (adminAccount == null) return null;

    final verified =
        TOTP().verifyTOTPFromEncodedSecret(adminAccount.totp!, totpCode);
    if (!verified) return null;

    return AdminAccount(
      id: adminAccount.id.toUuidOrNull()!,
      email: adminAccount.email!,
      permissions: adminAccount.permissions!
          .map((p) => AdminAccountPermission.values.byName(p.name))
          .toList(),
    );
  }

  Future<AdminAccount?> getByEmailOrNull(String email) async {
    final adminAccount = await _client.adminAccountDB.findUnique(
      select: AdminAccountDBSelect(
        id: true,
        email: true,
        permissions: true,
      ),
      where: AdminAccountDBWhereUniqueInput(email: email),
    );
    if (adminAccount == null) return null;

    return _dbToAdminAccount(adminAccount);
  }

  Future<AdminAccount?> getByIdOrNull(UuidValue id) async {
    final adminAccount = await _client.adminAccountDB.findUnique(
      select: AdminAccountDBSelect(
        id: true,
        email: true,
        permissions: true,
      ),
      where: AdminAccountDBWhereUniqueInput(id: '$id'),
    );
    if (adminAccount == null) return null;

    return _dbToAdminAccount(adminAccount);
  }
}

final class _AdminAccountManagerOfEntity {
  _AdminAccountManagerOfEntity(this._client, this._id);

  final PrismaAdminClient _client;
  final UuidValue _id;

  Future<AdminAccount> update({
    required String email,
    required List<AdminAccountPermission> permissions,
  }) async {
    final updatedAccount = await _client.adminAccountDB.update(
      select: AdminAccountDBSelect(
        id: true,
        email: true,
        permissions: true,
      ),
      where: AdminAccountDBWhereUniqueInput(id: '$_id'),
      data: $1(
        AdminAccountDBUpdateInput(
          email: $1(email),
          permissions: $2(permissions
              .map((e) => PermissionsDB.values.byName(e.name))
              .toList()),
          updatedAt: $1(DateTime.now()),
        ),
      ),
    );

    return AdminAccount(
      id: updatedAccount!.id.toUuidOrNull()!,
      email: updatedAccount.email!,
      permissions: permissions,
    );
  }

  Future<void> delete() async {
    await _client.adminAccountDB.delete(
      where: AdminAccountDBWhereUniqueInput(id: '$_id'),
    );
  }
}

```

File: /packages/admin_backend/lib/infrastructure/middlewares/admin_authentication_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Middleware adminAuthentication() {
  return (handler) {
    return (context) async {
      final authHeader = context.request.headers['Authorization'];
      if (authHeader == null) return handler(context);

      final parts = authHeader.split(' ');
      if (parts.length != 2 || parts[0] != 'Bearer') return handler(context);

      final token = parts[1];
      final session =
          await context.read<AdminSessionManager>().getByTokenOrNull(token);

      if (session != null) {
        if (session.expires.isBefore(DateTime.now().toUtc())) {
          await context
              .read<AdminSessionManager>()
              .deleteByAccountId(session.accountId);
          return SessionExpiredFailure().toResponse();
        }

        final account = await context
            .read<AdminAccountManager>()
            .getByIdOrNull(session.accountId);

        if (account != null) {
          return handler(context.provide<AdminAccount>(() => account));
        }
      } else {
        return SessionExpiredFailure().toResponse();
      }

      return handler(context);
    };
  };
}

```

File: /packages/admin_backend/lib/infrastructure/extensions/request_context_extension.dart
Content:
```
import 'dart:async';

import 'package:admin_backend/domain.dart';
import 'package:shared_backend/infrastructure.dart';

extension AdminResponseExtension on RequestContext {
  FutureOr<Response> requiredAuthorization(
    FutureOr<Response> Function() onAccepted,
  ) {
    if (readOrNull<AdminAccount>() == null) {
      return NotSignedInFailure().toResponse();
    }

    return onAccepted();
  }

  FutureOr<Response> requiredAuthAndPermissions(
    List<AdminAccountPermission> permissions,
    FutureOr<Response> Function() onAccepted,
  ) {
    final account = readOrNull<AdminAccount>();

    if (account == null) {
      return NotSignedInFailure().toResponse();
    }

    if (!account.hasPermissions(permissions)) {
      return AccessDeniedFailure().toResponse();
    }

    return onAccepted();
  }
}

```

File: /packages/admin_backend/lib/infrastructure/exports.dart
Content:
```
export 'package:shared_backend/infrastructure.dart';
export 'package:orm/orm.dart';

```

File: /packages/admin_backend/lib/infrastructure/environments.dart
Content:
```
import 'dart:io';

final class Environments {
  static String dbHost = Platform.environment['DB_HOST'] ?? 'localhost';
  static int dbPort =
      int.tryParse(Platform.environment['DB_PORT'] ?? '') ?? 5432;
  static String dbName = Platform.environment['DB_NAME'] ?? 'postgres';
  static String dbUsername = Platform.environment['DB_USERNAME'] ?? 'postgres';
  static String dbPassword =
      Platform.environment['DB_PASSWORD'] ?? 'testpassword';
}

```

File: /packages/admin_backend/lib/domain/exports.dart
Content:
```
export 'package:shared_admin/domain.dart';
export 'package:shared_backend/domain.dart';

```

File: /packages/admin_backend/routes/index.dart
Content:
```
import 'package:admin_backend/infrastructure.dart';

Response onRequest(RequestContext context) {
  return Response(body: 'root route');
}

```

File: /packages/admin_backend/routes/sign-up/index.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) async {
  return switch (context.request.method) {
    HttpMethod.post => _post(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _post(RequestContext context) async {
  return context.getRequiredParametersFromBody(
    ['email', 'permissions'],
    [String, List],
    (map) {
      final permissions = map['permissions'] as List;
      if (!AdminAccountPermission.values.containsAllAndNotNull(permissions)) {
        return Future.value(
          InvalidParameterValuesFailure(
            [
              AdminAccountPermission.values
                  .getInvalidParameterValue('permissions', permissions),
            ],
          ).toResponse(),
        );
      }

      return context
          .read<AdminAccountManagementService>()
          .createAccount(
              email: map['email'],
              permissions: permissions
                  .map((e) => AdminAccountPermission.values.byName(e))
                  .toList())
          .toResponse();
    },
  );
}

```

File: /packages/admin_backend/routes/sign-up/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminAccountManagementService>(
          () => AdminAccountManagementEndpoint(
            context.readOrNull<AdminAccount>(),
            context.read<AdminAccountManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/routes/daily/links/[date].dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context, String date) async {
  if (!RegExp(r'^\d{4}-\d{2}-\d{2}$').hasMatch(date)) {
    return InvalidParameterValuesFailure([
      InvalidParameterValue('date', [date], ['yyyy-MM-dd']),
    ]).toResponse();
  }
  return switch (context.request.method) {
    HttpMethod.get => _get(context, date),
    HttpMethod.put => _put(context, date),
    HttpMethod.delete => _delete(context, date),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String date) async {
  return context.requiredAuthAndPermissions(
    [AdminAccountPermission.daily],
    () {
      return context
          .read<AdminDailyService>()
          .getLinksByDate(Date.parse(date))
          .toResponse();
    },
  );
}

Future<Response> _put(RequestContext context, String date) async {
  return context.requiredAuthAndPermissions(
    [AdminAccountPermission.daily],
    () => context.getRequiredParametersFromBody(
      ['items'],
      [List],
      (map) {
        final items = map['items'] as List;
        late final List<DailyLinkRequest> links;
        try {
          links = items
              .map((e) => DailyLinkRequest.fromJson(e as Map<String, dynamic>))
              .toList();
        } catch (_) {
          return Future.value(
            InvalidParameterValuesFailure(
              [InvalidParameterValue('items', items, [])],
            ).toResponse(),
          );
        }

        return context
            .read<AdminDailyService>()
            .setLinksByDate(Date.parse(date), links)
            .toResponse();
      },
    ),
  );
}

Future<Response> _delete(RequestContext context, String date) async {
  return context.requiredAuthAndPermissions(
    [AdminAccountPermission.daily],
    () {
      final splittedDate = date.split('-');
      final year = int.parse(splittedDate[0]);
      final month = int.parse(splittedDate[1]);
      final day = int.parse(splittedDate[2]);

      return context
          .read<AdminDailyService>()
          .deleteByDate(Date(DateTime(year, month, day)))
          .toResponse();
    },
  );
}

```

File: /packages/admin_backend/routes/daily/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminDailyService>(
          () => AdminCollectionLinkEndpoint(
            context.read<DailyLinkManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/routes/daily/dates.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.requiredAuthAndPermissions(
    [AdminAccountPermission.daily],
    () => context.read<AdminDailyService>().getDates().toResponse(),
  );
}

```

File: /packages/admin_backend/routes/profile/[account_id].dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(
  RequestContext context,
  String accountId,
) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, accountId),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String accountId) async {
  return context.requiredAuthorization(() {
    return context
        .read<AdminProfileService>()
        .getProfile(accountId: UuidValue.fromString(accountId))
        .toResponse();
  });
}

```

File: /packages/admin_backend/routes/profile/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminProfileService>(
          () => AdminProfileEndpoint(
            context.read<AdminAccountManager>(),
            context.read<AdminProfileManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/routes/_middleware.dart
Content:
```
import 'package:admin_backend/infrastructure.dart';
import 'package:shelf_cors_headers/shelf_cors_headers.dart' as shelf;

import '../main.dart' as main;

Handler middleware(Handler handler) {
  return handler
      .use(adminAuthentication())
      .use(_provideManagers())
      .use(_providePrisma())
      .use(
        fromShelfMiddleware(
          shelf.corsHeaders(
            headers: {
              shelf.ACCESS_CONTROL_ALLOW_ORIGIN: '*',
              shelf.ACCESS_CONTROL_ALLOW_METHODS:
                  'GET,PUT,POST,PATCH,DELETE,OPTIONS',
              shelf.ACCESS_CONTROL_ALLOW_HEADERS:
                  'Origin, Content-Type, Accept, Authorization',
            },
          ),
        ),
      )
      .use(requestLogger());
}

Middleware _providePrisma() {
  return (handler) {
    return (context) async {
      return handler(
        context
            .provide(() => main.prismaSharedClient)
            .provide(() => main.prismaAdminClient),
      );
    };
  };
}

Middleware _provideManagers() {
  return (handler) {
    return (context) async {
      return handler(
        context
            .provide(
                () => AdminSessionManager(context.read<PrismaAdminClient>()))
            .provide(
                () => AdminAccountManager(context.read<PrismaAdminClient>()))
            .provide(
                () => AdminProfileManager(context.read<PrismaAdminClient>()))
            .provide(
                () => DailyLinkManager(context.read<PrismaSharedClient>())),
      );
    };
  };
}

```

File: /packages/admin_backend/routes/sign-in/index.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) async {
  return switch (context.request.method) {
    HttpMethod.post => _post(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _post(RequestContext context) async {
  return context.getRequiredParametersFromBody(
    ['email', 'totp_code'],
    [String, String],
    (map) => context
        .read<AdminSessionService>()
        .signIn(email: map['email'], totpCode: map['totp_code'])
        .toResponse(),
  );
}

```

File: /packages/admin_backend/routes/sign-in/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminSessionService>(
          () => AdminSessionEndpoint(
            context.readOrNull<AdminAccount>(),
            context.read<AdminSessionManager>(),
            context.read<AdminAccountManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/routes/account/[account_id].dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(
  RequestContext context,
  String accountId,
) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, accountId),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String accountId) async {
  return context
      .read<AdminAccountManagementService>()
      .getAccount(id: UuidValue.fromString(accountId))
      .toResponse();
}

```

File: /packages/admin_backend/routes/account/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminAccountManagementService>(
          () => AdminAccountManagementEndpoint(
            context.readOrNull<AdminAccount>(),
            context.read<AdminAccountManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/routes/sign-out/index.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.post => _post(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _post(RequestContext context) {
  return context.read<AdminSessionService>().signOut().toResponse();
}

```

File: /packages/admin_backend/routes/sign-out/_middleware.dart
Content:
```
import 'package:admin_backend/domain.dart';
import 'package:admin_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<AdminSessionService>(
          () => AdminSessionEndpoint(
            context.readOrNull<AdminAccount>(),
            context.read<AdminSessionManager>(),
            context.read<AdminAccountManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/admin_backend/.dart_frog/server.dart
Content:
```
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, implicit_dynamic_list_literal

import 'dart:io';

import 'package:dart_frog/dart_frog.dart';

import '../main.dart' as entrypoint;
import '../routes/index.dart' as index;
import '../routes/sign-up/index.dart' as sign_up_index;
import '../routes/sign-out/index.dart' as sign_out_index;
import '../routes/sign-in/index.dart' as sign_in_index;
import '../routes/profile/[account_id].dart' as profile_$account_id;
import '../routes/daily/dates.dart' as daily_dates;
import '../routes/daily/links/[date].dart' as daily_links_$date;
import '../routes/account/[account_id].dart' as account_$account_id;

import '../routes/_middleware.dart' as middleware;
import '../routes/sign-up/_middleware.dart' as sign_up_middleware;
import '../routes/sign-out/_middleware.dart' as sign_out_middleware;
import '../routes/sign-in/_middleware.dart' as sign_in_middleware;
import '../routes/profile/_middleware.dart' as profile_middleware;
import '../routes/daily/_middleware.dart' as daily_middleware;
import '../routes/account/_middleware.dart' as account_middleware;

void main() async {
  final address = InternetAddress.tryParse('') ?? InternetAddress.anyIPv6;
  final port = int.tryParse(Platform.environment['PORT'] ?? '8080') ?? 8080;
  hotReload(() => createServer(address, port));
}

Future<HttpServer> createServer(InternetAddress address, int port) {
  final handler = Cascade().add(buildRootHandler()).handler;
  return entrypoint.run(handler, address, port);
}

Handler buildRootHandler() {
  final pipeline = const Pipeline().addMiddleware(middleware.middleware);
  final router = Router()
    ..mount('/account', (context) => buildAccountHandler()(context))
    ..mount('/daily/links', (context) => buildDailyLinksHandler()(context))
    ..mount('/daily', (context) => buildDailyHandler()(context))
    ..mount('/profile', (context) => buildProfileHandler()(context))
    ..mount('/sign-in', (context) => buildSignInHandler()(context))
    ..mount('/sign-out', (context) => buildSignOutHandler()(context))
    ..mount('/sign-up', (context) => buildSignUpHandler()(context))
    ..mount('/', (context) => buildHandler()(context));
  return pipeline.addHandler(router);
}

Handler buildAccountHandler() {
  final pipeline = const Pipeline().addMiddleware(account_middleware.middleware);
  final router = Router()
    ..all('/<account_id>', (context,account_id,) => account_$account_id.onRequest(context,account_id,));
  return pipeline.addHandler(router);
}

Handler buildDailyLinksHandler() {
  final pipeline = const Pipeline().addMiddleware(daily_middleware.middleware);
  final router = Router()
    ..all('/<date>', (context,date,) => daily_links_$date.onRequest(context,date,));
  return pipeline.addHandler(router);
}

Handler buildDailyHandler() {
  final pipeline = const Pipeline().addMiddleware(daily_middleware.middleware);
  final router = Router()
    ..all('/dates', (context) => daily_dates.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildProfileHandler() {
  final pipeline = const Pipeline().addMiddleware(profile_middleware.middleware);
  final router = Router()
    ..all('/<account_id>', (context,account_id,) => profile_$account_id.onRequest(context,account_id,));
  return pipeline.addHandler(router);
}

Handler buildSignInHandler() {
  final pipeline = const Pipeline().addMiddleware(sign_in_middleware.middleware);
  final router = Router()
    ..all('/', (context) => sign_in_index.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildSignOutHandler() {
  final pipeline = const Pipeline().addMiddleware(sign_out_middleware.middleware);
  final router = Router()
    ..all('/', (context) => sign_out_index.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildSignUpHandler() {
  final pipeline = const Pipeline().addMiddleware(sign_up_middleware.middleware);
  final router = Router()
    ..all('/', (context) => sign_up_index.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildHandler() {
  final pipeline = const Pipeline();
  final router = Router()
    ..all('/', (context) => index.onRequest(context,));
  return pipeline.addHandler(router);
}


```

File: /packages/shared/pubspec.yaml
Content:
```
name: shared
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  uuid: ^4.3.3
  image: ^4.1.7
  intl: ^0.19.0
  logging: ^1.2.0

```

File: /packages/shared/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/exports.dart';

```

File: /packages/shared/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/typedefs.dart';
export 'domain/models/responses/branding_theme.dart';
export 'domain/models/responses/branding_project.dart';
export 'domain/models/responses/branding_post.dart';
export 'domain/models/responses/branding_studio.dart';
export 'domain/models/responses/daily_link.dart';
export 'domain/models/requests/branding_project.dart';
export 'domain/models/requests/branding_post.dart';
export 'domain/models/requests/daily_link.dart';
export 'domain/models/paginated_list.dart';
export 'domain/models/daily_link.dart';
export 'domain/extensions/uuid.dart';
export 'domain/exports.dart';
export 'domain/services/category.dart';
export 'domain/services/branding.dart';
export 'domain/services/collection_link.dart';
export 'domain/entities/failures/failure.dart';
export 'domain/entities/failures/not_signed_in.dart';
export 'domain/entities/failures/unknown_parameters.dart';
export 'domain/entities/failures/invalid_parameter_types.dart';
export 'domain/entities/failures/invalid_parameter_values.dart';
export 'domain/entities/failures/access_denied.dart';
export 'domain/entities/failures/backend.dart';
export 'domain/entities/failures/date_not_found.dart';
export 'domain/entities/failures/invalid_media_format.dart';
export 'domain/entities/failures/invalid_body_format.dart';
export 'domain/entities/failures/missing_parameters.dart';
export 'domain/entities/failures/already_signed_in.dart';
export 'domain/entities/failures/account_not_found.dart';
export 'domain/entities/failures/invalid_credentials.dart';
export 'domain/entities/failures/token_expired.dart';
export 'domain/entities/failures/account_already_exists.dart';
export 'domain/entities/data_or_failure.dart';
export 'domain/entities/date.dart';
export 'domain/entities/categories/media.dart';
export 'domain/entities/categories/font.dart';
export 'domain/entities/categories/category.dart';
export 'domain/entities/categories/studio.dart';
export 'domain/entities/categories/style.dart';
export 'domain/entities/categories/color.dart';
export 'domain/entities/categories/theme.dart';

```

File: /packages/shared/lib/infrastructure/exports.dart
Content:
```
export 'package:logging/logging.dart';
export 'package:intl/intl.dart' hide TextDirection;

```

File: /packages/shared/lib/domain/typedefs.dart
Content:
```
typedef Token = String;

```

File: /packages/shared/lib/domain/models/responses/branding_theme.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingTheme {
  const BrandingTheme({
    required this.id,
    required this.name,
    required this.projectsCounter,
    required this.previews,
  });

  final UuidValue id;
  final String name;
  final int projectsCounter;
  final List<BrandingPost> previews;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'name': name,
      'projects_counter': projectsCounter,
      'previews': previews.map((e) => e.toJson()).toList(),
    };
  }

  ThemeCategory toCategory() {
    return ThemeCategory(
      id: id,
      name: name,
    );
  }

  static BrandingTheme fromJson(Map<String, dynamic> json) {
    return BrandingTheme(
      id: UuidValue.fromString(json['id'] as String),
      name: json['name'] as String,
      projectsCounter: json['projects_counter'] as int,
      previews: (json['previews'] as List)
          .map((e) => BrandingPost.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

```

File: /packages/shared/lib/domain/models/responses/branding_project.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingProject {
  const BrandingProject({
    required this.id,
    required this.name,
    required this.description,
    required this.children,
    required this.nextChildrenCursor,
    required this.studio,
    required this.theme,
    required this.palette,
    required this.fonts,
    required this.categories,
  });

  final UuidValue id;
  final String name;
  final String description;
  final List<BrandingPost> children;
  final UuidValue? nextChildrenCursor;
  final StudioCategory studio;
  final ThemeCategory theme;
  final List<ColorCategory> palette;
  final List<FontCategory> fonts;
  final List<Category> categories;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'name': name,
      'description': description,
      'children': children.map((e) => e.toJson()).toList(),
      'next_children_cursor': nextChildrenCursor?.uuid,
      'studio': studio.toJson(),
      'theme': theme.toJson(),
      'palette': palette.map((e) => e.toJson()).toList(),
      'fonts': fonts.map((e) => e.toJson()).toList(),
      'categories': categories.map((e) => e.toJson()).toList(),
    };
  }

  static BrandingProject fromJson(Map<String, dynamic> json) {
    late final StudioCategory studio;
    late final ThemeCategory theme;
    late final List<ColorCategory> palette;
    late final List<FontCategory> fonts;
    final List<Category> categories = (json['categories'] as List)
        .map((e) => Category.fromJson(e as Map<String, dynamic>))
        .toList();

    if (json.containsKey('studio')) {
      studio = StudioCategory.fromJson(json['studio'] as Map<String, dynamic>);
      theme = ThemeCategory.fromJson(json['theme'] as Map<String, dynamic>);
      palette = (json['palette'] as List)
          .map((e) => ColorCategory.fromJson(e as Map<String, dynamic>))
          .toList();
      fonts = (json['fonts'] as List)
          .map((e) => FontCategory.fromJson(e as Map<String, dynamic>))
          .toList();
    } else {
      studio = categories.firstWhere(
        (element) => element.key == StudioCategory.keyName,
      ) as StudioCategory;

      theme = categories.firstWhere(
        (element) => element.key == ThemeCategory.keyName,
      ) as ThemeCategory;

      palette = categories
          .where((element) => element.key == ColorCategory.keyName)
          .map((e) => e as ColorCategory)
          .toList();

      fonts = categories
          .where((element) => element.key == FontCategory.keyName)
          .map((e) => e as FontCategory)
          .toList();

      categories.removeWhere(
        (element) =>
            element.key == StudioCategory.keyName ||
            element.key == ThemeCategory.keyName ||
            element.key == ColorCategory.keyName ||
            element.key == FontCategory.keyName,
      );
    }

    return BrandingProject(
      id: UuidValue.fromString(json['id'] as String),
      name: json['name'] as String,
      description: json['description'] as String,
      children: (json['children'] as List)
          .map((e) => BrandingPost.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextChildrenCursor: json['next_children_cursor'] == null
          ? null
          : UuidValue.fromString(json['next_children_cursor'] as String),
      studio: studio,
      theme: theme,
      palette: palette,
      fonts: fonts,
      categories: categories,
    );
  }
}

```

File: /packages/shared/lib/domain/models/responses/branding_post.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingPost {
  const BrandingPost({
    required this.id,
    required this.name,
    required this.description,
    required this.imageUrl,
    required this.studio,
    required this.theme,
    required this.palette,
    required this.fonts,
    required this.categories,
    required this.parent,
  });

  final UuidValue id;
  final String name;
  final String description;
  final Uri? imageUrl;
  final StudioCategory studio;
  final ThemeCategory theme;
  final List<ColorCategory> palette;
  final List<FontCategory> fonts;
  final List<Category> categories;
  final BrandingPostParent? parent;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'name': name,
      'description': description,
      'image_url': imageUrl?.toString(),
      'studio': studio.toJson(),
      'theme': theme.toJson(),
      'palette': palette.map((e) => e.toJson()).toList(),
      'fonts': fonts.map((e) => e.toJson()).toList(),
      'categories': categories.map((e) => e.toJson()).toList(),
      if (parent != null) 'parent': parent!.toJson(),
    };
  }

  static BrandingPost fromJson(Map<String, dynamic> json) {
    late final StudioCategory studio;
    late final ThemeCategory theme;
    late final List<ColorCategory> palette;
    late final List<FontCategory> fonts;
    final List<Category> categories = (json['categories'] as List)
        .map((e) => Category.fromJson(e as Map<String, dynamic>))
        .toList();

    if (json.containsKey('studio')) {
      studio = StudioCategory.fromJson(json['studio'] as Map<String, dynamic>);
      theme = ThemeCategory.fromJson(json['theme'] as Map<String, dynamic>);
      palette = (json['palette'] as List)
          .map((e) => ColorCategory.fromJson(e as Map<String, dynamic>))
          .toList();
      fonts = (json['fonts'] as List)
          .map((e) => FontCategory.fromJson(e as Map<String, dynamic>))
          .toList();
    } else {
      studio = categories.firstWhere(
        (element) => element.key == StudioCategory.keyName,
      ) as StudioCategory;

      theme = categories.firstWhere(
        (element) => element.key == ThemeCategory.keyName,
      ) as ThemeCategory;

      palette = categories
          .where((element) => element.key == ColorCategory.keyName)
          .map((e) => e as ColorCategory)
          .toList();

      fonts = categories
          .where((element) => element.key == FontCategory.keyName)
          .map((e) => e as FontCategory)
          .toList();

      categories.removeWhere(
        (element) =>
            element.key == StudioCategory.keyName ||
            element.key == ThemeCategory.keyName ||
            element.key == ColorCategory.keyName ||
            element.key == FontCategory.keyName,
      );
    }

    return BrandingPost(
      id: UuidValue.fromString(json['id'] as String),
      name: json['name'] as String,
      description: json['description'] as String,
      imageUrl: Uri.tryParse(json['image_url'] as String? ?? ''),
      studio: studio,
      theme: theme,
      palette: palette,
      fonts: fonts,
      categories: categories,
      parent: json.containsKey('parent')
          ? BrandingPostParent.fromJson(json['parent'] as Map<String, dynamic>)
          : null,
    );
  }
}

final class BrandingPostParent {
  const BrandingPostParent({
    required this.id,
    required this.name,
    required this.description,
  });

  final UuidValue id;
  final String name;
  final String description;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'name': name,
      'description': description,
    };
  }

  static BrandingPostParent fromJson(Map<String, dynamic> json) {
    return BrandingPostParent(
      id: UuidValue.fromString(json['id'] as String),
      name: json['name'] as String,
      description: json['description'] as String,
    );
  }
}

```

File: /packages/shared/lib/domain/models/responses/branding_studio.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingStudio {
  const BrandingStudio({
    required this.id,
    required this.name,
    required this.logoUrl,
    required this.projectsCounter,
    required this.previews,
  });

  final UuidValue id;
  final String name;
  final Uri logoUrl;
  final int projectsCounter;
  final List<BrandingPost> previews;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'name': name,
      'logo_url': logoUrl.toString(),
      'projects_counter': projectsCounter,
      'previews': previews.map((e) => e.toJson()).toList(),
    };
  }

  StudioCategory toCategory() {
    return StudioCategory(
      id: id,
      name: name,
      logoUrl: logoUrl,
    );
  }

  static BrandingStudio fromJson(Map<String, dynamic> json) {
    return BrandingStudio(
      id: UuidValue.fromString(json['id'] as String),
      name: json['name'] as String,
      logoUrl: Uri.parse(json['logo_url'] as String),
      projectsCounter: json['projects_counter'] as int,
      previews: (json['previews'] as List)
          .map((e) => BrandingPost.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

```

File: /packages/shared/lib/domain/models/responses/daily_link.dart
Content:
```
import 'package:shared/domain.dart';

final class DailyLink {
  DailyLink({
    required this.id,
    required this.title,
    required this.url,
    required this.previewImageUrl,
    required this.type,
    required this.date,
  });

  final UuidValue id;
  final String title;
  final Uri url;
  final Uri? previewImageUrl;
  final DailyLinkType type;
  final Date date;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'title': title,
      'url': '$url',
      'preview_image_url':
          previewImageUrl == null || previewImageUrl?.host == null
              ? null
              : '$previewImageUrl',
      'type': type.name,
      'date': date.dateTime.toIso8601String(),
    };
  }

  static DailyLink fromJson(Map<String, dynamic> json) {
    var previewImageUrl = json['preview_image_url'] as String?;
    if (previewImageUrl != null && previewImageUrl.isEmpty) {
      previewImageUrl = null;
    }
    return DailyLink(
      id: UuidValue.fromString(json['id'] as String),
      title: json['title'] as String,
      url: Uri.parse(json['url'] as String),
      previewImageUrl:
          previewImageUrl == null ? null : Uri.tryParse(previewImageUrl),
      type: DailyLinkType.values.byName(json['type'] as String),
      date: Date(DateTime.parse(json['date'] as String)),
    );
  }

  DailyLink copyWith({
    UuidValue? id,
    String? title,
    Uri? url,
    Uri? previewImageUrl,
    DailyLinkType? type,
    Date? date,
  }) {
    return DailyLink(
      id: id ?? this.id,
      title: title ?? this.title,
      url: url ?? this.url,
      previewImageUrl: previewImageUrl ?? this.previewImageUrl,
      type: type ?? this.type,
      date: date ?? this.date,
    );
  }

  @override
  operator ==(Object other) {
    return other is DailyLink &&
        other.id == id &&
        other.title == title &&
        other.url == url &&
        other.previewImageUrl == previewImageUrl &&
        other.type == type &&
        other.date == date;
  }

  @override
  int get hashCode {
    return id.hashCode ^
        title.hashCode ^
        url.hashCode ^
        previewImageUrl.hashCode ^
        type.hashCode ^
        date.hashCode;
  }
}

enum DailyLinkType {
  video,
  startup,
  utility,
  site,
  article,
  cases,
}

```

File: /packages/shared/lib/domain/models/requests/branding_project.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingProjectRequest {
  const BrandingProjectRequest({
    required this.name,
    required this.description,
    required this.studio,
    required this.theme,
    required this.palette,
    required this.fonts,
    required this.categories,
  });

  final String name;
  final String description;
  final StudioCategory studio;
  final ThemeCategory theme;
  final List<ColorCategory> palette;
  final List<FontCategory> fonts;
  final List<Category> categories;

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      'studio': studio.toJson(),
      'theme': theme.toJson(),
      'palette': palette.map((e) => e.toJson()).toList(),
      'fonts': fonts.map((e) => e.toJson()).toList(),
      'categories': categories.map((e) => e.toJson()).toList(),
    };
  }

  static BrandingProjectRequest fromJson(Map<String, dynamic> json) {
    return BrandingProjectRequest(
      name: json['name'] as String,
      description: json['description'] as String,
      studio: StudioCategory.fromJson(json['studio'] as Map<String, dynamic>),
      theme: ThemeCategory.fromJson(json['theme'] as Map<String, dynamic>),
      palette: (json['palette'] as List)
          .map((e) => ColorCategory.fromJson(e as Map<String, dynamic>))
          .toList(),
      fonts: (json['fonts'] as List)
          .map((e) => FontCategory.fromJson(e as Map<String, dynamic>))
          .toList(),
      categories: (json['categories'] as List)
          .map((e) => Category.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

```

File: /packages/shared/lib/domain/models/requests/branding_post.dart
Content:
```
import 'package:shared/domain.dart';

final class BrandingPostRequest {
  const BrandingPostRequest({
    required this.parentId,
    required this.name,
    required this.description,
    required this.imageUrl,
    required this.studio,
    required this.theme,
    required this.palette,
    required this.fonts,
    required this.categories,
  });

  final UuidValue parentId;
  final String name;
  final String description;
  final Uri? imageUrl;
  final StudioCategory studio;
  final ThemeCategory theme;
  final List<ColorCategory> palette;
  final List<FontCategory> fonts;
  final List<Category> categories;

  Map<String, dynamic> toJson() {
    return {
      'parent_id': parentId.toString(),
      'name': name,
      'description': description,
      'image_url': imageUrl?.toString(),
      'studio': studio.toJson(),
      'theme': theme.toJson(),
      'palette': palette.map((e) => e.toJson()).toList(),
      'fonts': fonts.map((e) => e.toJson()).toList(),
      'categories': categories.map((e) => e.toJson()).toList(),
    };
  }

  static BrandingPostRequest fromJson(Map<String, dynamic> json) {
    return BrandingPostRequest(
      parentId: UuidValue.fromString(json['parent_id'] as String),
      name: json['name'] as String,
      description: json['description'] as String,
      imageUrl: Uri.tryParse(json['image_url'] as String? ?? ''),
      studio: StudioCategory.fromJson(json['studio'] as Map<String, dynamic>),
      theme: ThemeCategory.fromJson(json['theme'] as Map<String, dynamic>),
      palette: (json['palette'] as List)
          .map((e) => ColorCategory.fromJson(e as Map<String, dynamic>))
          .toList(),
      fonts: (json['fonts'] as List)
          .map((e) => FontCategory.fromJson(e as Map<String, dynamic>))
          .toList(),
      categories: (json['categories'] as List)
          .map((e) => Category.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

```

File: /packages/shared/lib/domain/models/requests/daily_link.dart
Content:
```
import 'package:shared/domain.dart';

final class DailyLinkRequest extends DailyLinkModel {
  DailyLinkRequest({
    required super.title,
    required super.url,
    required super.previewImageUrl,
    required super.type,
    required super.date,
  });

  factory DailyLinkRequest.fromResponse(DailyLink response) {
    return DailyLinkRequest(
      title: response.title,
      url: response.url,
      previewImageUrl: response.previewImageUrl,
      type: response.type,
      date: response.date,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'url': '$url',
      'preview_image_url':
          previewImageUrl == null || previewImageUrl?.host == null
              ? null
              : '$previewImageUrl',
      'type': type.name,
      'date': date.dateTime.toIso8601String(),
    };
  }

  static DailyLinkRequest fromJson(Map<String, dynamic> json) {
    var previewImageUrl = json['preview_image_url'] as String?;
    if (previewImageUrl != null && previewImageUrl.isEmpty) {
      previewImageUrl = null;
    }
    return DailyLinkRequest(
      title: json['title'] as String,
      url: Uri.parse(json['url'] as String),
      previewImageUrl:
          previewImageUrl == null ? null : Uri.tryParse(previewImageUrl),
      type: DailyLinkType.values.byName(json['type'] as String),
      date: Date(DateTime.parse(json['date'] as String)),
    );
  }

  DailyLinkRequest copyWith({
    String? title,
    Uri? url,
    Uri? previewImageUrl,
    DailyLinkType? type,
    Date? date,
  }) {
    return DailyLinkRequest(
      title: title ?? this.title,
      url: url ?? this.url,
      previewImageUrl: previewImageUrl ?? this.previewImageUrl,
      type: type ?? this.type,
      date: date ?? this.date,
    );
  }
}

```

File: /packages/shared/lib/domain/models/paginated_list.dart
Content:
```
import 'dart:collection';

import 'package:shared/domain.dart';

final class PaginatedList<T> extends ListBase<T> {
  const PaginatedList(this._items, this.nextCursor);

  final List<T> _items;
  final UuidValue? nextCursor;

  @override
  int get length => _items.length;

  @override
  set length(int newLength) => _items.length = newLength;

  @override
  T operator [](int index) => _items[index];

  @override
  void operator []=(int index, T value) => _items[index] = value;

  bool get hasNext => nextCursor != null;

  PaginatedList<T> merge(PaginatedList<T> other) {
    return PaginatedList(
      _items + other._items,
      other.nextCursor,
    );
  }
}

```

File: /packages/shared/lib/domain/models/daily_link.dart
Content:
```
import 'package:shared/domain.dart';

class DailyLinkModel {
  DailyLinkModel({
    required this.title,
    required this.url,
    required this.previewImageUrl,
    required this.type,
    required this.date,
  });

  factory DailyLinkModel.fromResponse(DailyLink response) {
    return DailyLinkModel(
      title: response.title,
      url: response.url,
      previewImageUrl: response.previewImageUrl,
      type: response.type,
      date: response.date,
    );
  }

  final String title;
  final Uri url;
  final Uri? previewImageUrl;
  final DailyLinkType type;
  final Date date;

  DailyLinkModel copyWith({
    String? title,
    Uri? url,
    Uri? previewImageUrl,
    DailyLinkType? type,
    Date? date,
  }) {
    return DailyLinkModel(
      title: title ?? this.title,
      url: url ?? this.url,
      previewImageUrl: previewImageUrl ?? this.previewImageUrl,
      type: type ?? this.type,
      date: date ?? this.date,
    );
  }
}

```

File: /packages/shared/lib/domain/extensions/uuid.dart
Content:
```
import 'package:shared/domain.dart';

extension UuidExtension on String? {
  UuidValue? toUuidOrNull() {
    if (this == null || this!.isEmpty) return null;
    return UuidValue.fromString(this!);
  }
}

```

File: /packages/shared/lib/domain/exports.dart
Content:
```
export 'package:uuid/uuid.dart';
export 'dart:io' show HttpStatus;
export 'package:meta/meta.dart' hide Required;
export 'package:collection/collection.dart';
export 'package:intl/intl.dart' hide TextDirection;

```

File: /packages/shared/lib/domain/services/category.dart
Content:
```
import 'package:shared/domain.dart';

abstract interface class CategoryService {
  Future<PaginatedDataOrFailure<Category>> getCategoriesByKey(
    String key, {
    UuidValue? cursor,
    required int limit,
  });
}

```

File: /packages/shared/lib/domain/services/branding.dart
Content:
```
import 'package:shared/domain.dart';

abstract interface class BrandingService {
  Future<PaginatedDataOrFailure<BrandingProject>> getProjects({
    UuidValue? cursor,
    required int limit,
    required int childrenLimit,
  });

  Future<PaginatedDataOrFailure<BrandingStudio>> getStudios({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  });

  Future<PaginatedDataOrFailure<BrandingTheme>> getThemes({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  });

  Future<PaginatedDataOrFailure<BrandingPost>> getPosts({
    UuidValue? cursor,
    required int limit,
    UuidValue? byProject,
    List<UuidValue> byCategories = const [],
  });

  Future<DataOrFailure<BrandingProject>> getProjectById(
    UuidValue id, {
    required int childrenLimit,
  });

  Future<DataOrFailure<BrandingPost>> getPostById(UuidValue id);
}

```

File: /packages/shared/lib/domain/services/collection_link.dart
Content:
```
import 'package:shared/domain.dart';

abstract interface class CollectionLinkService {
  Future<ListDataOrFailure<Date>> getDates();

  Future<ListDataOrFailure<DailyLink>> getLinksByDate(Date date);
}

```

File: /packages/shared/lib/domain/entities/failures/failure.dart
Content:
```
import 'package:shared/domain.dart';

@immutable
class Failure {
  @override
  String toString() => '$runtimeType';
}

```

File: /packages/shared/lib/domain/entities/failures/not_signed_in.dart
Content:
```
import 'package:shared/domain.dart';

final class NotSignedInFailure extends BackendFailure {
  NotSignedInFailure() : super(HttpStatus.unauthorized);

  static const type = 'not_signed_in_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/unknown_parameters.dart
Content:
```
import 'package:shared/domain.dart';

final class UnknownParametersFailure extends BackendFailure {
  UnknownParametersFailure(this.parameters) : super(HttpStatus.badRequest);

  final Iterable<String> parameters;

  static const type = 'unknown_parameters_failure';

  @override
  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
      'parameters': parameters.toList(),
    };
  }

  static UnknownParametersFailure fromJson(Map<String, dynamic> json) {
    return UnknownParametersFailure(
      (json['parameters'] as List).cast<String>(),
    );
  }
}

```

File: /packages/shared/lib/domain/entities/failures/invalid_parameter_types.dart
Content:
```
import 'package:shared/domain.dart';

final class InvalidParameterTypesFailure extends BackendFailure {
  InvalidParameterTypesFailure(this.parameters, this.correctTypes)
      : super(HttpStatus.badRequest);
  final Iterable<String> parameters;
  final Iterable<String> correctTypes;

  static const type = 'invalid_parameter_types_failure';

  @override
  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
      'parameters': parameters.toList(),
      'correct_types': correctTypes.map((e) => e).toList(),
    };
  }

  static InvalidParameterTypesFailure fromJson(Map<String, dynamic> json) {
    return InvalidParameterTypesFailure(
      (json['parameters'] as List).cast<String>(),
      (json['correct_types'] as List).cast<String>(),
    );
  }
}

```

File: /packages/shared/lib/domain/entities/failures/invalid_parameter_values.dart
Content:
```
import 'package:shared/domain.dart';

final class InvalidParameterValuesFailure extends BackendFailure {
  InvalidParameterValuesFailure(
    this.parameters,
  ) : super(HttpStatus.badRequest);

  final Iterable<InvalidParameterValue> parameters;

  static const type = 'invalid_parameter_values_failure';

  @override
  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
      'parameters': parameters.map((e) => e.toJson()).toList(),
    };
  }

  static InvalidParameterValuesFailure fromJson(Map<String, dynamic> json) {
    return InvalidParameterValuesFailure(
      (json['parameters'] as List)
          .map((e) => InvalidParameterValue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

final class InvalidParameterValue {
  InvalidParameterValue(
    this.parameter,
    this.unknownValues,
    this.availableValues,
  );

  final String parameter;
  final List<dynamic> unknownValues;
  final List<dynamic> availableValues;

  Map<String, dynamic> toJson() {
    return {
      'parameter': parameter,
      'unknown_values': unknownValues,
      if (availableValues.isNotEmpty) 'available_values': availableValues,
    };
  }

  static InvalidParameterValue fromJson(Map<String, dynamic> json) {
    return InvalidParameterValue(
      json['parameter'] as String,
      json['unknown_values'] as List,
      !json.containsKey('available_values')
          ? []
          : json['available_values'] as List,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/failures/access_denied.dart
Content:
```
import 'package:shared/domain.dart';

final class AccessDeniedFailure extends BackendFailure {
  AccessDeniedFailure() : super(HttpStatus.forbidden);

  static const type = 'access_denied_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/backend.dart
Content:
```
import 'dart:convert';

import 'package:shared/domain.dart';

@immutable
class BackendFailure extends Failure {
  BackendFailure(this.statusCode);
  final int statusCode;

  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
    };
  }

  @override
  String toString() => '$runtimeType(${jsonEncode(toJson())})';

  String toSnakeCase() {
    return _fromCamelCaseToSnakeCase(this.runtimeType.toString());
  }

  String _fromCamelCaseToSnakeCase(String input) {
    return input
        .replaceAllMapped(
          RegExp(r'[A-Z]'),
          (match) => '_${match.group(0)!.toLowerCase()}',
        )
        .replaceFirst('_', '');
  }

  static BackendFailure fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    switch (type) {
      case InvalidBodyFormatFailure.type:
        return InvalidBodyFormatFailure.fromJson(json);
      case InvalidParameterTypesFailure.type:
        return InvalidParameterTypesFailure.fromJson(json);
      case InvalidParameterValuesFailure.type:
        return InvalidParameterValuesFailure.fromJson(json);
      case MissingParametersFailure.type:
        return MissingParametersFailure.fromJson(json);
      case SessionExpiredFailure.type:
        return SessionExpiredFailure();
      case UnknownParametersFailure.type:
        return UnknownParametersFailure.fromJson(json);
      case AlreadySignedInFailure.type:
        return AlreadySignedInFailure();
      case InvalidCredentialsFailure.type:
        return InvalidCredentialsFailure();
      case NotSignedInFailure.type:
        return NotSignedInFailure();
      case AccountAlreadyExistsFailure.type:
        return AccountAlreadyExistsFailure();
      case AccountNotFoundFailure.type:
        return AccountNotFoundFailure();
      default:
        throw UnimplementedError('Unknown type: $type');
    }
  }
}

```

File: /packages/shared/lib/domain/entities/failures/date_not_found.dart
Content:
```
import 'package:shared/domain.dart';

final class DateNotFoundFailure extends BackendFailure {
  DateNotFoundFailure() : super(HttpStatus.notFound);

  static const type = 'date_not_found_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/invalid_media_format.dart
Content:
```
import 'package:shared/domain.dart';

final class InvalidMediaFormatFailure extends BackendFailure {
  InvalidMediaFormatFailure() : super(HttpStatus.badRequest);

  static const type = 'invalid_media_format_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/invalid_body_format.dart
Content:
```
import 'package:shared/domain.dart';

final class InvalidBodyFormatFailure extends BackendFailure {
  InvalidBodyFormatFailure(this.message) : super(HttpStatus.badRequest);

  final String message;

  static const type = 'invalid_body_format_failure';

  @override
  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
      'message': message,
    };
  }

  static InvalidBodyFormatFailure fromJson(Map<String, dynamic> json) {
    return InvalidBodyFormatFailure(json['message'] as String);
  }
}

```

File: /packages/shared/lib/domain/entities/failures/missing_parameters.dart
Content:
```
import 'package:shared/domain.dart';

final class MissingParametersFailure extends BackendFailure {
  MissingParametersFailure(this.parameters) : super(HttpStatus.badRequest);

  final Iterable<String> parameters;

  static const type = 'missing_parameters_failure';

  @override
  Map<String, dynamic> toJson() {
    return {
      'type': toSnakeCase(),
      'parameters': parameters.toList(),
    };
  }

  static MissingParametersFailure fromJson(Map<String, dynamic> json) {
    return MissingParametersFailure(
      (json['parameters'] as List).cast<String>(),
    );
  }
}

```

File: /packages/shared/lib/domain/entities/failures/already_signed_in.dart
Content:
```
import 'package:shared/domain.dart';

final class AlreadySignedInFailure extends BackendFailure {
  AlreadySignedInFailure() : super(HttpStatus.conflict);

  static const type = 'already_signed_in_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/account_not_found.dart
Content:
```
import 'package:shared/domain.dart';

final class AccountNotFoundFailure extends BackendFailure {
  AccountNotFoundFailure() : super(HttpStatus.notFound);

  static const type = 'account_not_found_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/invalid_credentials.dart
Content:
```
import 'package:shared/domain.dart';

final class InvalidCredentialsFailure extends BackendFailure {
  InvalidCredentialsFailure() : super(HttpStatus.unauthorized);

  static const type = 'invalid_credentials_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/token_expired.dart
Content:
```
import 'package:shared/domain.dart';

final class SessionExpiredFailure extends BackendFailure {
  SessionExpiredFailure() : super(HttpStatus.badRequest);

  static const type = 'session_expired_failure';
}

```

File: /packages/shared/lib/domain/entities/failures/account_already_exists.dart
Content:
```
import 'package:shared/domain.dart';

final class AccountAlreadyExistsFailure extends BackendFailure {
  AccountAlreadyExistsFailure() : super(HttpStatus.conflict);

  static const type = 'account_already_exists_failure';
}

```

File: /packages/shared/lib/domain/entities/data_or_failure.dart
Content:
```
import 'package:shared/domain.dart';

final class DataOrFailure<T> {
  const DataOrFailure(this.data, this.failure);

  const DataOrFailure._success(T data) : this(data, null);
  const DataOrFailure._failure(Failure failure) : this(null, failure);

  final T? data;
  final Failure? failure;

  bool get isSuccess => data != null;
  bool get isFailure => failure != null;

  R when<R>({
    required R Function(T data) success,
    required R Function(Failure failure) failure,
  }) {
    if (this.failure != null) {
      return failure(this.failure!);
    } else {
      return success(this.data as T);
    }
  }

  void onSuccess(void Function(T data) success) {
    if (this.data != null) {
      success(this.data!);
    }
  }

  void onFailure(void Function(Failure failure) failure) {
    if (this.failure != null) {
      failure(this.failure!);
    }
  }
}

typedef SuccessOrFailure = DataOrFailure<void>;
typedef ListDataOrFailure<T> = DataOrFailure<List<T>>;
typedef PaginatedDataOrFailure<T> = DataOrFailure<PaginatedList<T>>;

DataOrFailure<T> successful<T>(T data) => DataOrFailure<T>._success(data);
DataOrFailure<T> failed<T>(Failure failure) =>
    DataOrFailure<T>._failure(failure);

```

File: /packages/shared/lib/domain/entities/date.dart
Content:
```
import 'package:shared/domain.dart';

@immutable
final class Date {
  Date(DateTime dateTime)
      : dateTime = DateTime(dateTime.year, dateTime.month, dateTime.day);

  final DateTime dateTime;

  Map<String, dynamic> toJson() {
    return {
      'date': '${dateTime.toIso8601String()}',
    };
  }

  static Date fromJson(Map<String, dynamic> json) {
    return Date(
      DateTime.parse(json['date'] as String),
    );
  }

  static Date parse(String formattedString) {
    return Date(DateTime.parse(formattedString));
  }

  static Date now() => Date(DateTime.now());

  bool isBefore(Date other) => dateTime.isBefore(other.dateTime);

  bool isAfter(Date other) => dateTime.isAfter(other.dateTime);

  @override
  String toString() => DateFormat('yyyy-MM-dd').format(dateTime);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Date && other.dateTime == dateTime;
  }

  @override
  int get hashCode => dateTime.hashCode;
}

extension DateTimeToDate on DateTime {
  Date toDate() => Date(this);
}

```

File: /packages/shared/lib/domain/entities/categories/media.dart
Content:
```
import 'package:shared/domain.dart';

final class MediaCategory extends Category {
  const MediaCategory({
    required this.id,
    required this.name,
  }) : super(
          id: id,
          key: keyName,
          value: name,
        );

  final UuidValue id;
  final String name;

  static const String keyName = 'media';

  static MediaCategory fromJson(Map<String, dynamic> json) {
    return MediaCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
    );
  }

  MediaCategory copyWith({
    UuidValue? id,
    String? name,
  }) {
    return MediaCategory(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/categories/font.dart
Content:
```
import 'package:shared/domain.dart';

final class FontCategory extends Category {
  const FontCategory({
    required this.id,
    required this.name,
  }) : super(
          id: id,
          key: keyName,
          value: name,
        );

  final UuidValue id;
  final String name;

  static const String keyName = 'font';

  static FontCategory fromJson(Map<String, dynamic> json) {
    return FontCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
    );
  }

  FontCategory copyWith({
    UuidValue? id,
    String? name,
  }) {
    return FontCategory(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/categories/category.dart
Content:
```
import 'dart:convert';
import 'package:shared/domain.dart';

base class Category {
  const Category({
    required this.id,
    required this.key,
    required this.value,
    this.properties = const {},
  });

  final UuidValue id;
  final String key;
  final String value;
  final Map<String, String> properties;

  Map<String, dynamic> toJson() {
    return {
      'id': '$id',
      'key': key,
      'value': value,
      'properties': properties,
    };
  }

  static Category fromJson(Map<String, dynamic> json) {
    // TODO: отдельная библиотека с маршрутизацией категорий между модулями, либо инициализирование в скоуп
    if (json['key'] == ColorCategory.keyName) {
      return ColorCategory.fromJson(json);
    }

    if (json['key'] == StudioCategory.keyName) {
      return StudioCategory.fromJson(json);
    }

    if (json['key'] == ThemeCategory.keyName) {
      return ThemeCategory.fromJson(json);
    }

    if (json['key'] == FontCategory.keyName) {
      return FontCategory.fromJson(json);
    }

    return Category(
      id: UuidValue.fromString(json['id'] as String),
      key: json['key'] as String,
      value: json['value'] as String,
      properties: jsonDecode(
        json['properties'] as String,
      ) as Map<String, String>,
    );
  }

  @override
  operator ==(Object other) {
    return other is Category && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}

```

File: /packages/shared/lib/domain/entities/categories/studio.dart
Content:
```
import 'package:shared/domain.dart';

final class StudioCategory extends Category {
  StudioCategory({
    required this.id,
    required this.name,
    required this.logoUrl,
  }) : super(
          id: id,
          key: keyName,
          value: name,
          properties: {
            'logo_url': logoUrl.toString(),
          },
        );

  final UuidValue id;
  final String name;
  final Uri logoUrl;

  static const String keyName = 'studio';

  static StudioCategory fromJson(Map<String, dynamic> json) {
    return StudioCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
      logoUrl: Uri.parse(json['properties']['logo_url'] as String),
    );
  }

  StudioCategory copyWith({
    UuidValue? id,
    String? name,
  }) {
    return StudioCategory(
      id: id ?? this.id,
      name: name ?? this.name,
      logoUrl: logoUrl,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/categories/style.dart
Content:
```
import 'package:shared/domain.dart';

final class StyleCategory extends Category {
  const StyleCategory({
    required this.id,
    required this.name,
  }) : super(
          id: id,
          key: keyName,
          value: name,
        );

  final UuidValue id;
  final String name;

  static const String keyName = 'style';

  static StyleCategory fromJson(Map<String, dynamic> json) {
    return StyleCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
    );
  }

  StyleCategory copyWith({
    UuidValue? id,
    String? name,
  }) {
    return StyleCategory(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/categories/color.dart
Content:
```
import 'package:shared/domain.dart';

final class ColorCategory extends Category {
  ColorCategory({
    required this.id,
    required this.name,
    required this.hexColor,
  }) : super(
          id: id,
          key: keyName,
          value: name,
          properties: {'hex_color': '#${hexColor.toRadixString(16)}'},
        );

  final UuidValue id;
  final String name;
  final int hexColor;

  static const String keyName = 'color';

  static ColorCategory fromJson(Map<String, dynamic> json) {
    return ColorCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
      hexColor: int.parse(
          (json['properties']['hex_color'] as String).substring(1),
          radix: 16),
    );
  }

  ColorCategory copyWith({
    UuidValue? id,
    String? name,
    int? hexColor,
  }) {
    return ColorCategory(
      id: id ?? this.id,
      name: name ?? this.name,
      hexColor: hexColor ?? this.hexColor,
    );
  }
}

```

File: /packages/shared/lib/domain/entities/categories/theme.dart
Content:
```
import 'package:shared/domain.dart';

final class ThemeCategory extends Category {
  const ThemeCategory({
    required this.id,
    required this.name,
  }) : super(
          id: id,
          key: keyName,
          value: name,
        );

  final UuidValue id;
  final String name;

  static const String keyName = 'theme';

  static ThemeCategory fromJson(Map<String, dynamic> json) {
    return ThemeCategory(
      id: UuidValue.fromString(json['id'] as String),
      name: json['value'] as String,
    );
  }

  ThemeCategory copyWith({
    UuidValue? id,
    String? name,
  }) {
    return ThemeCategory(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

```

File: /packages/admin_app/pubspec.yaml
Content:
```
name: admin_app
description: "A new Flutter project."
publish_to: "none"
version: 0.1.0

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  shared_app:
  shared_admin:
  html: ^0.15.4
  puppeteer: ^3.8.0
  image_picker: ^1.1.0

dev_dependencies:
  build_runner: ^2.4.8
  auto_route_generator: ^9.0.0

flutter:
  uses-material-design: true
  fonts:
    - family: Cygre
      fonts:
        - asset: packages/shared_app/fonts/Cygre/Cygre-Thin.ttf
          weight: 100
        - asset: packages/shared_app/fonts/Cygre/Cygre-ThinIt.ttf
          weight: 100
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Light.ttf
          weight: 300
        - asset: packages/shared_app/fonts/Cygre/Cygre-LightIt.ttf
          weight: 300
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Regular.ttf
          weight: 400
        - asset: packages/shared_app/fonts/Cygre/Cygre-RegularIt.ttf
          weight: 400
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Medium.ttf
          weight: 500
        - asset: packages/shared_app/fonts/Cygre/Cygre-MediumIt.ttf
          weight: 500
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-SemiBold.ttf
          weight: 600
        - asset: packages/shared_app/fonts/Cygre/Cygre-SemiBoldIt.ttf
          weight: 600
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Bold.ttf
          weight: 700
        - asset: packages/shared_app/fonts/Cygre/Cygre-BoldIt.ttf
          weight: 700
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-ExtraBold.ttf
          weight: 800
        - asset: packages/shared_app/fonts/Cygre/Cygre-ExtraBoldIt.ttf
          weight: 800
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Black.ttf
          weight: 900
        - asset: packages/shared_app/fonts/Cygre/Cygre-BlackIt.ttf
          weight: 900
          style: italic

```

File: /packages/admin_app/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/extensions/data_extension.dart';
export 'infrastructure/extensions/storage_extension.dart';
export 'infrastructure/exports.dart';
export 'infrastructure/services/admin_session.dart';
export 'infrastructure/services/admin_daily.dart';
export 'infrastructure/services/admin_profile.dart';
export 'infrastructure/services/admin_account_management.dart';

```

File: /packages/admin_app/lib/presentation.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'presentation/application.dart';
export 'presentation/router.dart';
export 'presentation/localizations/failure_localization.dart';
export 'presentation/extensions/failure_extensions.dart';
export 'presentation/exports.dart';
export 'presentation/pages/branding/branding_page.dart';
export 'presentation/pages/branding/branding_logic.dart';
export 'presentation/pages/daily/daily_logic.dart';
export 'presentation/pages/daily/daily_page.dart';
export 'presentation/pages/users/users_logic.dart';
export 'presentation/pages/users/users_page.dart';
export 'presentation/pages/root/root_logic.dart';
export 'presentation/pages/root/root_page.dart';
export 'presentation/pages/authorization/authorization_page.dart';
export 'presentation/pages/authorization/authorization_logic.dart';
export 'presentation/services/admin_session_notifier.dart';

```

File: /packages/admin_app/lib/main.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

const _environment = Environment.development;

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);

  _initializeLogger();
  final rootScope = await _initializeDependencies();

  runApp(Application(rootScope.serviceProvider));
}

void _initializeLogger() {
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    switch (record.level) {
      case Level.SEVERE:
        debugPrint(
          '\x1B[31m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      case Level.WARNING:
        debugPrint(
          '\x1B[33m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      case Level.INFO:
        debugPrint(
          '\x1B[30m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      default:
        debugPrint('${record.level.name}: ${record.time}: ${record.message}');
    }
  });
}

Future<ServiceScope> _initializeDependencies() async {
  final services = ServiceCollection();

  services.addServices();
  services.addPresentation();

  final rootScope = services.buildRootScope();
  await rootScope.initialize();

  return rootScope;
}

extension _Dependencies on ServiceCollection {
  void addServices() {
    addInstance(StorageService(_environment));
    addAlias<Initializable, StorageService>();
    addAlias<Disposable, StorageService>();

    addInstance(BackendClientService(_environment));
    addAlias<Initializable, BackendClientService>();
    addAlias<Disposable, BackendClientService>();
    addSingletonFactory(
      (sp) => sp.getRequired<BackendClientService>().client,
    );

    addInstance(AdminSessionNotifier());
    addSingletonFactory(
      (sp) => AdminSessionServiceImpl(
        sp.getRequired<Dio>(),
        sp.getRequired<AdminSessionNotifier>(),
        sp.getRequired<StorageService>(),
      ),
    );
    addAlias<AdminSessionService, AdminSessionServiceImpl>();
    addAlias<Initializable, AdminSessionServiceImpl>();
    addAlias<Disposable, AdminSessionServiceImpl>();

    addSingletonFactory<AdminProfileService>(
      (sp) => AdminProfileServiceImpl(
        sp.getRequired<Dio>(),
      ),
    );

    addSingletonFactory<AdminAccountManagementService>(
      (sp) => AdminAccountManagementServiceImpl(
        sp.getRequired<Dio>(),
      ),
    );

    addSingletonFactory<AdminDailyService>(
      (sp) => AdminDailyServiceImpl(
        sp.getRequired<Dio>(),
      ),
    );
  }

  void addPresentation() {
    addInstance(ScaffoldMessengerProvider());
    addSingletonFactory(
      (sp) => AppRouter(sp.getRequired<AdminSessionNotifier>()),
    );
  }
}

```

File: /packages/admin_app/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/exports.dart';

```

File: /packages/admin_app/lib/infrastructure/extensions/data_extension.dart
Content:
```
import 'dart:convert';
import 'dart:io';

import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';

// TODO: refactor this
extension AdminDataExtension on Future<Response> {
  Future<DataOrFailure<T>> toData<T>(
    T Function(dynamic response) map, [
    dynamic Function(dynamic response)? from,
  ]) async {
    try {
      final response = await this;
      final result = map.call(
        from != null
            ? from(jsonDecode(response.data))
            : jsonDecode(response.data)['data'] ?? {},
      );

      return successful(result);
    } catch (e) {
      final failure = switch (e) {
        DioException() => AdminBackendFailureHandler.toFailure(e),
        SocketException() => () {
            Logger.root.warning('Network failure');
            return NetworkFailure();
          }(),
        _ => () {
            Logger.root.severe('DOMAIN FAILURE: $e');
            return DomainFailure();
          }(),
      };

      return failed(failure);
    }
  }
}

final class AdminBackendFailureHandler {
  static Failure toFailure(DioException e) {
    if (e.response?.data != null) {
      try {
        final failure = AdminBackendFailure.fromJson(
          (jsonDecode(e.response!.data) as Map<String, dynamic>)['failure']!,
        );

        Logger.root.warning('Failure: $failure');
        return failure;
      } catch (_) {
        return SharedBackendFailureHandler.toFailure(e);
      }
    }

    return SharedBackendFailureHandler.toFailure(e);
  }
}

```

File: /packages/admin_app/lib/infrastructure/extensions/storage_extension.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';

const _adminSessionKey = 'admin_session';

extension StorageExtension on StorageService {
  Future<void> saveSession(AdminSession session) {
    return preferencesForAllAccounts.put(_adminSessionKey, session.toJson());
  }

  Future<AdminSession?> getSession() async {
    final sessionJson = await preferencesForAllAccounts.get(_adminSessionKey);
    return sessionJson == null
        ? null
        : AdminSession.fromJson(sessionJson.cast<String, dynamic>());
  }

  Future<void> removeSession() {
    return preferencesForAllAccounts.delete(_adminSessionKey);
  }
}

```

File: /packages/admin_app/lib/infrastructure/exports.dart
Content:
```
export 'package:shared_app/infrastructure.dart' hide SharedDataExtension;

```

File: /packages/admin_app/lib/infrastructure/services/admin_session.dart
Content:
```
import 'dart:async';

import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

final class AdminSessionServiceImpl
    implements AdminSessionService, Initializable, Disposable {
  AdminSessionServiceImpl(
    this._dio,
    this._adminSessionNotifier,
    this._storageService,
  );

  final Dio _dio;
  final AdminSessionNotifier _adminSessionNotifier;
  final StorageService _storageService;

  Timer? sessionExpirationTimer;

  @override
  Future<void> initialize() async {
    final token = await _storageService.getSession();

    _adminSessionNotifier.value = token != null;
    _checkSessionExpiration(token);
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        final session = await _storageService.getSession();
        if (session != null) {
          options.headers['Authorization'] = 'Bearer ${session.token}';
        }
        return handler.next(options);
      },
      onResponse: (response, handler) async {
        if (response.statusCode == HttpStatus.unauthorized) signOut();

        if (response.statusCode == HttpStatus.badRequest) {
          final error = response.data?['failure']?['type'] ==
              SessionExpiredFailure().toSnakeCase();

          if (error) signOut();
        }
        return handler.next(response);
      },
    ));
  }

  @override
  Future<void> dispose() async {
    sessionExpirationTimer?.cancel();
  }

  @override
  Future<DataOrFailure<AdminSession>> signIn({
    required String email,
    required String totpCode,
  }) async {
    return await _dio.post('/sign-in', data: {
      'email': email,
      'totp_code': totpCode,
    }).toData((r) => AdminSession.fromJson(r))
      ..onSuccess((data) {
        _adminSessionNotifier.value = true;
        _checkSessionExpiration(data);
        _storageService.saveSession(data);
      });
  }

  @override
  Future<SuccessOrFailure> signOut() async {
    _adminSessionNotifier.value = false;
    sessionExpirationTimer?.cancel();

    final session = await _storageService.getSession();
    if (session == null) return failed(NotSignedInFailure());

    unawaited(_storageService.removeSession());
    return _dio
        .post(
          '/sign-out',
          options: Options(headers: {
            'Authorization': 'Bearer ${session.token}',
          }),
        )
        .toSuccess();
  }

  void _checkSessionExpiration(AdminSession? session) {
    if (session == null) return;

    sessionExpirationTimer = Timer(
      session.expires
          .difference(DateTime.now().add(const Duration(seconds: 5))),
      signOut,
    );
  }
}

```

File: /packages/admin_app/lib/infrastructure/services/admin_daily.dart
Content:
```
import 'dart:convert';

import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/domain.dart';

final class AdminDailyServiceImpl implements AdminDailyService {
  AdminDailyServiceImpl(this._dio);
  final Dio _dio;

  @override
  Future<ListDataOrFailure<Date>> getDates() {
    return _dio.get('/daily/dates').toListData((r) => Date.fromJson(r));
  }

  @override
  Future<ListDataOrFailure<DailyLink>> getLinksByDate(Date date) {
    return _dio
        .get('/daily/links/$date')
        .toListData((r) => DailyLink.fromJson(r));
  }

  @override
  Future<SuccessOrFailure> deleteByDate(Date date) {
    return _dio.delete('/daily/links/$date').toSuccess();
  }

  @override
  Future<SuccessOrFailure> setLinksByDate(
    Date date,
    List<DailyLinkRequest> links,
  ) {
    return _dio
        .put(
          '/daily/links/$date',
          data: jsonEncode({'items': links}),
        )
        .toSuccess();
  }
}

```

File: /packages/admin_app/lib/infrastructure/services/admin_profile.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';

final class AdminProfileServiceImpl implements AdminProfileService {
  AdminProfileServiceImpl(this._dio);

  final Dio _dio;

  @override
  Future<DataOrFailure<AdminProfile>> getProfile({
    required UuidValue accountId,
  }) {
    return _dio
        .get('/profile/$accountId')
        .toData((r) => AdminProfile.fromJson(r));
  }
}

```

File: /packages/admin_app/lib/infrastructure/services/admin_account_management.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';

final class AdminAccountManagementServiceImpl
    implements AdminAccountManagementService {
  AdminAccountManagementServiceImpl(this._dio);

  final Dio _dio;

  @override
  Future<DataOrFailure<AdminAccountWithTotp>> createAccount({
    required String email,
    required List<AdminAccountPermission> permissions,
  }) {
    return _dio.post('/sign-up', data: {
      'email': email,
      'permissions': permissions.map((e) => e.name).toList(),
    }).toData((r) => AdminAccountWithTotp.fromJson(r));
  }

  @override
  Future<ListDataOrFailure<AdminAccount>> getAccounts() {
    return _dio
        .get('/account')
        .toListData((r) => r.map((e) => AdminAccount.fromJson(e)).toList());
  }

  @override
  Future<DataOrFailure<AdminAccount>> getAccount({
    required UuidValue id,
  }) {
    return _dio.get('/account/$id').toData((r) => AdminAccount.fromJson(r));
  }

  @override
  Future<DataOrFailure<AdminAccount>> updateAccount({
    required UuidValue id,
    required String email,
    required String password,
    required List<AdminAccountPermission> permissions,
  }) {
    return _dio.put('/account/$id', data: {
      'email': email,
      'password': password,
      'permissions': permissions.map((e) => e.name).toList(),
    }).toData((r) => AdminAccount.fromJson(r));
  }

  @override
  Future<SuccessOrFailure> deleteAccount({
    required UuidValue id,
  }) {
    return _dio.delete('/account/$id').toSuccess();
  }
}

```

File: /packages/admin_app/lib/domain/exports.dart
Content:
```
export 'package:shared_app/domain.dart';
export 'package:shared_admin/domain.dart';

```

File: /packages/admin_app/lib/presentation/application.dart
Content:
```
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

final class Application extends StatelessWidget {
  const Application(this.serviceProvider, {super.key});

  final ServiceProvider serviceProvider;

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        Provider.value(value: serviceProvider),
      ],
      child: MaterialApp.router(
        localizationsDelegates: {
          ...SharedAppLocalizations.localizationsDelegates,
          ...AdminAppLocalizations.localizationsDelegates,
        }.toList(),
        supportedLocales: {
          ...SharedAppLocalizations.supportedLocales,
          ...AdminAppLocalizations.supportedLocales,
        }.toList(),
        scaffoldMessengerKey: serviceProvider
            .getRequired<ScaffoldMessengerProvider>()
            .scaffoldMessengerKey,
        debugShowCheckedModeBanner: false,
        routerConfig: serviceProvider.getRequired<AppRouter>().config(
            reevaluateListenable: serviceProvider.get<AdminSessionNotifier>()),
        title: 'Designgersss',
      ),
    );
  }
}

```

File: /packages/admin_app/lib/presentation/router.dart
Content:
```
import 'package:admin_app/presentation.dart';

part 'router.gr.dart';

@AutoRouterConfig(replaceInRouteName: 'Page,Route')
final class AppRouter extends RootStackRouter {
  AppRouter(this._adminSessionNotifier);

  final AdminSessionNotifier _adminSessionNotifier;

  @override
  List<AutoRoute> get routes {
    return [
      CustomRoute(
        page: RootRoute.page,
        initial: true,
        path: '/',
        children: [
          RedirectRoute(path: '', redirectTo: 'daily'),
          CustomRoute(
            page: DailyRoute.page,
            path: 'daily',
          ),
          CustomRoute(
            page: BrandingRoute.page,
            path: 'branding',
          ),
          CustomRoute(
            page: UsersRoute.page,
            path: 'users',
          ),
        ],
      ),
      CustomRoute(
        page: AuthorizationRoute.page,
        path: '/login',
      ),
    ];
  }

  @override
  late final List<AutoRouteGuard> guards = [
    AutoRouteGuard.simple(
      (resolver, router) {
        if (_adminSessionNotifier.value ||
            resolver.routeName == AuthorizationRoute.name) {
          resolver.next(true);
        } else {
          resolver.redirect(
            AuthorizationRoute(onResult: () => resolver.next(true)),
          );
        }
      },
    ),
  ];
}

```

File: /packages/admin_app/lib/presentation/localizations/localizations.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.
// ignore_for_file: library_private_types_in_public_api

import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

part 'ru.g.dart';
part 'en.g.dart';

abstract final class AdminAppLocalizationData {
  String get invalidCredentialsFailure;
  String welcomeMessage(String name);
  String get dateAlreadyExistsError;
  String get createDialog;
  String get confirmDialog;
  String get deleteDialog;
  String get cancelDialog;
  String get deleteDateMessage;
  String get createLinkTitle;
  String get changeLinkTitle;
  String get linkUrlHint;
  String get changeTypeTitle;
  String get newDateButton;
  String get createLinkButton;
  String get uploadFileButton;
  String get deleteDateButton;
  String get saveChangesButton;
  String get discardChangesButton;
  String get noDatesMessage;
  String get changeImageTitle;

  Map<String, String> get map;
}

final class AdminAppLocalizations {
  static const _AdminAppLocalizationsDelegate delegate =
      _AdminAppLocalizationsDelegate();

  static AdminAppLocalizationData of(BuildContext context) {
    return Localizations.of<AdminAppLocalizationData>(
      context,
      AdminAppLocalizationData,
    )!;
  }

  static const List<Locale> supportedLocales = [Locale('ru'), Locale('en')];

  static const List<LocalizationsDelegate> localizationsDelegates = [
    AdminAppLocalizations.delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];
}

final class _AdminAppLocalizationsDelegate
    extends LocalizationsDelegate<AdminAppLocalizationData> {
  const _AdminAppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) =>
      AdminAppLocalizations.supportedLocales.contains(locale);

  @override
  Future<AdminAppLocalizationData> load(Locale locale) async {
    switch (locale.languageCode) {
      case 'ru':
        return const RuAdminAppLocalizationData();
      case 'en':
        return const EnAdminAppLocalizationData();
      default:
        return const RuAdminAppLocalizationData();
    }
  }

  @override
  bool shouldReload(_AdminAppLocalizationsDelegate old) => false;
}

extension AdminAppLocalizationsExtension on BuildContext {
  AdminAppLocalizationData get adminAppLocalizations =>
      AdminAppLocalizations.of(this);
}


```

File: /packages/admin_app/lib/presentation/localizations/ru.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class RuAdminAppLocalizationData implements AdminAppLocalizationData {
  const RuAdminAppLocalizationData();

  @override
  String get invalidCredentialsFailure => r'Неправильная электронная почта или пароль.';
  @override
  String welcomeMessage(String name) => 'Добро пожаловать, $name!';
  @override
  String get dateAlreadyExistsError => r'Эта дата уже существует.';
  @override
  String get createDialog => r'Создать';
  @override
  String get confirmDialog => r'Подтвердить';
  @override
  String get deleteDialog => r'Удалить';
  @override
  String get cancelDialog => r'Отменить';
  @override
  String get deleteDateMessage => r'Вы уверены, что хотите удалить эту дату?';
  @override
  String get createLinkTitle => r'Создать ссылку';
  @override
  String get changeLinkTitle => r'Изменить ссылку';
  @override
  String get linkUrlHint => r'Введите ссылку';
  @override
  String get changeTypeTitle => r'Изменить тип';
  @override
  String get newDateButton => r'Новая дата';
  @override
  String get createLinkButton => r'Новая ссылка';
  @override
  String get uploadFileButton => r'Загрузить файл';
  @override
  String get deleteDateButton => r'Удалить дату';
  @override
  String get saveChangesButton => r'Сохранить изменения';
  @override
  String get discardChangesButton => r'Отменить изменения';
  @override
  String get noDatesMessage => r'Нет дат для отображения.';
  @override
  String get changeImageTitle => r'Изменить изображение';

  @override
  Map<String, String> get map => {
        'invalid_credentials_failure': r'Неправильная электронная почта или пароль.',
        'welcome_message': r'Добро пожаловать, {name}!',
        'date_already_exists_error': r'Эта дата уже существует.',
        'create_dialog': r'Создать',
        'confirm_dialog': r'Подтвердить',
        'delete_dialog': r'Удалить',
        'cancel_dialog': r'Отменить',
        'delete_date_message': r'Вы уверены, что хотите удалить эту дату?',
        'create_link_title': r'Создать ссылку',
        'change_link_title': r'Изменить ссылку',
        'link_url_hint': r'Введите ссылку',
        'change_type_title': r'Изменить тип',
        'new_date_button': r'Новая дата',
        'create_link_button': r'Новая ссылка',
        'upload_file_button': r'Загрузить файл',
        'delete_date_button': r'Удалить дату',
        'save_changes_button': r'Сохранить изменения',
        'discard_changes_button': r'Отменить изменения',
        'no_dates_message': r'Нет дат для отображения.',
        'change_image_title': r'Изменить изображение',
      };
}

```

File: /packages/admin_app/lib/presentation/localizations/failure_localization.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/presentation.dart';

final class AdminAppFailureLocalization {
  static String toLocalizedString(BuildContext context, Failure failure) {
    final localization = context.adminAppLocalizations;

    if (failure is BackendFailure) {
      if (failure.toSnakeCase() != 'backend_failure' &&
          localization.map.keys.contains(failure.toSnakeCase())) {
        return localization.map[failure.toSnakeCase()]!;
      } else {
        return SharedFailureLocalization.toLocalizedString(
          context,
          failure,
        );
      }
    } else {
      return SharedFailureLocalization.toLocalizedString(context, failure);
    }
  }
}

```

File: /packages/admin_app/lib/presentation/localizations/en.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class EnAdminAppLocalizationData implements AdminAppLocalizationData {
  const EnAdminAppLocalizationData();

  @override
  String get invalidCredentialsFailure => r'Wrong email or password.';
  @override
  String welcomeMessage(String name) => 'Welcome, $name!';
  @override
  String get dateAlreadyExistsError => r'This date already exists.';
  @override
  String get createDialog => r'Create';
  @override
  String get confirmDialog => r'Confirm';
  @override
  String get deleteDialog => r'Delete';
  @override
  String get cancelDialog => r'Cancel';
  @override
  String get deleteDateMessage => r'Are you sure you want to delete this date?';
  @override
  String get createLinkTitle => r'Create link';
  @override
  String get changeLinkTitle => r'Change link';
  @override
  String get linkUrlHint => r'Enter url';
  @override
  String get changeTypeTitle => r'Change type';
  @override
  String get newDateButton => r'New date';
  @override
  String get createLinkButton => r'Create link';
  @override
  String get uploadFileButton => r'Upload file';
  @override
  String get deleteDateButton => r'Delete date';
  @override
  String get saveChangesButton => r'Save changes';
  @override
  String get discardChangesButton => r'Discard changes';
  @override
  String get noDatesMessage => r'No dates found.';
  @override
  String get changeImageTitle => r'Change image';

  @override
  Map<String, String> get map => {
        'invalid_credentials_failure': r'Wrong email or password.',
        'welcome_message': r'Welcome, {name}!',
        'date_already_exists_error': r'This date already exists.',
        'create_dialog': r'Create',
        'confirm_dialog': r'Confirm',
        'delete_dialog': r'Delete',
        'cancel_dialog': r'Cancel',
        'delete_date_message': r'Are you sure you want to delete this date?',
        'create_link_title': r'Create link',
        'change_link_title': r'Change link',
        'link_url_hint': r'Enter url',
        'change_type_title': r'Change type',
        'new_date_button': r'New date',
        'create_link_button': r'Create link',
        'upload_file_button': r'Upload file',
        'delete_date_button': r'Delete date',
        'save_changes_button': r'Save changes',
        'discard_changes_button': r'Discard changes',
        'no_dates_message': r'No dates found.',
        'change_image_title': r'Change image',
      };
}

```

File: /packages/admin_app/lib/presentation/extensions/failure_extensions.dart
Content:
```
import 'package:admin_app/presentation.dart';
import 'package:shared/domain.dart';

extension FailureExtension on Failure {
  String toLocalizedString(BuildContext context) {
    return AdminAppFailureLocalization.toLocalizedString(context, this);
  }
}

```

File: /packages/admin_app/lib/presentation/exports.dart
Content:
```
export 'package:shared_app/presentation.dart' hide FailureExtension;
export 'localizations/localizations.g.dart';

```

File: /packages/admin_app/lib/presentation/router.gr.dart
Content:
```
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// AutoRouterGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

part of 'router.dart';

/// generated route for
/// [AuthorizationPage]
class AuthorizationRoute extends PageRouteInfo<AuthorizationRouteArgs> {
  AuthorizationRoute({
    Key? key,
    required VoidCallback onResult,
    List<PageRouteInfo>? children,
  }) : super(
          AuthorizationRoute.name,
          args: AuthorizationRouteArgs(
            key: key,
            onResult: onResult,
          ),
          initialChildren: children,
        );

  static const String name = 'AuthorizationRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      final args = data.argsAs<AuthorizationRouteArgs>();
      return AuthorizationPage(
        key: args.key,
        onResult: args.onResult,
      );
    },
  );
}

class AuthorizationRouteArgs {
  const AuthorizationRouteArgs({
    this.key,
    required this.onResult,
  });

  final Key? key;

  final VoidCallback onResult;

  @override
  String toString() {
    return 'AuthorizationRouteArgs{key: $key, onResult: $onResult}';
  }
}

/// generated route for
/// [BrandingPage]
class BrandingRoute extends PageRouteInfo<void> {
  const BrandingRoute({List<PageRouteInfo>? children})
      : super(
          BrandingRoute.name,
          initialChildren: children,
        );

  static const String name = 'BrandingRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const BrandingPage();
    },
  );
}

/// generated route for
/// [DailyPage]
class DailyRoute extends PageRouteInfo<void> {
  const DailyRoute({List<PageRouteInfo>? children})
      : super(
          DailyRoute.name,
          initialChildren: children,
        );

  static const String name = 'DailyRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const DailyPage();
    },
  );
}

/// generated route for
/// [RootPage]
class RootRoute extends PageRouteInfo<void> {
  const RootRoute({List<PageRouteInfo>? children})
      : super(
          RootRoute.name,
          initialChildren: children,
        );

  static const String name = 'RootRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const RootPage();
    },
  );
}

/// generated route for
/// [UsersPage]
class UsersRoute extends PageRouteInfo<void> {
  const UsersRoute({List<PageRouteInfo>? children})
      : super(
          UsersRoute.name,
          initialChildren: children,
        );

  static const String name = 'UsersRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const UsersPage();
    },
  );
}

```

File: /packages/admin_app/lib/presentation/pages/branding/branding_page.dart
Content:
```
import 'package:admin_app/presentation.dart';

@RoutePage()
final class BrandingPage extends WidgetWithLogic<BrandingLogic> {
  const BrandingPage({super.key});

  @override
  logicBuilder(context) => BrandingLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      body: logic.dataNotifier.when(
        success: (profile) {
          return const Text('Branding Page');
        },
      ),
    );
  }
}

```

File: /packages/admin_app/lib/presentation/pages/branding/branding_logic.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

final class BrandingLogic extends Logic {
  BrandingLogic(super.sp);

  late final dataNotifier = DataNotifier<AdminProfile>();

  @override
  Future<void> initLogic() async {
    super.initLogic();
    final currentAccountId =
        (await getRequired<StorageService>().getSession())!.accountId;

    dataNotifier.loadData(
      getRequired<AdminProfileService>()
          .getProfile(accountId: currentAccountId),
    );
  }

  @override
  void disposeLogic() {
    dataNotifier.dispose();
    super.disposeLogic();
  }

  void signOut() {
    getRequired<AdminSessionService>().signOut();
  }
}

```

File: /packages/admin_app/lib/presentation/pages/daily/daily_logic.dart
Content:
```
import 'dart:async';
import 'dart:typed_data';

import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

import 'package:image/image.dart' as img;
import 'package:html/parser.dart' as html_parser;

final class DailyLogic extends Logic {
  DailyLogic(super.sp);

  final datesDataNotifier = DataNotifier<List<Date>>();
  final selectedDateNotifier = ValueNotifier<Date?>(null);

  final linksDataNotifier = DataNotifier<List<List<DailyLinkRequest>>>();
  final isDraftNotifier = ValueNotifier<bool>(false);

  @override
  Future<void> initLogic() async {
    super.initLogic();

    datesDataNotifier.loadData(
      getRequired<AdminDailyService>().getDates(),
    );
  }

  @override
  void disposeLogic() {
    datesDataNotifier.dispose();
    super.disposeLogic();
  }

  Future<void> selectDate(Date? date) async {
    if (date == null) {
      selectedDateNotifier.value = null;
      linksDataNotifier.value = const DataStateInitial();
      isDraftNotifier.value = false;
      return;
    }

    if (selectedDateNotifier.value == date) return;
    selectedDateNotifier.value = date;

    final data = await getRequired<AdminDailyService>().getLinksByDate(date);

    data.when(
      success: (data) {
        final requests =
            data.map((e) => DailyLinkRequest.fromResponse(e)).toList();
        final items = [
          [
            requests[0],
            requests[1],
            requests[2],
          ],
          [
            requests[3],
            requests[4],
            requests[5],
            requests[6],
          ],
          [
            requests[7],
            requests[8],
            requests[9],
          ],
          [
            requests[10],
            requests[11],
            requests[12],
            requests[13],
            requests[14],
            requests[15],
            requests[16],
            requests[17],
          ],
        ];

        linksDataNotifier.value = DataStateSuccess(items);
      },
      failure: (failure) {
        linksDataNotifier.value = DataStateFailed(failure);
      },
    );

    isDraftNotifier.value = false;
  }

  Future<void> createDate() async {
    if (!datesDataNotifier.value.isSuccess) return;

    final result = await showDatePicker(
      context: context,
      initialDate: DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime(3000),
    );

    if (result == null) return;
    final date = Date(result);

    if (datesDataNotifier.value.asSuccess!.data.contains(date)) {
      await getRequired<ScaffoldMessengerProvider>()
          .scaffoldMessenger
          .showSnackBar(SnackBar(
            content: Text(context.adminAppLocalizations.dateAlreadyExistsError),
          ));
      return;
    }

    datesDataNotifier.value = DataStateSuccess(
      [...datesDataNotifier.value.asSuccess!.data, date],
    );
    selectedDateNotifier.value = date;

    linksDataNotifier.value = DataStateSuccess(_initialData);
    isDraftNotifier.value = true;
  }

  Future<void> deleteSelectedDate() async {
    if (!datesDataNotifier.value.isSuccess) return;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(context.adminAppLocalizations.confirmDialog),
          content: Text(context.adminAppLocalizations.deleteDateMessage),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(context.adminAppLocalizations.cancelDialog),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(context.adminAppLocalizations.confirmDialog),
            ),
          ],
        );
      },
    );

    if (result == false) return;

    final date = selectedDateNotifier.value!;
    unawaited(getRequired<AdminDailyService>().deleteByDate(date));

    datesDataNotifier.value = DataStateSuccess(datesDataNotifier
        .value.asSuccess!.data
        .where((d) => d != date)
        .toList());

    selectedDateNotifier.value = null;
    linksDataNotifier.value = const DataStateInitial();
    isDraftNotifier.value = false;
  }

  Future<void> discardChanges() async {
    final selectedDate = selectedDateNotifier.value!;

    selectedDateNotifier.value = null;
    linksDataNotifier.value = const DataStateInitial();
    isDraftNotifier.value = false;

    selectDate(selectedDate);
  }

  // Future<void> createLinkInSelectedDate() async {
  //   if (selectedDateNotifier.value == null) return;

  //   final url = await GetLinkDialog(
  //     title: context.adminAppLocalizations.createLinkTitle,
  //   ).show(context);
  //   if (url == null) return;

  //   final backup = linksDataNotifier.value.asSuccess!.data;
  //   linksDataNotifier.value = DataStateLoading();

  //   final response = await fetchPreviewData(
  //     url,
  //     backup.lastOrNull?.type ?? DailyLinkType.site,
  //   );

  //   response.when(
  //     success: (link) {
  //       isDraftNotifier.value = true;
  //       linksDataNotifier.value = DataStateSuccess(
  //         [...backup, link],
  //       );
  //     },
  //     failure: (failure) {
  //       linksDataNotifier.value = DataStateSuccess(backup);
  //       return get<ScaffoldMessengerProvider>()
  //           .scaffoldMessenger
  //           .showSnackBar(SnackBar(
  //             content: Text(failure.toLocalizedString(context)),
  //           ));
  //     },
  //   );
  // }

  Future<void> setPreviewFromUrl(DailyLinkRequest link) async {
    final backup = linksDataNotifier.value.asSuccess!;
    linksDataNotifier.value = const DataStateLoading();

    final response = await fetchPreviewData('${link.url}');

    response.when(
      success: (data) async {
        final url = await _uploadImage(UrlOrFile(url: data.$2));

        url.when(
          success: (url) {
            linksDataNotifier.value = backup;
            editLink(
              link.copyWith(
                title: data.$1,
                previewImageUrl: Uri.tryParse(url ?? ''),
              ),
            );
          },
          failure: (failure) {
            getRequired<ScaffoldMessengerProvider>()
                .scaffoldMessenger
                .showSnackBar(SnackBar(
                  content: Text(failure.toLocalizedString(context)),
                ));

            linksDataNotifier.value = backup;
          },
        );
      },
      failure: (failure) {
        getRequired<ScaffoldMessengerProvider>()
            .scaffoldMessenger
            .showSnackBar(SnackBar(
              content: Text(failure.toLocalizedString(context)),
            ));

        linksDataNotifier.value = backup;
      },
    );
  }

  Future<DataOrFailure<(String title, String? previewImageUrl)>>
      fetchPreviewData(String url) async {
    try {
      final dio = Dio();

      if (url.startsWith('https://www.behance.net/gallery/')) {
        final match = RegExp(r'\/(\d+)\/').firstMatch(url);
        if (match != null) {
          url =
              'https://www.behance.net/embed/project/${match.group(1)}?ilo0=1';
        }
      }

      final response = await dio.get(url);
      final document = html_parser.parse(response.data);

      final String title;
      String? previewImageUrl;

      if (url.startsWith('https://www.behance.net/embed/project/')) {
        title = document
                .querySelector('.e2e-EmbedShareProjectCover-projectName')
                ?.text
                .trim() ??
            document.head
                ?.querySelector("meta[property='og:title']")
                ?.attributes['content'] ??
            document.head?.querySelector('title')?.text ??
            'No title';

        previewImageUrl = document
                .querySelector('.EmbedShareProjectCover-image-OwG')
                ?.attributes['src'] ??
            document.head
                ?.querySelector("meta[property='og:image']")
                ?.attributes['content'];
      } else {
        title = document.head
                ?.querySelector("meta[property='og:title']")
                ?.attributes['content'] ??
            document.head?.querySelector('title')?.text ??
            'No title';
        previewImageUrl = document.head
            ?.querySelector("meta[property='og:image']")
            ?.attributes['content'];
      }

      if (previewImageUrl != null && previewImageUrl[0] == '/') {
        previewImageUrl = url + previewImageUrl.substring(1);
      }

      return successful(
        (title, previewImageUrl),
      );
    } on DioException catch (_) {
      return failed(NetworkFailure());
    }
  }

  Future<void> saveLinks() async {
    if (selectedDateNotifier.value == null) return;

    final date = selectedDateNotifier.value!;
    final links = linksDataNotifier.value.asSuccess!.data;

    linksDataNotifier.value = const DataStateLoading();
    isDraftNotifier.value = false;

    await getRequired<AdminDailyService>()
        .setLinksByDate(date, links.expand((e) => e).toList());
    linksDataNotifier.value = DataStateSuccess(links);
  }

  void editLink(DailyLinkRequest link) {
    final nestedList = linksDataNotifier.value.asSuccess!.data;
    for (var sublist in nestedList) {
      for (var i = 0; i < sublist.length; i++) {
        if (sublist[i] == link) {
          sublist[i] = link;
          linksDataNotifier.value = DataStateSuccess(nestedList);
          isDraftNotifier.value = true;
          return;
        }
      }
    }
  }

  Future<void> changeImage(DailyLinkRequest link) async {
    final urlOrFile = await GetImageUrlOrFileDialog(
      title: context.adminAppLocalizations.changeImageTitle,
      initialUrl: link.previewImageUrl?.toString(),
    ).show(context);
    if (urlOrFile == null) return;

    final backup = linksDataNotifier.value.asSuccess!;
    linksDataNotifier.value = const DataStateLoading();

    final response = await _uploadImage(urlOrFile);
    linksDataNotifier.value = backup;

    response.when(
      success: (url) {
        editLink(link.copyWith(previewImageUrl: Uri.tryParse(url ?? '')));
      },
      failure: (failure) {
        getRequired<ScaffoldMessengerProvider>()
            .scaffoldMessenger
            .showSnackBar(SnackBar(
              content: Text(failure.toLocalizedString(context)),
            ));
      },
    );
  }

  Future<DataOrFailure<String?>> _uploadImage(UrlOrFile urlOrFile) async {
    throw UnimplementedError();
    try {
      // final storage = getRequired<FirebaseStorageService>().storage;
      // final imagesRef = storage.ref('images/');
      // final imageFileRef = imagesRef.child('${const Uuid().v4()}.png');

      // late final Uint8List bytes;
      // if (urlOrFile.isFile) {
      //   bytes = await urlOrFile.file!.readAsBytes();
      // } else {
      //   if (urlOrFile.url == null) return successful(null);
      //   final response = await Dio().get(
      //     urlOrFile.url!,
      //     options: Options(responseType: ResponseType.bytes),
      //   );

      //   if (response.data == null) return successful(null);
      //   bytes = response.data;
      // }

      // img.Image image = img.decodeImage(bytes)!;
      // image = img.copyResize(
      //   image,
      //   width: 600,
      //   interpolation: img.Interpolation.cubic,
      // );
      // final newImageBytes = img.encodeJpg(image);

      // await imageFileRef.putData(
      //   newImageBytes,
      //   SettableMetadata(contentType: 'image/jpeg'),
      // );

      // return successful(await imageFileRef.getDownloadURL());
    } on DioException catch (_) {
      return failed(NetworkFailure());
    }
  }

  void changeTitle(DailyLinkRequest link, String title) {
    editLink(link.copyWith(title: title));
  }

  Future<void> changeUrl(DailyLinkRequest link, String url) async {
    if (!url.contains('http')) url = 'https://$url';
    editLink(link.copyWith(url: Uri.parse(url)));
  }

  void deleteLink(DailyLink link) {
    final backup = linksDataNotifier.value.asSuccess!.data;
    linksDataNotifier.value = DataStateSuccess(
      backup.where((l) => l != link).toList(),
    );
    isDraftNotifier.value = true;
  }
}

final _initialData = [
  [
    _createLink(DailyLinkType.video),
    _createLink(DailyLinkType.startup),
    _createLink(DailyLinkType.utility),
  ],
  [
    _createLink(DailyLinkType.site),
    _createLink(DailyLinkType.site),
    _createLink(DailyLinkType.site),
    _createLink(DailyLinkType.site),
  ],
  [
    _createLink(DailyLinkType.article),
    _createLink(DailyLinkType.article),
    _createLink(DailyLinkType.article),
  ],
  [
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
    _createLink(DailyLinkType.cases),
  ],
];

DailyLinkRequest _createLink(DailyLinkType type) {
  return DailyLinkRequest(
    title: 'Заголовок',
    url: Uri.parse('https://example.com/'),
    previewImageUrl: null,
    type: type,
    date: DateTime.now().toDate(),
  );
}

```

File: /packages/admin_app/lib/presentation/pages/daily/daily_page.dart
Content:
```
import 'package:admin_app/presentation.dart';
import 'package:image_picker/image_picker.dart';

@RoutePage()
final class DailyPage extends WidgetWithLogic<DailyLogic> {
  const DailyPage({super.key});

  @override
  logicBuilder(context) => DailyLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      body: logic.datesDataNotifier.when(
        success: (dates) {
          return logic.selectedDateNotifier.builder(
            (context, selectedDate, _) => Row(
              children: [
                SizedBox(
                  width: 300,
                  child: logic.isDraftNotifier.builder(
                    (context, isDraft, child) => IgnorePointer(
                      ignoring: isDraft,
                      child: Opacity(
                        opacity: isDraft ? 0.5 : 1,
                        child: child,
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        ListTile(
                          title:
                              Text(context.adminAppLocalizations.newDateButton),
                          leading: const Icon(Icons.add),
                          onTap: logic.createDate,
                        ),
                        if (dates.isEmpty)
                          ListTile(
                            title: Text(
                                context.adminAppLocalizations.noDatesMessage),
                          ),
                        Expanded(
                          child: ListView.builder(
                            itemCount: dates.length,
                            itemBuilder: (context, index) {
                              final date = dates[index];
                              return ListTile(
                                title: Text(date.toString()),
                                selected: selectedDate == date,
                                onTap: () {
                                  final value =
                                      selectedDate == date ? null : date;
                                  logic.selectDate(value);
                                },
                                selectedTileColor: Colors.black12,
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                const ColoredBox(
                  color: Colors.black12,
                  child: SizedBox(width: 1, height: double.infinity),
                ),
                Expanded(
                  child: ColoredBox(
                    color: Colors.white,
                    child: logic.linksDataNotifier.when(
                      success: (links) {
                        return Column(
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            Row(
                              children: [
                                // IntrinsicWidth(
                                //   child: ListTile(
                                //     title: Text(context.adminAppLocalizations
                                //         .createLinkButton),
                                //     leading: Icon(Icons.add),
                                //     onTap: logic.createLinkInSelectedDate,
                                //   ),
                                // ),
                                const Spacer(),
                                IntrinsicWidth(
                                  child: ListTile(
                                    title: Text(context.adminAppLocalizations
                                        .deleteDateButton),
                                    leading: const Icon(Icons.delete_forever),
                                    iconColor: Colors.red,
                                    textColor: Colors.red,
                                    onTap: logic.deleteSelectedDate,
                                  ),
                                ),
                                // отмена изменений

                                logic.isDraftNotifier.builder(
                                  (context, isDraft, __) => Opacity(
                                    opacity: !isDraft ? 0.5 : 1,
                                    child: Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        IntrinsicWidth(
                                          child: ListTile(
                                            title: Text(context
                                                .adminAppLocalizations
                                                .discardChangesButton),
                                            leading: const Icon(Icons.save),
                                            iconColor: Colors.black,
                                            textColor: Colors.black,
                                            onTap: !isDraft
                                                ? null
                                                : logic.discardChanges,
                                          ),
                                        ),
                                        Opacity(
                                          opacity: links.isEmpty ? 0.5 : 1,
                                          child: IntrinsicWidth(
                                            child: ListTile(
                                              title: Text(context
                                                  .adminAppLocalizations
                                                  .saveChangesButton),
                                              leading: const Icon(Icons.save),
                                              iconColor: Colors.blue,
                                              textColor: Colors.blue,
                                              onTap: !isDraft || links.isEmpty
                                                  ? null
                                                  : logic.saveLinks,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            Expanded(
                              child: SingleChildScrollView(
                                child: CollectionViewer(
                                  links,
                                  onChangeImage: logic.changeImage,
                                  onChangeTitle: logic.changeTitle,
                                  onChangeUrl: logic.changeUrl,
                                  onSetPreviewFromUrl: logic.setPreviewFromUrl,
                                ),
                              ),
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

final class UrlOrFile {
  const UrlOrFile({this.url, this.file});

  final String? url;
  final XFile? file;

  bool get isUrl => url != null;
  bool get isFile => file != null;
}

final class GetImageUrlOrFileDialog extends StatefulWidget {
  const GetImageUrlOrFileDialog({
    super.key,
    required this.title,
    this.initialUrl,
  });

  final String title;
  final String? initialUrl;

  Future<UrlOrFile?> show(BuildContext context) {
    return showDialog<UrlOrFile>(
      context: context,
      builder: (_) => this,
    );
  }

  @override
  State<GetImageUrlOrFileDialog> createState() =>
      _GetImageUrlOrFileDialogState();
}

final class _GetImageUrlOrFileDialogState
    extends State<GetImageUrlOrFileDialog> {
  late final TextEditingController _controller =
      TextEditingController(text: widget.initialUrl);

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(context) {
    return AlertDialog(
      title: Text(widget.title),
      content: TextField(
        controller: _controller,
        decoration: InputDecoration(
          hintText: context.adminAppLocalizations.linkUrlHint,
        ),
      ),
      actions: [
        TextButton(
          onPressed: () async {
            final file =
                await ImagePicker().pickImage(source: ImageSource.gallery);
            if (file == null) return;

            Navigator.of(context).pop(UrlOrFile(file: file));
          },
          child: Text(context.adminAppLocalizations.uploadFileButton),
        ),
        TextButton(
          onPressed: () => Navigator.of(context).pop(null),
          child: Text(context.adminAppLocalizations.cancelDialog),
        ),
        FilledButton(
          onPressed: () =>
              Navigator.of(context).pop(UrlOrFile(url: _controller.text)),
          child: Text(context.adminAppLocalizations.confirmDialog),
        ),
      ],
    );
  }
}

```

File: /packages/admin_app/lib/presentation/pages/users/users_logic.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

final class UsersLogic extends Logic {
  UsersLogic(super.sp);

  late final dataNotifier = DataNotifier<AdminProfile>();

  @override
  Future<void> initLogic() async {
    super.initLogic();
    final currentAccountId =
        (await getRequired<StorageService>().getSession())!.accountId;

    dataNotifier.loadData(
      getRequired<AdminProfileService>()
          .getProfile(accountId: currentAccountId),
    );
  }

  @override
  void disposeLogic() {
    dataNotifier.dispose();
    super.disposeLogic();
  }

  void signOut() {
    getRequired<AdminSessionService>().signOut();
  }
}

```

File: /packages/admin_app/lib/presentation/pages/users/users_page.dart
Content:
```
import 'package:admin_app/presentation.dart';

@RoutePage()
final class UsersPage extends WidgetWithLogic<UsersLogic> {
  const UsersPage({super.key});

  @override
  logicBuilder(context) => UsersLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      body: logic.dataNotifier.when(
        success: (profile) {
          return const Text('Users Page');
        },
      ),
    );
  }
}

```

File: /packages/admin_app/lib/presentation/pages/root/root_logic.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/infrastructure.dart';
import 'package:admin_app/presentation.dart';

final class RootLogic extends Logic {
  RootLogic(super.sp);

  final adminAccountDataNotifier = DataNotifier<AdminAccount>();
  final profileDataNotifier = DataNotifier<AdminProfile>();

  @override
  Future<void> initLogic() async {
    super.initLogic();
    final currentAccountId =
        (await getRequired<StorageService>().getSession())!.accountId;

    adminAccountDataNotifier.loadData(
      getRequired<AdminAccountManagementService>()
          .getAccount(id: currentAccountId),
    );

    profileDataNotifier.loadData(
      getRequired<AdminProfileService>()
          .getProfile(accountId: currentAccountId),
    );
  }

  @override
  void disposeLogic() {
    adminAccountDataNotifier.dispose();
    profileDataNotifier.dispose();
    super.disposeLogic();
  }

  void signOut() {
    getRequired<AdminSessionService>().signOut();
  }
}

```

File: /packages/admin_app/lib/presentation/pages/root/root_page.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/presentation.dart';

@RoutePage()
final class RootPage extends WidgetWithLogic<RootLogic> {
  const RootPage({super.key});

  @override
  logicBuilder(context) => RootLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      body: [logic.adminAccountDataNotifier, logic.profileDataNotifier].when(
        success: (dataList) {
          final account = dataList.get<AdminAccount>();
          final profile = dataList.get<AdminProfile>();
          final tabs = _getTabs(account);

          return AutoTabsRouter(
            routes: tabs.map((e) => e.route).toList(),
            builder: (context, child) {
              return Column(
                children: [
                  Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: Row(
                      children: [
                        ...[
                          for (int i = 0; i < tabs.length; i++)
                            _TabWidget(tabs, i),
                        ].separated(const SizedBox(width: 5)),
                        const Spacer(),
                        Text(
                          context.adminAppLocalizations
                              .welcomeMessage(profile.name),
                        ),
                        const SizedBox(width: 15),
                        ElevatedButton(
                          onPressed: logic.signOut,
                          child: Text(context.sharedAppLocalizations.signOut),
                        ),
                      ],
                    ),
                  ),
                  const ColoredBox(
                    color: Colors.black12,
                    child: SizedBox(height: 1, width: double.infinity),
                  ),
                  Expanded(child: child),
                ],
              );
            },
          );
        },
      ),
    );
  }
}

final class _TabWidget extends StatelessWidget {
  const _TabWidget(this.tabs, this.index);
  final List<_TabModel> tabs;
  final int index;

  @override
  Widget build(context) {
    final tabsRouter = AutoTabsRouter.of(context);
    final tab = tabs[index];

    if (tabsRouter.activeIndex == index) {
      return FilledButton.icon(
        label: Text(tab.title),
        icon: Icon(tab.icon),
        onPressed: () => tabsRouter.setActiveIndex(index),
      );
    } else {
      return ElevatedButton.icon(
        label: Text(tab.title),
        icon: Icon(tab.icon),
        onPressed: () => tabsRouter.setActiveIndex(index),
      );
    }
  }
}

List<_TabModel> _getTabs(AdminAccount account) => [
      if (account.hasPermissions([AdminAccountPermission.daily]))
        const _TabModel(
          title: 'Daily',
          icon: Icons.dashboard_rounded,
          route: DailyRoute(),
        ),
      if (account.hasPermissions([AdminAccountPermission.posts]))
        const _TabModel(
          title: 'Branding',
          icon: Icons.list_alt_rounded,
          route: BrandingRoute(),
        ),
      if (account.hasPermissions([AdminAccountPermission.users]))
        const _TabModel(
          title: 'Users',
          icon: Icons.account_box_outlined,
          route: UsersRoute(),
        ),
    ];

final class _TabModel {
  const _TabModel({
    required this.title,
    required this.icon,
    required this.route,
  });
  final String title;
  final IconData icon;
  final PageRouteInfo route;
}

```

File: /packages/admin_app/lib/presentation/pages/authorization/authorization_page.dart
Content:
```
import 'package:admin_app/presentation.dart';

@RoutePage()
final class AuthorizationPage extends WidgetWithLogic<AuthorizationLogic> {
  const AuthorizationPage({super.key, required this.onResult});

  final VoidCallback onResult;

  @override
  logicBuilder(context) => AuthorizationLogic(context, onResult);

  @override
  Widget build(context, logic) {
    return Scaffold(
      body: logic.dataNotifier.builder(
        builder: (context, state, _) {
          return LoadingDecorator(
            isLoading: state.isLoading,
            child: Center(
              child: SizedBox(
                width: 300,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    TextField(
                      controller: logic.emailController,
                      decoration: InputDecoration(
                        hintText: context.sharedAppLocalizations.email,
                      ),
                    ),
                    TextField(
                      controller: logic.totpCodeController,
                      decoration: InputDecoration(
                        hintText: context.sharedAppLocalizations.totpCode,
                      ),
                    ),
                    ElevatedButton(
                      onPressed: logic.signIn,
                      child: Text(context.sharedAppLocalizations.signIn),
                    ),
                  ].separated(const SizedBox(height: 10)),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

```

File: /packages/admin_app/lib/presentation/pages/authorization/authorization_logic.dart
Content:
```
import 'package:admin_app/domain.dart';
import 'package:admin_app/presentation.dart';

final class AuthorizationLogic extends Logic {
  AuthorizationLogic(super.context, this.onResult);

  final VoidCallback onResult;

  late final dataNotifier = DataNotifier<AdminSession>();

  final emailController = TextEditingController();
  final totpCodeController = TextEditingController();

  @override
  void disposeLogic() {
    dataNotifier.dispose();
    emailController.dispose();
    totpCodeController.dispose();
    super.disposeLogic();
  }

  Future<void> signIn() {
    final email = emailController.text;
    final totpCode = totpCodeController.text;
    if (email.isEmpty || totpCode.isEmpty) {
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text(context.sharedAppLocalizations.fillAllFieldsError),
        ),
      );
      return SynchronousFuture(null);
    }

    return dataNotifier.loadData(
      getRequired<AdminSessionService>()
          .signIn(email: email, totpCode: totpCode),
      onSuccess: (data) {
        onResult();
      },
      onFailure: (failure) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text(failure.toLocalizedString(context)),
          ),
        );
      },
    );
  }
}

```

File: /packages/admin_app/lib/presentation/services/admin_session_notifier.dart
Content:
```
import 'package:admin_app/presentation.dart';

final class AdminSessionNotifier extends ValueNotifier<bool> {
  AdminSessionNotifier() : super(false);
}

```

File: /packages/main_app/pubspec.yaml
Content:
```
name: main_app
description: "A new Flutter project."
publish_to: "none"
version: 0.1.0

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  shared_app:
  shared_main:
  html: ^0.15.4
  url_launcher: ^6.2.5
  svg_flutter: ^0.0.1
  flutter_portal: ^1.1.4

dev_dependencies:
  build_runner: ^2.4.8
  auto_route_generator: ^9.0.0

flutter:
  uses-material-design: true
  fonts:
    - family: Cygre
      fonts:
        - asset: packages/shared_app/fonts/Cygre/Cygre-Thin.ttf
          weight: 100
        - asset: packages/shared_app/fonts/Cygre/Cygre-ThinIt.ttf
          weight: 100
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Light.ttf
          weight: 300
        - asset: packages/shared_app/fonts/Cygre/Cygre-LightIt.ttf
          weight: 300
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Regular.ttf
          weight: 400
        - asset: packages/shared_app/fonts/Cygre/Cygre-RegularIt.ttf
          weight: 400
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Medium.ttf
          weight: 500
        - asset: packages/shared_app/fonts/Cygre/Cygre-MediumIt.ttf
          weight: 500
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-SemiBold.ttf
          weight: 600
        - asset: packages/shared_app/fonts/Cygre/Cygre-SemiBoldIt.ttf
          weight: 600
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Bold.ttf
          weight: 700
        - asset: packages/shared_app/fonts/Cygre/Cygre-BoldIt.ttf
          weight: 700
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-ExtraBold.ttf
          weight: 800
        - asset: packages/shared_app/fonts/Cygre/Cygre-ExtraBoldIt.ttf
          weight: 800
          style: italic
        - asset: packages/shared_app/fonts/Cygre/Cygre-Black.ttf
          weight: 900
        - asset: packages/shared_app/fonts/Cygre/Cygre-BlackIt.ttf
          weight: 900
          style: italic

```

File: /packages/main_app/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/extensions/data_extension.dart';
export 'infrastructure/exports.dart';
export 'infrastructure/services/category.dart';
export 'infrastructure/services/branding.dart';
export 'infrastructure/services/collection_link.dart';

```

File: /packages/main_app/lib/presentation.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'presentation/application.dart';
export 'presentation/router.dart';
export 'presentation/localizations/failure_localization.dart';
export 'presentation/extensions/failure_extensions.dart';
export 'presentation/exports.dart';
export 'presentation/pages/branding/branding_page.dart';
export 'presentation/pages/branding/branding_logic.dart';
export 'presentation/pages/studios/studios_page.dart';
export 'presentation/pages/studios/studios_logic.dart';
export 'presentation/pages/projects/projects_page.dart';
export 'presentation/pages/projects/projects_logic.dart';
export 'presentation/pages/projects/project_details/project_details_page.dart';
export 'presentation/pages/projects/project_details/project_details_logic.dart';
export 'presentation/pages/daily/daily_logic.dart';
export 'presentation/pages/daily/daily_page.dart';
export 'presentation/pages/root/root_logic.dart';
export 'presentation/pages/root/root_page.dart';
export 'presentation/pages/themes/themes_page.dart';
export 'presentation/pages/themes/themes_logic.dart';

```

File: /packages/main_app/lib/main.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/infrastructure.dart';
import 'package:main_app/presentation.dart';

const _environment = Environment.development;

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);

  _initializeLogger();
  final rootScope = await _initializeDependencies();

  runApp(Application(rootScope.serviceProvider));
}

void _initializeLogger() {
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    switch (record.level) {
      case Level.SEVERE:
        debugPrint(
          '\x1B[31m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      case Level.WARNING:
        debugPrint(
          '\x1B[33m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      case Level.INFO:
        debugPrint(
          '\x1B[30m${record.level.name}: ${record.time}: ${record.message}\x1B[0m',
        );
      default:
        debugPrint('${record.level.name}: ${record.time}: ${record.message}');
    }
  });
}

Future<ServiceScope> _initializeDependencies() async {
  final services = ServiceCollection();

  services.addServices();
  services.addPresentation();

  final rootScope = services.buildRootScope();
  await rootScope.initialize();

  return rootScope;
}

extension _Dependencies on ServiceCollection {
  void addServices() {
    addInstance(StorageService(_environment));
    addAlias<Initializable, StorageService>();
    addAlias<Disposable, StorageService>();

    addInstance(BackendClientService(_environment));
    addAlias<Initializable, BackendClientService>();
    addAlias<Disposable, BackendClientService>();
    addSingletonFactory(
      (sp) => sp.getRequired<BackendClientService>().client,
    );
    addSingletonFactory<CollectionLinkService>(
      (sp) => CollectionLinkServiceImpl(sp.getRequired<Dio>()),
    );
    addSingletonFactory<BrandingService>(
      (sp) => BrandingServiceImpl(sp.getRequired<Dio>()),
    );
    addSingletonFactory<CategoryService>(
      (sp) => CategoryServiceImpl(sp.getRequired<Dio>()),
    );
  }

  void addPresentation() {
    addInstance(ScaffoldMessengerProvider());
    addInstance(AppRouter());
  }
}

```

File: /packages/main_app/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/exports.dart';

```

File: /packages/main_app/lib/infrastructure/extensions/data_extension.dart
Content:
```
import 'dart:convert';
import 'dart:io';

import 'package:shared_app/infrastructure.dart';
import 'package:main_app/domain.dart';

// TODO: refactor this
extension MainDataExtension on Future<Response> {
  Future<DataOrFailure<T>> toData<T>(
    T Function(dynamic response) map, [
    dynamic Function(dynamic response)? from,
  ]) async {
    try {
      final response = await this;
      final result = map.call(
        from != null
            ? from(jsonDecode(response.data))
            : jsonDecode(response.data)['data'] ?? {},
      );

      return successful(result);
    } catch (e) {
      final failure = switch (e) {
        DioException() => SharedBackendFailureHandler.toFailure(e),
        SocketException() => () {
            Logger.root.warning('Network failure');
            return NetworkFailure();
          }(),
        _ => () {
            Logger.root.severe('DOMAIN FAILURE: $e');
            return DomainFailure();
          }(),
      };

      return failed(failure);
    }
  }
}

```

File: /packages/main_app/lib/infrastructure/exports.dart
Content:
```
export 'package:shared_app/infrastructure.dart' hide SharedDataExtension;

```

File: /packages/main_app/lib/infrastructure/services/category.dart
Content:
```
import 'package:main_app/infrastructure.dart';
import 'package:main_app/domain.dart';

final class CategoryServiceImpl implements CategoryService {
  CategoryServiceImpl(this._dio);

  final Dio _dio;

  @override
  Future<PaginatedDataOrFailure<Category>> getCategoriesByKey(
    String key, {
    UuidValue? cursor,
    required int limit,
  }) async {
    return _dio.get(
      '/categories/$key',
      queryParameters: {
        'cursor': cursor?.uuid,
        'limit': limit,
      },
    ).toPaginatedData((r) => Category.fromJson(r));
  }
}

```

File: /packages/main_app/lib/infrastructure/services/branding.dart
Content:
```
import 'package:main_app/infrastructure.dart';
import 'package:main_app/domain.dart';

final class BrandingServiceImpl implements BrandingService {
  BrandingServiceImpl(this._dio);

  final Dio _dio;

  @override
  Future<PaginatedDataOrFailure<BrandingProject>> getProjects({
    UuidValue? cursor,
    required int limit,
    required int childrenLimit,
  }) {
    return _dio.get(
      '/branding/projects',
      queryParameters: {
        'cursor': cursor?.uuid,
        'limit': limit,
        'children_limit': childrenLimit,
      },
    ).toPaginatedData((r) => BrandingProject.fromJson(r));
  }

  @override
  Future<PaginatedDataOrFailure<BrandingStudio>> getStudios({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) {
    return _dio.get(
      '/branding/studios',
      queryParameters: {
        'cursor': cursor?.uuid,
        'limit': limit,
        'preview_limit': previewLimit,
      },
    ).toPaginatedData((r) => BrandingStudio.fromJson(r));
  }

  @override
  Future<PaginatedDataOrFailure<BrandingTheme>> getThemes({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) {
    return _dio.get(
      '/branding/themes',
      queryParameters: {
        'cursor': cursor?.uuid,
        'limit': limit,
        'preview_limit': previewLimit,
      },
    ).toPaginatedData((r) => BrandingTheme.fromJson(r));
  }

  @override
  Future<PaginatedDataOrFailure<BrandingPost>> getPosts({
    UuidValue? cursor,
    required int limit,
    UuidValue? byProject,
    List<UuidValue> byCategories = const [],
  }) {
    return _dio.get(
      '/branding/posts',
      queryParameters: {
        'cursor': cursor?.uuid,
        'limit': limit,
        'by_project': byProject?.uuid,
        if (byCategories.isNotEmpty)
          'by_categories': byCategories.map((e) => e.uuid).join(','),
      },
    ).toPaginatedData((r) => BrandingPost.fromJson(r));
  }

  @override
  Future<DataOrFailure<BrandingProject>> getProjectById(
    UuidValue id, {
    required int childrenLimit,
  }) {
    return _dio.get(
      '/branding/project/$id',
      queryParameters: {
        'children_limit': childrenLimit,
      },
    ).toData((r) => BrandingProject.fromJson(r));
  }

  @override
  Future<DataOrFailure<BrandingPost>> getPostById(UuidValue id) {
    return _dio
        .get('/branding/post/$id')
        .toData((r) => BrandingPost.fromJson(r));
  }
}

```

File: /packages/main_app/lib/infrastructure/services/collection_link.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/infrastructure.dart';

final class CollectionLinkServiceImpl implements CollectionLinkService {
  CollectionLinkServiceImpl(this._dio);

  final Dio _dio;

  @override
  Future<ListDataOrFailure<Date>> getDates() {
    return _dio.get('/daily/dates').toListData((r) => Date.fromJson(r));
  }

  @override
  Future<ListDataOrFailure<DailyLink>> getLinksByDate(Date date) {
    return _dio
        .get('/daily/links/$date')
        .toListData((r) => DailyLink.fromJson(r));
  }
}

```

File: /packages/main_app/lib/domain/exports.dart
Content:
```
export 'package:shared_app/domain.dart';

```

File: /packages/main_app/lib/presentation/application.dart
Content:
```
import 'package:main_app/infrastructure.dart';
import 'package:main_app/presentation.dart';

final class Application extends StatelessWidget {
  const Application(this.dependencies, {super.key});

  final ServiceProvider dependencies;

  @override
  Widget build(BuildContext context) {
    final _appRouter = dependencies.getRequired<AppRouter>();
    return MultiProvider(
      providers: [
        Provider.value(value: dependencies),
      ],
      child: Portal(
        child: MaterialApp.router(
          localizationsDelegates: {
            ...SharedAppLocalizations.localizationsDelegates,
            ...MainAppLocalizations.localizationsDelegates,
          }.toList(),
          supportedLocales: {
            ...SharedAppLocalizations.supportedLocales,
            ...MainAppLocalizations.supportedLocales,
          }.toList(),
          scaffoldMessengerKey: dependencies
              .getRequired<ScaffoldMessengerProvider>()
              .scaffoldMessengerKey,
          debugShowCheckedModeBanner: false,
          routerDelegate: _appRouter.delegate(),
          routeInformationParser: _appRouter.defaultRouteParser(),
          title: 'Designersss',
          scrollBehavior: const _ScrollBehavior(),
          locale: const Locale('ru'),
        ),
      ),
    );
  }
}

final class _ScrollBehavior extends ScrollBehavior {
  const _ScrollBehavior();
  @override
  ScrollPhysics getScrollPhysics(BuildContext context) {
    switch (getPlatform(context)) {
      case TargetPlatform.iOS:
      case TargetPlatform.macOS:
      case TargetPlatform.android:
        return const BouncingScrollPhysics();
      case TargetPlatform.fuchsia:
      case TargetPlatform.linux:
      case TargetPlatform.windows:
        return const ClampingScrollPhysics();
    }
  }
}

```

File: /packages/main_app/lib/presentation/router.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

part 'router.gr.dart';

@AutoRouterConfig(replaceInRouteName: 'Page,Route')
final class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes {
    return [
      CustomRoute(
        page: RootRoute.page,
        initial: true,
        path: '/',
        transitionsBuilder: _transitionsBuilder,
        children: [
          RedirectRoute(path: '', redirectTo: 'daily'),
          CustomRoute(
            page: DailyRoute.page,
            path: 'daily',
            transitionsBuilder: _transitionsBuilder,
          ),
          CustomRoute(
            page: BrandingRoute.page,
            path: 'branding',
            transitionsBuilder: _transitionsBuilder,
            children: [
              RedirectRoute(path: '', redirectTo: 'projects'),
              CustomRoute(
                page: ProjectsRoute.page,
                path: 'projects',
                transitionsBuilder: _transitionsBuilder,
              ),
              CustomRoute(
                page: StudiosRoute.page,
                path: 'studios',
                transitionsBuilder: _transitionsBuilder,
              ),
              CustomRoute(
                page: ThemesRoute.page,
                path: 'themes',
                transitionsBuilder: _transitionsBuilder,
              ),
            ],
          ),
          CustomRoute(
            page: ProjectDetailsRoute.page,
            path: 'branding/project/:id',
            transitionsBuilder: _transitionsBuilder,
          ),
        ],
      ),
    ];
  }
}

Widget _transitionsBuilder(BuildContext context, Animation<double> animation,
    Animation<double> secondaryAnimation, Widget child) {
  return Stack(
    children: [
      FadeTransition(
        opacity: Tween<double>(
          begin: 1.0,
          end: 0.0,
        ).animate(CurvedAnimation(
          parent: secondaryAnimation,
          curve: const Interval(0.0, 0.5, curve: Curves.easeInOut),
        )),
        child: secondaryAnimation.isDismissed ? Container() : child,
      ),
      FadeTransition(
        opacity: Tween<double>(
          begin: 0.0,
          end: 1.0,
        ).animate(CurvedAnimation(
          parent: animation,
          curve: const Interval(0.5, 1.0, curve: Curves.easeInOut),
        )),
        child: secondaryAnimation.isDismissed ? child : Container(),
      ),
    ],
  );
}

```

File: /packages/main_app/lib/presentation/localizations/localizations.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.
// ignore_for_file: library_private_types_in_public_api

import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

part 'ru.g.dart';
part 'en.g.dart';

abstract final class MainAppLocalizationData {
  String get collectionTitle;
  String get brandingTitle;
  String get bookmarksTitle;
  String get settingsTitle;
  String get inDevelopment;
  String get search;
  String get projectsTitle;
  String get studiosTitle;
  String get themesTitle;
  String projectsCounter(String count);
  String get studio;
  String get theme;
  String get media;
  String get pallete;
  String get style;
  String get fonts;

  Map<String, String> get map;
}

final class MainAppLocalizations {
  static const _MainAppLocalizationsDelegate delegate =
      _MainAppLocalizationsDelegate();

  static MainAppLocalizationData of(BuildContext context) {
    return Localizations.of<MainAppLocalizationData>(
      context,
      MainAppLocalizationData,
    )!;
  }

  static const List<Locale> supportedLocales = [Locale('ru'), Locale('en')];

  static const List<LocalizationsDelegate> localizationsDelegates = [
    MainAppLocalizations.delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];
}

final class _MainAppLocalizationsDelegate
    extends LocalizationsDelegate<MainAppLocalizationData> {
  const _MainAppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) =>
      MainAppLocalizations.supportedLocales.contains(locale);

  @override
  Future<MainAppLocalizationData> load(Locale locale) async {
    switch (locale.languageCode) {
      case 'ru':
        return const RuMainAppLocalizationData();
      case 'en':
        return const EnMainAppLocalizationData();
      default:
        return const RuMainAppLocalizationData();
    }
  }

  @override
  bool shouldReload(_MainAppLocalizationsDelegate old) => false;
}

extension MainAppLocalizationsExtension on BuildContext {
  MainAppLocalizationData get mainAppLocalizations =>
      MainAppLocalizations.of(this);
}


```

File: /packages/main_app/lib/presentation/localizations/ru.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class RuMainAppLocalizationData implements MainAppLocalizationData {
  const RuMainAppLocalizationData();

  @override
  String get collectionTitle => r'Daily Dose of Design';
  @override
  String get brandingTitle => r'Брендинг';
  @override
  String get bookmarksTitle => r'Закладки';
  @override
  String get settingsTitle => r'Настройки';
  @override
  String get inDevelopment => r'В разработке';
  @override
  String get search => r'Поиск';
  @override
  String get projectsTitle => r'Проекты';
  @override
  String get studiosTitle => r'Студии';
  @override
  String get themesTitle => r'Индустрия';
  @override
  String projectsCounter(String count) => '$count проектов';
  @override
  String get studio => r'Студия';
  @override
  String get theme => r'Индустрия';
  @override
  String get media => r'Носители';
  @override
  String get pallete => r'Цвета';
  @override
  String get style => r'Стиль';
  @override
  String get fonts => r'Шрифты';

  @override
  Map<String, String> get map => {
        'collection_title': r'Daily Dose of Design',
        'branding_title': r'Брендинг',
        'bookmarks_title': r'Закладки',
        'settings_title': r'Настройки',
        'in_development': r'В разработке',
        'search': r'Поиск',
        'projects_title': r'Проекты',
        'studios_title': r'Студии',
        'themes_title': r'Индустрия',
        'projects_counter': r'{count} проектов',
        'studio': r'Студия',
        'theme': r'Индустрия',
        'media': r'Носители',
        'pallete': r'Цвета',
        'style': r'Стиль',
        'fonts': r'Шрифты',
      };
}

```

File: /packages/main_app/lib/presentation/localizations/failure_localization.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

final class AdminAppFailureLocalization {
  static String toLocalizedString(BuildContext context, Failure failure) {
    final localization = context.mainAppLocalizations;

    if (failure is BackendFailure) {
      if (failure.toSnakeCase() != 'backend_failure' &&
          localization.map.keys.contains(failure.toSnakeCase())) {
        return localization.map[failure.toSnakeCase()]!;
      } else {
        return SharedFailureLocalization.toLocalizedString(
          context,
          failure,
        );
      }
    } else {
      return SharedFailureLocalization.toLocalizedString(context, failure);
    }
  }
}

```

File: /packages/main_app/lib/presentation/localizations/en.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class EnMainAppLocalizationData implements MainAppLocalizationData {
  const EnMainAppLocalizationData();

  @override
  String get collectionTitle => r'Daily Dose of Design';
  @override
  String get brandingTitle => r'Branding';
  @override
  String get bookmarksTitle => r'Bookmarks';
  @override
  String get settingsTitle => r'Settings';
  @override
  String get inDevelopment => r'In development';
  @override
  String get search => r'Search';
  @override
  String get projectsTitle => r'Projects';
  @override
  String get studiosTitle => r'Studios';
  @override
  String get themesTitle => r'Theme';
  @override
  String projectsCounter(String count) => '$count projects';
  @override
  String get studio => r'Studio';
  @override
  String get theme => r'Theme';
  @override
  String get media => r'Media';
  @override
  String get pallete => r'Pallete';
  @override
  String get style => r'Style';
  @override
  String get fonts => r'Fonts';

  @override
  Map<String, String> get map => {
        'collection_title': r'Daily Dose of Design',
        'branding_title': r'Branding',
        'bookmarks_title': r'Bookmarks',
        'settings_title': r'Settings',
        'in_development': r'In development',
        'search': r'Search',
        'projects_title': r'Projects',
        'studios_title': r'Studios',
        'themes_title': r'Theme',
        'projects_counter': r'{count} projects',
        'studio': r'Studio',
        'theme': r'Theme',
        'media': r'Media',
        'pallete': r'Pallete',
        'style': r'Style',
        'fonts': r'Fonts',
      };
}

```

File: /packages/main_app/lib/presentation/extensions/failure_extensions.dart
Content:
```
import 'package:main_app/presentation.dart';
import 'package:shared/domain.dart';

extension FailureExtension on Failure {
  String toLocalizedString(BuildContext context) {
    return AdminAppFailureLocalization.toLocalizedString(context, this);
  }
}

```

File: /packages/main_app/lib/presentation/exports.dart
Content:
```
export 'package:shared_app/presentation.dart' hide FailureExtension;
export 'localizations/localizations.g.dart';
export 'package:flutter_portal/flutter_portal.dart';

```

File: /packages/main_app/lib/presentation/router.gr.dart
Content:
```
// GENERATED CODE - DO NOT MODIFY BY HAND

// **************************************************************************
// AutoRouterGenerator
// **************************************************************************

// ignore_for_file: type=lint
// coverage:ignore-file

part of 'router.dart';

/// generated route for
/// [BrandingPage]
class BrandingRoute extends PageRouteInfo<void> {
  const BrandingRoute({List<PageRouteInfo>? children})
      : super(
          BrandingRoute.name,
          initialChildren: children,
        );

  static const String name = 'BrandingRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const BrandingPage();
    },
  );
}

/// generated route for
/// [DailyPage]
class DailyRoute extends PageRouteInfo<void> {
  const DailyRoute({List<PageRouteInfo>? children})
      : super(
          DailyRoute.name,
          initialChildren: children,
        );

  static const String name = 'DailyRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const DailyPage();
    },
  );
}

/// generated route for
/// [ProjectDetailsPage]
class ProjectDetailsRoute extends PageRouteInfo<ProjectDetailsRouteArgs> {
  ProjectDetailsRoute({
    required String id,
    Key? key,
    BrandingProject? cachedData,
    List<PageRouteInfo>? children,
  }) : super(
          ProjectDetailsRoute.name,
          args: ProjectDetailsRouteArgs(
            id: id,
            key: key,
            cachedData: cachedData,
          ),
          rawPathParams: {'id': id},
          initialChildren: children,
        );

  static const String name = 'ProjectDetailsRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      final pathParams = data.inheritedPathParams;
      final args = data.argsAs<ProjectDetailsRouteArgs>(
          orElse: () =>
              ProjectDetailsRouteArgs(id: pathParams.getString('id')));
      return ProjectDetailsPage(
        args.id,
        key: args.key,
        cachedData: args.cachedData,
      );
    },
  );
}

class ProjectDetailsRouteArgs {
  const ProjectDetailsRouteArgs({
    required this.id,
    this.key,
    this.cachedData,
  });

  final String id;

  final Key? key;

  final BrandingProject? cachedData;

  @override
  String toString() {
    return 'ProjectDetailsRouteArgs{id: $id, key: $key, cachedData: $cachedData}';
  }
}

/// generated route for
/// [ProjectsPage]
class ProjectsRoute extends PageRouteInfo<void> {
  const ProjectsRoute({List<PageRouteInfo>? children})
      : super(
          ProjectsRoute.name,
          initialChildren: children,
        );

  static const String name = 'ProjectsRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const ProjectsPage();
    },
  );
}

/// generated route for
/// [RootPage]
class RootRoute extends PageRouteInfo<void> {
  const RootRoute({List<PageRouteInfo>? children})
      : super(
          RootRoute.name,
          initialChildren: children,
        );

  static const String name = 'RootRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const RootPage();
    },
  );
}

/// generated route for
/// [StudiosPage]
class StudiosRoute extends PageRouteInfo<void> {
  const StudiosRoute({List<PageRouteInfo>? children})
      : super(
          StudiosRoute.name,
          initialChildren: children,
        );

  static const String name = 'StudiosRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const StudiosPage();
    },
  );
}

/// generated route for
/// [ThemesPage]
class ThemesRoute extends PageRouteInfo<void> {
  const ThemesRoute({List<PageRouteInfo>? children})
      : super(
          ThemesRoute.name,
          initialChildren: children,
        );

  static const String name = 'ThemesRoute';

  static PageInfo page = PageInfo(
    name,
    builder: (data) {
      return const ThemesPage();
    },
  );
}

```

File: /packages/main_app/lib/presentation/pages/branding/branding_page.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

@RoutePage()
final class BrandingPage extends WidgetWithLogic<BrandingLogic> {
  const BrandingPage({super.key});

  @override
  logicBuilder(context) => BrandingLogic(context);

  @override
  Widget build(context, logic) {
    final _tabs = [
      _TabModel(
        title: context.mainAppLocalizations.projectsTitle,
        path: 'projects',
        route: ProjectsRoute(),
      ),
      _TabModel(
        title: context.mainAppLocalizations.studiosTitle,
        path: 'studios',
        route: StudiosRoute(),
      ),
      _TabModel(
        title: context.mainAppLocalizations.themesTitle,
        path: 'themes',
        route: ThemesRoute(),
      ),
    ];

    final _categories = <String, String>{
      ThemeCategory.keyName: context.mainAppLocalizations.theme,
      MediaCategory.keyName: context.mainAppLocalizations.media,
      ColorCategory.keyName: context.mainAppLocalizations.pallete,
      StyleCategory.keyName: context.mainAppLocalizations.style,
      FontCategory.keyName: context.mainAppLocalizations.fonts,
    };

    return ValueListenableBuilder(
      valueListenable: logic.selectedCategoriesNotifier,
      builder: (context, selectedCategories, _) => Scaffold(
        backgroundColor: const Color(0xFFFBFBFB),
        body: logic.searchResultsDataNotifier.builder(
          builder: (context, searchedPosts, _) => Column(
            children: [
              ValueListenableBuilder(
                  valueListenable: logic.isOpenedSearchMenuNotifier,
                  builder: (context, isOpened, _) {
                    return PortalTarget(
                      visible: isOpened,
                      anchor: const Filled(),
                      portalFollower: GestureDetector(
                        onTap: logic.closeSearchMenu,
                        child: PlayAnimationBuilder<double>(
                          tween: Tween(begin: 0, end: 1),
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.fastOutSlowIn,
                          builder: (context, value, child) {
                            return Opacity(opacity: value, child: child);
                          },
                          child: Container(color: Colors.black26),
                        ),
                      ),
                      child: PortalTarget(
                        visible: isOpened,
                        anchor: const Aligned(
                          follower: Alignment.topLeft,
                          target: Alignment.topLeft,
                          offset: Offset(-308, 0),
                        ),
                        portalFollower: Padding(
                          padding: const EdgeInsets.only(left: 307),
                          child: PlayAnimationBuilder<double>(
                            tween: Tween(begin: 90, end: 500),
                            duration: const Duration(milliseconds: 300),
                            curve: Curves.fastOutSlowIn,
                            builder: (context, value, child) {
                              return Container(
                                width: double.infinity,
                                height: value,
                                decoration: const BoxDecoration(
                                  color: Colors.white,
                                ),
                                child: child,
                              );
                            },
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.stretch,
                              children: [
                                Container(
                                  height: 84,
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 20,
                                    vertical: 16,
                                  ),
                                  decoration: const BoxDecoration(
                                    border: Border(
                                      bottom: BorderSide(
                                        color: Color(0x33000000),
                                      ),
                                    ),
                                  ),
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: ListView(
                                          scrollDirection: Axis.horizontal,
                                          children: [
                                            for (final category
                                                in selectedCategories)
                                              Container(
                                                padding:
                                                    const EdgeInsets.symmetric(
                                                  horizontal: 16,
                                                  vertical: 12,
                                                ),
                                                margin: const EdgeInsets.only(
                                                    right: 10),
                                                decoration: const BoxDecoration(
                                                  color: Color(0xFF000000),
                                                ),
                                                child: Row(
                                                  children: [
                                                    Text(
                                                      category.value,
                                                      style: const TextStyle(
                                                        fontFamily: 'Cygre',
                                                        color:
                                                            Color(0xFFFBFBFB),
                                                        fontSize: 22,
                                                        fontWeight:
                                                            FontWeight.w500,
                                                        height: 24.2 / 22,
                                                      ),
                                                    ),
                                                    const SizedBox(width: 10),
                                                    Clickable(
                                                      onTap: () =>
                                                          logic.removeCategory(
                                                              category),
                                                      child: const Icon(
                                                        Icons.close,
                                                        size: 18,
                                                        color:
                                                            Color(0xFFFBFBFB),
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ),
                                            if (selectedCategories.isEmpty)
                                              Text(
                                                context.mainAppLocalizations
                                                    .search,
                                                style: const TextStyle(
                                                  fontFamily: 'Cygre',
                                                  color: Color(0xFFC9C9C9),
                                                  fontSize: 32,
                                                  fontWeight: FontWeight.w500,
                                                  height: 51.74 / 32,
                                                ),
                                              ),
                                          ],
                                        ),
                                      ),
                                      Clickable(
                                        onTap: !logic.isSearchResultsAvailable
                                            ? null
                                            : logic.closeSearchMenu,
                                        child: const Icon(
                                          Icons.arrow_forward,
                                          size: 32,
                                          color: Color(0xFF000000),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                Expanded(
                                  child: Row(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.stretch,
                                    children: [
                                      Container(
                                        width: 270,
                                        decoration: const BoxDecoration(
                                          border: Border(
                                            right: BorderSide(
                                              color: Color(0x33000000),
                                            ),
                                          ),
                                        ),
                                        child: Padding(
                                          padding: const EdgeInsets.all(20),
                                          child: ValueListenableBuilder(
                                              valueListenable: logic
                                                  .selectedCategoryKeyNotifier,
                                              builder:
                                                  (context, selectedKey, _) {
                                                return ListView.separated(
                                                  itemCount: _categories.length,
                                                  itemBuilder:
                                                      (context, index) {
                                                    final key = _categories.keys
                                                        .elementAt(index);
                                                    final selectedIndex =
                                                        _categories.keys
                                                            .toList()
                                                            .indexOf(
                                                                selectedKey);

                                                    return Clickable(
                                                      onTap: () => logic
                                                          .selectCategoryKey(
                                                              _categories.keys
                                                                  .elementAt(
                                                                      index)),
                                                      child: Text(
                                                        _categories[key]!,
                                                        style: TextStyle(
                                                          fontFamily: 'Cygre',
                                                          color: selectedIndex ==
                                                                  index
                                                              ? const Color(
                                                                  0xFF000000)
                                                              : const Color(
                                                                  0xFF979797),
                                                          fontSize: 26,
                                                          fontWeight:
                                                              FontWeight.w500,
                                                          height: 42.04 / 26,
                                                        ),
                                                      ),
                                                    );
                                                  },
                                                  separatorBuilder: (_, __) =>
                                                      const SizedBox(height: 6),
                                                );
                                              }),
                                        ),
                                      ),
                                      Expanded(
                                        child:
                                            logic.categoriesDataNotifier.when(
                                          success: (data) => ListView.separated(
                                            controller: logic.scrollController,
                                            padding: const EdgeInsets.all(20),
                                            itemCount: data.length,
                                            itemBuilder: (context, index) {
                                              final category = data[index];

                                              return Clickable(
                                                onTap: selectedCategories
                                                        .contains(category)
                                                    ? null
                                                    : () =>
                                                        logic.selectCategory(
                                                            category),
                                                child: Text(
                                                  category.value,
                                                  style: const TextStyle(
                                                    fontFamily: 'Cygre',
                                                    color: Color(0xFF000000),
                                                    fontSize: 18,
                                                    fontWeight: FontWeight.w500,
                                                    height: 29.11 / 18,
                                                  ),
                                                ),
                                              );
                                            },
                                            separatorBuilder: (_, __) =>
                                                const SizedBox(height: 6),
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 20,
                            vertical: 16,
                          ),
                          decoration: const BoxDecoration(
                            border: Border(
                              bottom: BorderSide(
                                color: Color(0x33000000),
                              ),
                            ),
                          ),
                          child: Expanded(
                            child: Row(
                              children: [
                                Clickable(
                                  onTap: logic.openSearchMenu,
                                  child: Text.rich(
                                    TextSpan(
                                      style: const TextStyle(
                                        fontFamily: 'Cygre',
                                        color: Color(0xFF000000),
                                        fontSize: 32,
                                        fontWeight: FontWeight.w500,
                                        height: 51.74 / 32,
                                      ),
                                      children: [
                                        const WidgetSpan(
                                          child: Padding(
                                            padding: EdgeInsets.only(right: 20),
                                            child: Icon(
                                              Icons.search,
                                              size: 32,
                                              color: Color(0xFF000000),
                                            ),
                                          ),
                                          alignment:
                                              PlaceholderAlignment.baseline,
                                          baseline: TextBaseline.ideographic,
                                        ),
                                        if (selectedCategories.isEmpty)
                                          TextSpan(
                                            text: context
                                                .mainAppLocalizations.search,
                                          ),
                                      ],
                                    ),
                                  ),
                                ),
                                for (final category in selectedCategories)
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: 12,
                                    ),
                                    margin: const EdgeInsets.only(right: 10),
                                    decoration: const BoxDecoration(
                                      color: Color(0xFF000000),
                                    ),
                                    child: Row(
                                      children: [
                                        Text(
                                          category.value,
                                          style: const TextStyle(
                                            fontFamily: 'Cygre',
                                            color: Color(0xFFFBFBFB),
                                            fontSize: 22,
                                            fontWeight: FontWeight.w500,
                                            height: 24.2 / 22,
                                          ),
                                        ),
                                        const SizedBox(width: 10),
                                        Clickable(
                                          onTap: () =>
                                              logic.removeCategory(category),
                                          child: const Icon(
                                            Icons.close,
                                            size: 18,
                                            color: Color(0xFFFBFBFB),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    );
                  }),
              if (searchedPosts.isInitial) ...[
                ChangeNotifierProvider(
                  create: (_) => _Notifier(),
                  child: Consumer<_Notifier>(
                    builder: (context, _, __) {
                      return Padding(
                        padding: const EdgeInsets.all(20),
                        child: Row(
                          children: [
                            for (final tab in _tabs) _TabWidget(tab),
                          ].separated(const SizedBox(width: 32)),
                        ),
                      );
                    },
                  ),
                ),
                Expanded(
                  child: Provider<BrandingLogic>.value(
                    value: logic,
                    child: const AutoRouter(),
                  ),
                ),
              ],
              if (!searchedPosts.isInitial) ...[
                Expanded(
                  child: searchedPosts.whenOrDefault(
                    context,
                    success: (posts, failure) => SearchedPostsViewer(
                      posts,
                      onPostPressed: logic.openPost,
                      onEndReached: logic.loadMoreSearchResults,
                      isHasMore: failure == null,
                    ),
                    loadingMore: (posts) => SearchedPostsViewer(
                      posts,
                      onPostPressed: logic.openPost,
                      onEndReached: logic.loadMoreSearchResults,
                      isHasMore: true,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

final class _TabWidget extends StatefulWidget {
  const _TabWidget(this.tab);
  final _TabModel tab;

  @override
  State<_TabWidget> createState() => _TabWidgetState();
}

final class _TabWidgetState extends State<_TabWidget> {
  StackRouter? router;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      setState(() {
        router = context.innerRouterOf<StackRouter>(BrandingRoute.name);
      });
    });
  }

  @override
  Widget build(context) {
    final isCurrent =
        router?.stack.last.routeData.path.contains(widget.tab.path) ?? false;

    return Clickable(
      onTap: () {
        setState(() {
          router?.push(widget.tab.route);
          context.read<_Notifier>().update();
        });
      },
      child: Row(
        children: [
          Text(
            widget.tab.title,
            style: TextStyle(
              fontFamily: 'Cygre',
              fontSize: 26,
              fontWeight: FontWeight.w500,
              height: 42.04 / 26,
              color: isCurrent ? Colors.black : const Color(0xFF9A9A9A),
            ),
          ),
        ],
      ),
    );
  }
}

final class _TabModel {
  const _TabModel({
    required this.title,
    required this.route,
    required this.path,
  });
  final String title;
  final PageRouteInfo route;
  final String path;
}

//TODO: refactor
final class _Notifier extends ChangeNotifier {
  void update() {
    notifyListeners();
  }
}

```

File: /packages/main_app/lib/presentation/pages/branding/branding_logic.dart
Content:
```
import 'dart:async';

import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

const _limit = 50;

final class BrandingLogic extends Logic {
  BrandingLogic(super.context);

  final isOpenedSearchMenuNotifier = ValueNotifier(false);
  final selectedCategoryKeyNotifier = ValueNotifier(ThemeCategory.keyName);
  final selectedCategoriesNotifier = ValueNotifier<List<Category>>([]);

  final categoriesDataNotifier = DataNotifier<PaginatedList<Category>>();
  final searchResultsDataNotifier = DataNotifier<PaginatedList<BrandingPost>>();

  late final scrollController = ScrollController()..addListener(_onScroll);
  Timer? _timer;
  bool _antispamEnabled = false;

  @override
  Future<void> initLogic() async {
    super.initLogic();

    await categoriesDataNotifier.loadData(
      getRequired<CategoryService>().getCategoriesByKey(
        selectedCategoryKeyNotifier.value,
        limit: _limit,
      ),
    );
  }

  @override
  void disposeLogic() {
    isOpenedSearchMenuNotifier.dispose();
    selectedCategoryKeyNotifier.dispose();
    categoriesDataNotifier.dispose();

    scrollController.removeListener(_onScroll);
    scrollController.dispose();
    _timer?.cancel();

    super.disposeLogic();
  }

  void _antispam() {
    _antispamEnabled = true;
    _timer = Timer(const Duration(milliseconds: 200), () {
      _antispamEnabled = false;
    });
  }

  void _onScroll() {
    if (!categoriesDataNotifier.value.isSuccess) return;

    final hasNext = categoriesDataNotifier.value.asSuccess!.data.hasNext;
    if (scrollController.position.pixels >=
            scrollController.position.maxScrollExtent - 500 &&
        hasNext &&
        !_antispamEnabled) {
      _antispam();
      _loadMore();
    }
  }

  void openSearchMenu() => isOpenedSearchMenuNotifier.value = true;

  Future<void> closeSearchMenu() {
    isOpenedSearchMenuNotifier.value = false;
    return loadSearchResults();
  }

  Future<void> selectCategoryKey(String key) async {
    selectedCategoryKeyNotifier.value = key;
    await categoriesDataNotifier.loadData(
      getRequired<CategoryService>().getCategoriesByKey(
        selectedCategoryKeyNotifier.value,
        limit: _limit,
      ),
    );
  }

  void selectCategory(Category category) {
    selectedCategoriesNotifier.value = [
      ...selectedCategoriesNotifier.value,
      category,
    ];
  }

  void removeCategory(Category category) {
    selectedCategoriesNotifier.value = selectedCategoriesNotifier.value
        .where((c) => c.id != category.id)
        .toList();

    if (selectedCategoriesNotifier.value.isEmpty) {
      searchResultsDataNotifier.value = const DataStateInitial();
    } else {
      loadSearchResults();
    }
  }

  Future<void> _loadMore() async {
    await categoriesDataNotifier.loadMore(
      getRequired<CategoryService>().getCategoriesByKey(
        selectedCategoryKeyNotifier.value,
        cursor: categoriesDataNotifier.value.asSuccess?.data.nextCursor,
        limit: _limit,
      ),
    );
  }

  bool get isSearchResultsAvailable =>
      !searchResultsDataNotifier.value.isLoading &&
      !searchResultsDataNotifier.value.isLoadingMore &&
      selectedCategoriesNotifier.value.isNotEmpty;

  Future<void> loadSearchResults() async {
    if (!isSearchResultsAvailable) return;

    await searchResultsDataNotifier.loadData(
      getRequired<BrandingService>().getPosts(
        limit: _limit,
        byCategories:
            selectedCategoriesNotifier.value.map((c) => c.id).toList(),
      ),
    );
  }

  Future<void> loadMoreSearchResults() async {
    if (!searchResultsDataNotifier.value.isSuccess) return;

    await searchResultsDataNotifier.loadMore(
      getRequired<BrandingService>().getPosts(
        cursor: searchResultsDataNotifier.value.asSuccess!.data.nextCursor,
        limit: _limit,
        byCategories:
            selectedCategoriesNotifier.value.map((c) => c.id).toList(),
      ),
    );
  }

  void openPost(BrandingPost post) {
    context.navigateTo(
      ProjectDetailsRoute(id: post.parent!.id.uuid),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/studios/studios_page.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

@RoutePage()
final class StudiosPage extends WidgetWithLogic<StudiosLogic> {
  const StudiosPage({super.key});

  @override
  logicBuilder(context) => StudiosLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      backgroundColor: const Color(0xFFFBFBFB),
      body: logic.studiosNotifier.when(
        success: (studios) {
          return _StudioListViewer(
            studios,
            onStudioPressed: logic.openStudio,
          );
        },
      ),
    );
  }
}

final class _StudioListViewer extends StatefulWidget {
  const _StudioListViewer(
    this.data, {
    this.onStudioPressed,
  });

  final List<BrandingStudio> data;
  final ValueChanged<BrandingStudio>? onStudioPressed;

  @override
  State<_StudioListViewer> createState() => _StudioListViewerState();
}

final class _StudioListViewerState extends State<_StudioListViewer> {
  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      itemCount: widget.data.length,
      itemBuilder: (context, index) => _StudioWidget(
        widget.data[index],
        onPressed: () => widget.onStudioPressed?.call(widget.data[index]),
      ),
      separatorBuilder: (_, __) => const SizedBox(
        height: 1,
        child: ColoredBox(
          color: Color(0xFFC9C9C9),
        ),
      ),
    );
  }
}

final class _StudioWidget extends StatefulWidget {
  const _StudioWidget(
    this.data, {
    required this.onPressed,
  });

  final BrandingStudio data;
  final VoidCallback? onPressed;

  @override
  State<_StudioWidget> createState() => _StudioWidgetState();
}

final class _StudioWidgetState extends State<_StudioWidget> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: Clickable(
        onTap: widget.onPressed,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.only(
                left: 20,
                right: 80,
                top: 10,
                bottom: 24,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      AnimatedNetworkImage(
                        widget.data.logoUrl,
                        width: 32,
                        height: 32,
                      ),
                      const SizedBox(width: 13),
                      Text(
                        widget.data.name,
                        style: const TextStyle(
                          fontFamily: 'Cygre Medium',
                          fontSize: 32,
                          fontWeight: FontWeight.w500,
                          height: 51.74 / 32,
                        ),
                      ),
                    ],
                  ),
                  Text(
                    context.mainAppLocalizations
                        .projectsCounter('${widget.data.projectsCounter}'),
                    style: const TextStyle(
                      fontFamily: 'Cygre Medium',
                      fontSize: 18,
                      fontWeight: FontWeight.w500,
                      height: 29.11 / 18,
                      color: Color(0xFF646464),
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(
              height: 180,
              child: ListView.separated(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                scrollDirection: Axis.horizontal,
                itemCount: widget.data.previews.length,
                itemBuilder: (context, index) => Hero(
                  tag: widget.data.previews[index].id,
                  child: AnimatedNetworkImage(
                    widget.data.previews[index].imageUrl,
                    height: 180,
                  ),
                ),
                separatorBuilder: (_, __) => const SizedBox(width: 12),
              ),
            ),
            const SizedBox(
              height: 29,
            ),
          ],
        ),
      ),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/studios/studios_logic.dart
Content:
```
import 'dart:async';

import 'package:main_app/presentation.dart';
import 'package:shared_app/domain.dart';

const _limit = 20;
const _previewLimit = 8;

final class StudiosLogic extends Logic {
  StudiosLogic(super.context);

  final studiosNotifier = DataNotifier<List<BrandingStudio>>();

  @override
  Future<void> initLogic() async {
    super.initLogic();

    await studiosNotifier.loadData(
      getRequired<BrandingService>().getStudios(
        limit: _limit,
        previewLimit: _previewLimit,
      ),
    );
  }

  @override
  void disposeLogic() {
    studiosNotifier.dispose();
    super.disposeLogic();
  }

  void openStudio(BrandingStudio studio) {
    context.read<BrandingLogic>()
      ..selectCategory(studio.toCategory())
      ..loadSearchResults();
  }
}

```

File: /packages/main_app/lib/presentation/pages/projects/projects_page.dart
Content:
```
import 'package:main_app/presentation.dart';

@RoutePage()
final class ProjectsPage extends WidgetWithLogic<ProjectsLogic> {
  const ProjectsPage({super.key});

  @override
  logicBuilder(context) => ProjectsLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      backgroundColor: const Color(0xFFFBFBFB),
      body: logic.projectsNotifier.when(
        success: (projects) {
          return ProjectListViewer(
            projects,
            onProjectPressed: logic.openProject,
            onEndReached: logic.loadMore,
            isHasMore: projects.nextCursor != null,
          );
        },
      ),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/projects/projects_logic.dart
Content:
```
import 'dart:async';

import 'package:main_app/presentation.dart';
import 'package:shared_app/domain.dart';

const _limit = 20;
const _childrenLimit = 8;

final class ProjectsLogic extends Logic {
  ProjectsLogic(super.context);

  final projectsNotifier = DataNotifier<PaginatedList<BrandingProject>>();

  @override
  Future<void> initLogic() async {
    super.initLogic();

    projectsNotifier.loadData(
      getRequired<BrandingService>().getProjects(
        limit: _limit,
        childrenLimit: _childrenLimit,
      ),
    );
  }

  @override
  void disposeLogic() {
    projectsNotifier.dispose();
    super.disposeLogic();
  }

  void loadMore() {
    projectsNotifier.loadMore(
      getRequired<BrandingService>().getProjects(
        cursor: projectsNotifier.value.asSuccess?.data.nextCursor,
        limit: _limit,
        childrenLimit: _childrenLimit,
      ),
    );
  }

  void openProject(BrandingProject value) {
    context.router.push(
      ProjectDetailsRoute(id: '${value.id}', cachedData: value),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/projects/project_details/project_details_page.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

@RoutePage()
final class ProjectDetailsPage extends WidgetWithLogic<ProjectDetailsLogic> {
  const ProjectDetailsPage(
    @PathParam('id') this.id, {
    super.key,
    this.cachedData,
  });

  final String id;
  final BrandingProject? cachedData;

  @override
  logicBuilder(context) =>
      ProjectDetailsLogic(context, UuidValue.fromString(id), cachedData);

  @override
  Widget build(context, logic) {
    return Scaffold(
      backgroundColor: const Color(0xFFFBFBFB),
      body: Center(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: 20,
                vertical: 16,
              ).copyWith(bottom: 0),
              child: Clickable(
                onTap: () => Navigator.of(context).pop(),
                child: Row(
                  children: [
                    Text.rich(
                      TextSpan(
                        style: const TextStyle(
                          fontFamily: 'Cygre',
                          color: Color(0xFF000000),
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                        ),
                        children: [
                          const WidgetSpan(
                            child: Padding(
                              padding: EdgeInsets.only(right: 14, top: 3),
                              child: Icon(
                                Icons.arrow_back_ios_new,
                                size: 14,
                                color: Color(0xFF000000),
                              ),
                            ),
                            alignment: PlaceholderAlignment.middle,
                          ),
                          TextSpan(
                            text: context.mainAppLocalizations.projectsTitle,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            Expanded(
              child: logic.projectNotifier.when(
                success: (project) {
                  return Column(
                    children: [
                      _Header(project),
                      Expanded(
                        child: logic.postListNotifier.builder(
                            builder: (context, state, _) {
                          final children = () {
                            if (state is DataStateSuccess) {
                              return state.asSuccess!.data;
                            } else if (state is DataStateLoadingMore) {
                              return state.asLoadingMore!.data;
                            } else {
                              return project.children;
                            }
                          }();
                          return MasonryGridView.count(
                            controller: logic.scrollController,
                            padding: const EdgeInsets.only(
                              left: 20,
                              right: 60,
                              top: 70,
                              bottom: 60,
                            ),
                            itemCount: children.length,
                            crossAxisCount: 3,
                            mainAxisSpacing: 20,
                            crossAxisSpacing: 20,
                            itemBuilder: (context, index) {
                              return AnimatedNetworkImage(
                                children[index].imageUrl,
                              );
                            },
                          );
                        }),
                      ),
                    ],
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

final class _Header extends StatefulWidget {
  const _Header(this.project);

  final BrandingProject project;

  @override
  State<_Header> createState() => _HeaderState();
}

final class _HeaderState extends State<_Header>
    with SingleTickerProviderStateMixin {
  late final AnimationController animationController =
      AnimationController(vsync: this, value: 1);
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    context
        .read<ProjectDetailsLogic>()
        .scrollController
        .addListener(scrollListener);

    _opacityAnimation = CurvedAnimation(
      parent: animationController,
      curve: const Interval(0.8, 1, curve: Curves.easeIn),
    );
  }

  @override
  void dispose() {
    context
        .read<ProjectDetailsLogic>()
        .scrollController
        .removeListener(scrollListener);
    animationController.dispose();
    super.dispose();
  }

  void scrollListener() {
    final animationValue = context
        .read<ProjectDetailsLogic>()
        .scrollController
        .offset
        .clamp(0.0, 200.0)
        .toDouble();

    animationController.value = 1 - (animationValue / 200);
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        AnimatedBuilder(
          animation: animationController,
          builder: (context, _) {
            final child = Container(
              padding: const EdgeInsets.only(left: 20, top: 8, bottom: 10),
              decoration: BoxDecoration(
                border: Border(
                  bottom: BorderSide(
                    color: animationController.value > 0.3
                        ? const Color(0x00000000)
                        : const Color(0x33000000),
                  ),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.project.name,
                    style: TextStyle(
                      fontFamily: 'Cygre',
                      color: const Color(0xFF000000),
                      fontSize: 48 * (animationController.value / 2 + 0.4),
                      fontWeight: FontWeight.w500,
                      height: 77.62 / 48,
                    ),
                  ),
                  if (animationController.value > 0.8)
                    FadeTransition(
                      opacity: _opacityAnimation,
                      child: Text(
                        widget.project.description,
                        style: const TextStyle(
                          fontFamily: 'Cygre',
                          color: Color(0xFF7E7E7E),
                          fontSize: 18,
                          fontWeight: FontWeight.w500,
                          height: 77.62 / 48,
                        ),
                      ),
                    ),
                ],
              ),
            );

            if (animationController.value > 0.3) {
              return child;
            } else {
              return Expanded(
                child: child,
              );
            }
          },
        ),
        AnimatedBuilder(
          animation: animationController,
          builder: (context, _) {
            if (animationController.value > 0.3) {
              return const Spacer();
            } else {
              return const SizedBox.shrink();
            }
          },
        ),
        AnimatedBuilder(
            animation: animationController,
            builder: (context, _) {
              if (animationController.value < 0.3) {
                return const SizedBox.shrink();
              } else {
                return SizeTransition(
                  sizeFactor: animationController,
                  axis: Axis.vertical,
                  axisAlignment: 1,
                  child: FadeTransition(
                    opacity: _opacityAnimation,
                    child: Padding(
                      padding: const EdgeInsets.only(top: 38, right: 60),
                      child: SizedBox(
                        width: 516,
                        child: Column(
                          children: [
                            for (int i = 0; i < 2; i++)
                              Row(
                                children: [
                                  SizedBox(
                                    width: 178,
                                    height: 29,
                                    child: Text(
                                      i == 0
                                          ? context.mainAppLocalizations.studio
                                          : context.mainAppLocalizations.theme,
                                      style: const TextStyle(
                                        fontFamily: 'Cygre',
                                        color: Color(0xFF7E7E7E),
                                        fontSize: 18,
                                        fontWeight: FontWeight.w500,
                                        height: 29.11 / 18,
                                      ),
                                    ),
                                  ),
                                  Text(
                                    i == 0
                                        ? widget.project.studio.value
                                        : widget.project.theme.value,
                                    style: const TextStyle(
                                      fontFamily: 'Cygre',
                                      color: Color(0xFF000000),
                                      fontSize: 18,
                                      fontWeight: FontWeight.w500,
                                      height: 29.11 / 18,
                                    ),
                                  ),
                                ],
                              ),
                            Container(
                              height: 1,
                              color: const Color(0xFFC9C9C9),
                            ),
                            for (int i = 0; i < 2; i++)
                              Row(
                                children: [
                                  SizedBox(
                                    width: 178,
                                    height: 29,
                                    child: Text(
                                      i == 0
                                          ? context.mainAppLocalizations.pallete
                                          : context.mainAppLocalizations.fonts,
                                      style: const TextStyle(
                                        fontFamily: 'Cygre',
                                        color: Color(0xFF7E7E7E),
                                        fontSize: 16,
                                        fontWeight: FontWeight.w500,
                                        height: 19.2 / 16,
                                      ),
                                    ),
                                  ),
                                  SizedBox(
                                    height: 29,
                                    child: Text.rich(
                                      TextSpan(
                                        children: [
                                          for (final category in i == 0
                                              ? widget.project.palette
                                              : widget.project.fonts) ...[
                                            if (category is ColorCategory) ...[
                                              WidgetSpan(
                                                alignment: PlaceholderAlignment
                                                    .baseline,
                                                baseline:
                                                    TextBaseline.ideographic,
                                                child: Container(
                                                  width: 16,
                                                  height: 16,
                                                  decoration: BoxDecoration(
                                                    color: Color(0xFF000000 +
                                                        category.hexColor),
                                                    borderRadius:
                                                        BorderRadius.circular(
                                                            100),
                                                  ),
                                                ),
                                              ),
                                              TextSpan(
                                                text: ' ${category.name}',
                                              ),
                                            ],
                                            if (category is FontCategory) ...[
                                              TextSpan(
                                                text: '${category.name}' +
                                                    (widget.project.fonts
                                                                .last ==
                                                            category
                                                        ? ''
                                                        : ','),
                                              ),
                                            ],
                                          ],
                                        ],
                                      ),
                                      style: const TextStyle(
                                        fontFamily: 'Cygre',
                                        color: Color(0xFF000000),
                                        fontSize: 16,
                                        fontWeight: FontWeight.w500,
                                        height: 19.2 / 16,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                          ].separated(const SizedBox(height: 8)),
                        ),
                      ),
                    ),
                  ),
                );
              }
            }),
      ],
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/projects/project_details/project_details_logic.dart
Content:
```
import 'dart:async';

import 'package:main_app/presentation.dart';
import 'package:shared_app/domain.dart';

const _limit = 50;
const _childrenLimit = 8;

final class ProjectDetailsLogic extends Logic {
  ProjectDetailsLogic(super.context, this.uuid, this.cachedData);

  final UuidValue uuid;
  final BrandingProject? cachedData;

  final scrollController = ScrollController();
  final projectNotifier = DataNotifier<BrandingProject>();
  final postListNotifier = DataNotifier<PaginatedList<BrandingPost>>();

  Timer? _timer;
  bool _guard = false;

  @override
  Future<void> initLogic() async {
    super.initLogic();

    await projectNotifier.loadData(
      getRequired<BrandingService>()
          .getProjectById(uuid, childrenLimit: _childrenLimit),
      cachedData: cachedData,
    );

    if (projectNotifier.value.isSuccess) {
      final project = projectNotifier.value.asSuccess!.data;
      if (project.nextChildrenCursor != null) {
        postListNotifier.value = DataStateSuccess(
          PaginatedList(project.children, project.nextChildrenCursor),
        );
        await postListNotifier.loadMore(
          getRequired<BrandingService>().getPosts(
            cursor: project.nextChildrenCursor,
            byProject: project.id,
            limit: _limit - _childrenLimit,
          ),
        );

        scrollController.addListener(() {
          if (scrollController.position.pixels >=
              scrollController.position.maxScrollExtent - 500) {
            loadMore();
          }
        });
      }
    }
  }

  @override
  void disposeLogic() {
    projectNotifier.dispose();
    _timer?.cancel();
    super.disposeLogic();
  }

  void _guarding() {
    _guard = true;
    _timer?.cancel();
    _timer = Timer(const Duration(milliseconds: 200), () {
      _guard = false;
    });
  }

  void loadMore() {
    if (projectNotifier.value.isSuccess &&
        postListNotifier.value.asSuccess?.data.nextCursor != null &&
        !_guard) {
      _guarding();
      final project = projectNotifier.value.asSuccess!.data;
      postListNotifier.loadMore(
        getRequired<BrandingService>().getPosts(
          cursor: postListNotifier.value.asSuccess?.data.nextCursor,
          byProject: project.id,
          limit: _limit,
        ),
      );
    }
  }
}

```

File: /packages/main_app/lib/presentation/pages/daily/daily_logic.dart
Content:
```
import 'dart:async';

import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

final class DailyLogic extends Logic {
  DailyLogic(super.sp);

  final datesDataNotifier = DataNotifier<List<Date>>();
  final selectedDateNotifier = ValueNotifier<Date?>(null);

  final linksDataNotifier = DataNotifier<List<List<DailyLink>>>();

  @override
  Future<void> initLogic() async {
    super.initLogic();

    await datesDataNotifier.loadData(
      getRequired<CollectionLinkService>().getDates(),
    );
    datesDataNotifier.value.whenOrElse(
      success: (dates, _) {
        if (dates.isEmpty) return;
        selectDate(dates
            .where((element) => element.dateTime.isBefore(DateTime.now()))
            .first);
      },
      orElse: () {},
    );
  }

  @override
  void disposeLogic() {
    datesDataNotifier.dispose();
    selectedDateNotifier.dispose();
    linksDataNotifier.dispose();
    super.disposeLogic();
  }

  Future<void> selectNextDate() async {
    final dates = datesDataNotifier.value.whenOrNull(
      success: (dates, _) => dates,
    );

    if (dates == null || dates.isEmpty) return;

    final index = dates.indexOf(selectedDateNotifier.value!);
    if (index == 0) return;

    await selectDate(dates[index - 1]);
  }

  Future<void> selectPreviousDate() async {
    final dates = datesDataNotifier.value.whenOrNull(
      success: (dates, _) => dates,
    );

    if (dates == null || dates.isEmpty) return;

    final index = dates.indexOf(selectedDateNotifier.value!);
    if (index == dates.length - 1) return;

    await selectDate(dates[index + 1]);
  }

  Future<void> selectDate(Date date) async {
    if (selectedDateNotifier.value == date) return;
    selectedDateNotifier.value = date;

    linksDataNotifier.value = const DataStateLoading();
    final data =
        await getRequired<CollectionLinkService>().getLinksByDate(date);

    data.when(
      success: (data) {
        final items = [
          [
            data[0],
            data[1],
            data[2],
          ],
          [
            data[3],
            data[4],
            data[5],
            data[6],
          ],
          [
            data[7],
            data[8],
            data[9],
          ],
          [
            data[10],
            data[11],
            data[12],
            data[13],
            data[14],
            data[15],
            data[16],
            data[17],
          ],
        ];

        linksDataNotifier.value = DataStateSuccess(items);
      },
      failure: (failure) {
        linksDataNotifier.value = DataStateFailed(failure);
      },
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/daily/daily_page.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';
import 'package:url_launcher/url_launcher.dart';

@RoutePage()
final class DailyPage extends WidgetWithLogic<DailyLogic> {
  const DailyPage({super.key});

  @override
  logicBuilder(context) => DailyLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      backgroundColor: const Color(0xFFFBFBFB),
      body: logic.datesDataNotifier.when(
        success: (dates) {
          return Column(
            children: [
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 20,
                  vertical: 16,
                ),
                decoration: const BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: Color(0x33000000),
                    ),
                  ),
                ),
                child: Row(
                  children: [
                    Text(
                      context.mainAppLocalizations.collectionTitle,
                      style: const TextStyle(
                        fontFamily: 'Cygre',
                        color: Color(0xFF000000),
                        fontSize: 32,
                        fontWeight: FontWeight.w500,
                        height: 51.74 / 32,
                      ),
                    ),
                    const Spacer(),
                    logic.selectedDateNotifier.builder(
                      (context, selectedDate, _) => _DateSwitcher(
                        availableDates: dates,
                        selectedDate: selectedDate!,
                      ),
                    ),
                  ],
                ),
              ),
              Expanded(
                child: SmoothListView(
                  children: [
                    logic.linksDataNotifier.when(
                      success: (links) {
                        return CollectionViewer(
                          links
                              .map(
                                (row) => row
                                    .map((e) => DailyLinkModel.fromResponse(e))
                                    .toList(),
                              )
                              .toList(),
                          onPressed: (link) => launchUrl(link.url),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

final class _DateSwitcher extends StatefulWidget {
  const _DateSwitcher({
    required this.availableDates,
    required this.selectedDate,
  });

  final List<Date> availableDates;
  final Date selectedDate;

  @override
  State<_DateSwitcher> createState() => _DateSwitcherState();
}

final class _DateSwitcherState extends State<_DateSwitcher> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    final linesInTextPainter = TextPainter(
      text: TextSpan(
        text: widget.selectedDate.dateTime
            .format(context, 'dd MMM, EEE')
            .replaceAll('.', ''),
        style: const TextStyle(
          fontFamily: 'Cygre',
          color: Color(0xFF000000),
          fontSize: 24,
          fontWeight: FontWeight.w500,
          height: 38.81 / 24,
        ),
      ),
      textDirection: TextDirection.ltr,
    )..layout();

    const duration = Duration(milliseconds: 300);
    const curve = Curves.linearToEaseOut;
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: Row(
        children: [
          AnimatedContainer(
            duration: duration,
            curve: curve,
            width: isHovered
                ? linesInTextPainter.width - 20
                : linesInTextPainter.width + 10,
            height: linesInTextPainter.height,
            child: FittedBox(
              fit: BoxFit.fill,
              child: Text(
                widget.selectedDate.dateTime
                    .format(context, 'dd MMM, EEE')
                    .replaceAll('.', ''),
                style: const TextStyle(
                  fontFamily: 'Cygre',
                  color: Color(0xFF000000),
                  fontSize: 24,
                  fontWeight: FontWeight.w500,
                  height: 38.81 / 24,
                ),
              ),
            ),
          ),
          AnimatedContainer(
            duration: duration,
            curve: curve,
            width: isHovered ? 13 : 10,
          ),
          Padding(
            padding: const EdgeInsets.only(top: 9),
            child: Row(
              children: [
                DisablingDecorator(
                  isDisabled: widget.selectedDate == widget.availableDates.last,
                  child: Clickable(
                    onTap: context.read<DailyLogic>().selectPreviousDate,
                    child: AnimatedContainer(
                      duration: duration,
                      curve: curve,
                      width: isHovered ? 16 : 9,
                      height: isHovered ? 20 : 18,
                      child: SvgPicture.string(
                        '<svg width="11" height="18" viewBox="0 0 11 18" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M10 17L2 9L10 1" stroke="black" stroke-width="2"/> </svg>',
                        fit: BoxFit.fill,
                      ),
                    ),
                  ),
                ),
                AnimatedContainer(
                  duration: duration,
                  curve: curve,
                  width: isHovered ? 20 : 5,
                ),
                DisablingDecorator(
                  isDisabled:
                      widget.selectedDate == widget.availableDates.first,
                  child: Clickable(
                    onTap: context.read<DailyLogic>().selectNextDate,
                    child: AnimatedContainer(
                      duration: duration,
                      curve: curve,
                      width: isHovered ? 16 : 9,
                      height: isHovered ? 20 : 18,
                      child: SvgPicture.string(
                        '<svg width="11" height="18" viewBox="0 0 11 18" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M1 1L9 9L0.999999 17" stroke="black" stroke-width="2"/> </svg>',
                        fit: BoxFit.fill,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/root/root_logic.dart
Content:
```
import 'package:main_app/presentation.dart';

final class RootLogic extends Logic {
  RootLogic(super.context);
}

```

File: /packages/main_app/lib/presentation/pages/root/root_page.dart
Content:
```
import 'package:main_app/presentation.dart';

@RoutePage()
final class RootPage extends WidgetWithLogic<RootLogic> {
  const RootPage({super.key});

  @override
  logicBuilder(context) => RootLogic(context);

  @override
  Widget build(context, logic) {
    final _tabs = [
      _TabModel(
        title: context.mainAppLocalizations.collectionTitle,
        path: 'daily',
        route: DailyRoute(),
      ),
      _TabModel(
        title: context.mainAppLocalizations.brandingTitle,
        path: 'branding',
        route: BrandingRoute(),
      ),
      _TabModel(
        title: context.mainAppLocalizations.bookmarksTitle,
        path: 'bookmarks',
        route: BrandingRoute(),
      ),
      _TabModel(
        title: context.mainAppLocalizations.settingsTitle,
        path: 'settings',
        route: BrandingRoute(),
      ),
    ];

    return Scaffold(
      backgroundColor: const Color(0xFFFBFBFB),
      body: Row(
        children: [
          ChangeNotifierProvider(
            create: (_) => _Notifier(),
            child: Consumer<_Notifier>(
              builder: (context, _, __) {
                return Container(
                  width: 308,
                  decoration: const BoxDecoration(
                    border: Border(
                      right: BorderSide(
                        color: Color(0x33000000),
                      ),
                    ),
                  ),
                  child: Padding(
                    padding: const EdgeInsets.only(
                      top: 19.5,
                      left: 60,
                      bottom: 22,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Clickable(
                          onTap: () => DailyRoute().push(context),
                          child: Image.asset(
                            'assets/images/logo.png',
                            package: 'shared_app',
                            height: 50,
                            width: 215,
                          ),
                        ),
                        const SizedBox(height: 40),
                        ...[
                          _TabWidget(_tabs[0]),
                          _TabWidget(_tabs[1]),
                          const Spacer(),
                          _TabWidget(_tabs[2]),
                          _TabWidget(_tabs[3]),
                        ].separated(const SizedBox(height: 9)),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          const Expanded(
            child: AutoRouter(),
          ),
        ],
      ),
    );
  }
}

final class _TabWidget extends StatefulWidget {
  const _TabWidget(this.tab);
  final _TabModel tab;

  @override
  State<_TabWidget> createState() => _TabWidgetState();
}

final class _TabWidgetState extends State<_TabWidget> {
  StackRouter? router;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      setState(() {
        router = context.innerRouterOf<StackRouter>(RootRoute.name);
      });
    });
  }

  @override
  Widget build(context) {
    final isCurrent =
        router?.stack.last.routeData.path.contains(widget.tab.path) ?? false;

    return Clickable(
      onTap: () {
        router?.push(widget.tab.route);
        context.read<_Notifier>().update();
      },
      child: Row(
        children: [
          Text(
            widget.tab.title,
            style: TextStyle(
              fontFamily: 'Cygre',
              fontWeight: FontWeight.w500,
              fontSize: 20,
              height: 32.34 / 20,
              color: isCurrent ? Colors.black : const Color(0xFF9A9A9A),
            ),
          ),
        ],
      ),
    );
  }
}

final class _TabModel {
  const _TabModel({
    required this.title,
    required this.route,
    required this.path,
  });
  final String title;
  final PageRouteInfo route;
  final String path;
}

final class _Notifier extends ChangeNotifier {
  void update() {
    notifyListeners();
  }
}

```

File: /packages/main_app/lib/presentation/pages/themes/themes_page.dart
Content:
```
import 'package:main_app/domain.dart';
import 'package:main_app/presentation.dart';

@RoutePage()
final class ThemesPage extends WidgetWithLogic<ThemesLogic> {
  const ThemesPage({super.key});

  @override
  logicBuilder(context) => ThemesLogic(context);

  @override
  Widget build(context, logic) {
    return Scaffold(
      // TODO интегрировать тему с палитрой, шрифтами и тд
      backgroundColor: const Color(0xFFFBFBFB),
      body: logic.themesNotifier.when(
        success: (themes) {
          return _ThemeListViewer(
            themes,
            onThemePressed: logic.openTheme,
          );
        },
      ),
    );
  }
}

final class _ThemeListViewer extends StatefulWidget {
  const _ThemeListViewer(
    this.data, {
    this.onThemePressed,
  });

  final List<BrandingTheme> data;
  final ValueChanged<BrandingTheme>? onThemePressed;

  @override
  State<_ThemeListViewer> createState() => _ThemeListViewerState();
}

final class _ThemeListViewerState extends State<_ThemeListViewer> {
  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      itemCount: widget.data.length,
      itemBuilder: (context, index) => _ThemeWidget(
        widget.data[index],
        onPressed: () => widget.onThemePressed?.call(widget.data[index]),
      ),
      separatorBuilder: (_, __) => const SizedBox(
        height: 1,
        child: ColoredBox(
          color: Color(0xFFC9C9C9),
        ),
      ),
    );
  }
}

final class _ThemeWidget extends StatefulWidget {
  const _ThemeWidget(
    this.data, {
    required this.onPressed,
  });

  final BrandingTheme data;
  final VoidCallback? onPressed;

  @override
  State<_ThemeWidget> createState() => _ThemeWidgetState();
}

final class _ThemeWidgetState extends State<_ThemeWidget> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: Clickable(
        onTap: widget.onPressed,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.only(
                left: 20,
                right: 80,
                top: 10,
                bottom: 24,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.data.name,
                    style: const TextStyle(
                      fontFamily: 'Cygre Medium',
                      fontSize: 32,
                      fontWeight: FontWeight.w500,
                      height: 51.74 / 32,
                    ),
                  ),
                  Text(
                    context.mainAppLocalizations
                        .projectsCounter('${widget.data.projectsCounter}'),
                    style: const TextStyle(
                      fontFamily: 'Cygre Medium',
                      fontSize: 18,
                      fontWeight: FontWeight.w500,
                      height: 29.11 / 18,
                      color: Color(0xFF646464),
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(
              height: 180,
              child: ListView.separated(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                scrollDirection: Axis.horizontal,
                itemCount: widget.data.previews.length,
                itemBuilder: (context, index) => Hero(
                  tag: widget.data.previews[index].id,
                  child: AnimatedNetworkImage(
                    widget.data.previews[index].imageUrl,
                    height: 180,
                  ),
                ),
                separatorBuilder: (_, __) => const SizedBox(width: 12),
              ),
            ),
            const SizedBox(
              height: 29,
            ),
          ],
        ),
      ),
    );
  }
}

```

File: /packages/main_app/lib/presentation/pages/themes/themes_logic.dart
Content:
```
import 'dart:async';

import 'package:main_app/presentation.dart';
import 'package:shared_app/domain.dart';

const _limit = 20;
const _previewLimit = 8;

final class ThemesLogic extends Logic {
  ThemesLogic(super.context);

  final themesNotifier = DataNotifier<List<BrandingTheme>>();

  @override
  Future<void> initLogic() async {
    super.initLogic();

    await themesNotifier.loadData(
      getRequired<BrandingService>().getThemes(
        limit: _limit,
        previewLimit: _previewLimit,
      ),
    );
  }

  @override
  void disposeLogic() {
    themesNotifier.dispose();
    super.disposeLogic();
  }

  void openTheme(BrandingTheme theme) {
    context.read<BrandingLogic>()
      ..selectCategory(theme.toCategory())
      ..loadSearchResults();
  }
}

```

File: /packages/shared_backend/prisma/schema.prisma
Content:
```
generator client {
  provider = "dart run orm"
  output   = "../lib/generated/prisma_client"
}

datasource db {
  provider = "postgresql"
  url      = env("SHARED_DATABASE_URL")
}

model CategoryDB {
  id                String              @id @default(uuid())
  key               String
  value             String
  properties        String
  createdAt         DateTime
  updatedAt         DateTime
  PostCategoryDb    PostCategoryDB[]
  ProjectCategoryDb ProjectCategoryDB[]

  @@map("Category")
}

model DailyLinkDB {
  id              String          @id @default(uuid())
  title           String
  url             String
  previewImageUrl String?
  date            String
  type            DailyLinkTypeDB

  @@map("DailyLink")
}

enum DailyLinkTypeDB {
  video
  startup
  utility
  site
  article
  cases

  @@map("DailyLinkType")
}

model BrandingProjectDB {
  id          String              @id @default(uuid())
  name        String
  description String
  createdAt   DateTime
  updatedAt   DateTime
  children    BrandingPostDB[]
  categories  ProjectCategoryDB[]

  @@map("BrandingProject")
}

model BrandingPostDB {
  id          String            @id @default(uuid())
  parentId    String            @unique
  name        String
  description String
  imageUrl    String?
  createdAt   DateTime
  updatedAt   DateTime
  sortOrder   Int
  parent      BrandingProjectDB @relation(fields: [parentId], references: [id])
  categories  PostCategoryDB[]

  @@map("BrandingPost")
}

model PostCategoryDB {
  BrandingPostDB BrandingPostDB @relation(fields: [postId], references: [id])
  postId         String         @unique
  CategoryDB     CategoryDB     @relation(fields: [categoryId], references: [id])
  categoryId     String         @unique

  @@map("PostCategory")
}

model ProjectCategoryDB {
  BrandingProjectDB BrandingProjectDB @relation(fields: [projectId], references: [id])
  projectId         String            @unique
  CategoryDB        CategoryDB        @relation(fields: [categoryId], references: [id])
  categoryId        String            @unique

  @@map("ProjectCategory")
}

```

File: /packages/shared_backend/pubspec.yaml
Content:
```
name: shared_backend
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  shared:
  dart_frog: ^1.0.0
  shelf_cors_headers: ^0.1.5
  shelf_multipart: ^2.0.0
  orm: ^5.0.4
  otp: ^3.1.4
  encrypt: ^5.0.3

```

File: /packages/shared_backend/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/clients/prisma.dart';
export 'infrastructure/managers/category.dart';
export 'infrastructure/managers/branding.dart';
export 'infrastructure/managers/daily_link.dart';
export 'infrastructure/utils/totp.dart';
export 'infrastructure/utils/prisma.dart';
export 'infrastructure/extensions/request_context.dart';
export 'infrastructure/extensions/data.dart';
export 'infrastructure/extensions/enum.dart';
export 'infrastructure/extensions/paginated_list.dart';
export 'infrastructure/exports.dart';

```

File: /packages/shared_backend/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/exports.dart';

```

File: /packages/shared_backend/lib/infrastructure/clients/prisma.dart
Content:
```
import 'package:shared_backend/generated/prisma_client/client.dart';
export 'package:shared_backend/generated/prisma_client/model.dart';
export 'package:shared_backend/generated/prisma_client/prisma.dart';

final class PrismaSharedClient extends PrismaClient {}

```

File: /packages/shared_backend/lib/infrastructure/managers/category.dart
Content:
```
import 'dart:convert';

import 'package:shared_backend/domain.dart';
import 'package:shared_backend/infrastructure.dart';

final class CategoryManager {
  CategoryManager(this._client);

  final PrismaSharedClient _client;

  Future<PaginatedList<Category>> getCategoriesByKey(
    String key, {
    required UuidValue? cursor,
    required int limit,
  }) async {
    final categories = await _client.categoryDB.findMany(
      select: _selectCategory(),
      cursor: cursor == null ? null : CategoryDBWhereUniqueInput(id: '$cursor'),
      where: CategoryDBWhereInput(
        key: $2(key),
      ),
      orderBy: $2(CategoryDBOrderByWithRelationInput(
        createdAt: SortOrder.asc,
      )),
      skip: cursor == null ? 0 : 1,
      take: limit,
    );

    return PaginatedList(
      categories.map((e) => e.toDomain()).toList(),
      categories.length < limit ? null : categories.last.id.toUuidOrNull(),
    );
  }

  Future<Category?> getCategoryById(UuidValue id) async {
    final category = await _client.categoryDB.findUnique(
      select: _selectCategory(),
      where: CategoryDBWhereUniqueInput(id: '$id'),
    );

    return category?.toDomain();
  }

  Future<List<Category>> getCategoriesByIds(List<UuidValue> categoryIds) async {
    final categories = await _client.categoryDB.findMany(
      select: _selectCategory(),
      where: CategoryDBWhereInput(
        id: $1(StringFilter(
          $in: $1(categoryIds.map((e) => e.toString()).toList()),
        )),
      ),
    );

    return categories.map((e) => e.toDomain()).toList();
  }
}

CategoryDBSelect _selectCategory() {
  return CategoryDBSelect(
    id: true,
    key: true,
    value: true,
    properties: true,
  );
}

extension CategoryDBToDomain on CategoryDB {
  Category toDomain() {
    return Category(
      id: id.toUuidOrNull()!,
      key: key!,
      value: value!,
      properties: jsonDecode(properties!),
    );
  }
}

```

File: /packages/shared_backend/lib/infrastructure/managers/branding.dart
Content:
```
import 'dart:convert';

import 'package:shared_backend/domain.dart';
import 'package:shared_backend/infrastructure.dart';

final class BrandingManager {
  BrandingManager(this._client, this._categoryManager);
  final PrismaSharedClient _client;
  final CategoryManager _categoryManager;

  Future<PaginatedList<BrandingProject>> getProjects({
    required UuidValue? cursor,
    required int limit,
    required int childrenLimit,
  }) async {
    final projects = await _client.brandingProjectDB.findMany(
      select: BrandingProjectDBSelect(
        id: true,
        name: true,
        description: true,
        createdAt: true,
        updatedAt: true,
        children: $2(
          BrandingProjectDBChildrenArgs(
            take: childrenLimit,
          ),
        ),
      ),
      skip: cursor == null ? 0 : 1,
      cursor: cursor == null
          ? null
          : BrandingProjectDBWhereUniqueInput(id: '$cursor'),
      orderBy: $2(BrandingProjectDBOrderByWithRelationInput(
        createdAt: SortOrder.asc,
      )),
      take: limit,
    );

    return PaginatedList(
      projects.map((e) => e.toDomain()).toList(),
      projects.length < limit ? null : projects.last.id.toUuidOrNull(),
    );
  }

  Future<PaginatedList<BrandingStudio>> getStudios({
    required UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) async {
    final categories = await _categoryManager.getCategoriesByKey(
      StudioCategory.keyName,
      cursor: cursor,
      limit: limit,
    );

    final result = await Future.wait(categories.map((category) async {
      final studioCategory = category as StudioCategory;
      return BrandingStudio(
        id: studioCategory.id,
        name: studioCategory.value,
        logoUrl: studioCategory.logoUrl,
        projectsCounter: await getProjectsCounterByCategory(studioCategory),
        previews: await getPostsByCategory(studioCategory, limit: previewLimit),
      );
    }).toList());

    return PaginatedList(result, categories.nextCursor);
  }

  Future<PaginatedList<BrandingTheme>> getThemes({
    required UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) async {
    final themes = await _categoryManager.getCategoriesByKey(
      ThemeCategory.keyName,
      cursor: cursor,
      limit: limit,
    );

    final result = await Future.wait(themes.map((theme) async {
      return BrandingTheme(
        id: theme.id,
        name: theme.value,
        projectsCounter: await getProjectsCounterByCategory(theme),
        previews: await getPostsByCategory(theme, limit: previewLimit),
      );
    }).toList());

    return PaginatedList(result, themes.nextCursor);
  }

  Future<PaginatedList<BrandingPost>> getPosts({
    required UuidValue? cursor,
    required int limit,
    required UuidValue? byProject,
    required List<UuidValue> byCategories,
    bool withParent = true,
  }) async {
    final posts = await _client.brandingPostDB.findMany(
      select: BrandingPostDBSelect(
        id: true,
        name: true,
        description: true,
        imageUrl: true,
        parent: withParent
            ? $2(
                BrandingPostDBParentArgs(
                  select: BrandingProjectDBSelect(
                    id: true,
                    name: true,
                    description: true,
                  ),
                ),
              )
            : null,
        categories: $2(
          BrandingPostDBCategoriesArgs(
            select: PostCategoryDBSelect(
              categoryDB: $1(true),
            ),
          ),
        ),
      ),
      where: BrandingPostDBWhereInput(
        parent: byProject != null
            ? $2(BrandingProjectDBWhereInput(
                id: $2('${byProject}'),
              ))
            : null,
        categories: byCategories.isNotEmpty
            ? PostCategoryDBListRelationFilter(
                some: PostCategoryDBWhereInput(
                  categoryId: $1(StringFilter(
                    $in: $1(byCategories.map((e) => '${e}')),
                  )),
                ),
              )
            : null,
      ),
      orderBy: $2(BrandingPostDBOrderByWithRelationInput(
        createdAt: SortOrder.desc,
      )),
      cursor:
          cursor == null ? null : BrandingPostDBWhereUniqueInput(id: '$cursor'),
      skip: cursor == null ? 0 : 1,
      take: limit,
    );

    return PaginatedList(
      posts.map((e) => e.toDomain()).toList(),
      posts.length < limit ? null : posts.last.id.toUuidOrNull(),
    );
  }

  Future<BrandingProject> getProjectById(UuidValue id,
      {required int childrenLimit}) async {
    final project = await _client.brandingProjectDB.findUnique(
      select: BrandingProjectDBSelect(
        id: true,
        name: true,
        description: true,
        createdAt: true,
        updatedAt: true,
        children: $2(
          BrandingProjectDBChildrenArgs(
            take: childrenLimit,
          ),
        ),
        categories: $2(
          BrandingProjectDBCategoriesArgs(
            select: ProjectCategoryDBSelect(
              categoryDB: $1(true),
            ),
          ),
        ),
      ),
      where: BrandingProjectDBWhereUniqueInput(id: '${id}'),
    );

    // TODO: добавить возврат ошибок если не найдено

    final retrieveCategories = _splitCategories(
      project!.categories!.map((e) => e.toDomain()),
    );

    return BrandingProject(
      id: project.id.toUuidOrNull()!,
      name: project.name!,
      description: project.description!,
      children: project.children!.map((e) => e.toDomain()).toList(),
      nextChildrenCursor: project.children?.lastOrNull?.id.toUuidOrNull(),
      studio: retrieveCategories.studio,
      theme: retrieveCategories.theme,
      palette: retrieveCategories.palette,
      fonts: retrieveCategories.fonts,
      categories: retrieveCategories.otherCategories,
    );
  }

  Future<BrandingPost> getPostById(UuidValue id) async {
    final post = await _client.brandingPostDB.findUnique(
      select: BrandingPostDBSelect(
        id: true,
        name: true,
        description: true,
        imageUrl: true,
        parent: $2(
          BrandingPostDBParentArgs(
            select: BrandingProjectDBSelect(
              id: true,
              name: true,
              description: true,
            ),
          ),
        ),
        categories: $2(
          BrandingPostDBCategoriesArgs(
            select: PostCategoryDBSelect(
              categoryDB: $1(true),
            ),
          ),
        ),
      ),
      where: BrandingPostDBWhereUniqueInput(id: '${id}'),
    );

    final retrieveCategories = _splitCategories(
      post!.categories!.map((e) => e.toDomain()),
    );

    return BrandingPost(
      id: post.id.toUuidOrNull()!,
      name: post.name!,
      description: post.description!,
      imageUrl: Uri.dataFromString(post.imageUrl!),
      parent: BrandingPostParent(
        id: post.parent!.id!.toUuidOrNull()!,
        name: post.parent!.name!,
        description: post.parent!.description!,
      ),
      studio: retrieveCategories.studio,
      theme: retrieveCategories.theme,
      palette: retrieveCategories.palette,
      fonts: retrieveCategories.fonts,
      categories: retrieveCategories.otherCategories,
    );
  }
}

extension on BrandingManager {
  Future<int> getProjectsCounterByCategory(Category category) async {
    return (await _client.projectCategoryDB.aggregate(
          where: ProjectCategoryDBWhereInput(
            categoryId: $2('${category.id}'),
          ),
        ))
            .$count
            ?.categoryId ??
        0;
  }

  Future<List<BrandingPost>> getPostsByCategory(
    Category category, {
    required int limit,
  }) async {
    final result = await _client.brandingPostDB.findMany(
      where: BrandingPostDBWhereInput(
        parent: $2(BrandingProjectDBWhereInput(
          categories: ProjectCategoryDBListRelationFilter(
            some: ProjectCategoryDBWhereInput(
              categoryId: $2('${category.id}'),
            ),
          ),
        )),
      ),
      orderBy: $2(BrandingPostDBOrderByWithRelationInput(
        createdAt: SortOrder.desc,
      )),
      take: limit,
    );

    return result.map((e) => e.toDomain()).toList();
  }
}

extension on BrandingProjectDB {
  BrandingProject toDomain() {
    final retrieveCategories =
        _splitCategories(categories!.map((e) => e.toDomain()));

    return BrandingProject(
      id: id.toUuidOrNull()!,
      name: name!,
      description: description!,
      children: children!.map((e) => e.toDomain()).toList(),
      nextChildrenCursor: children?.lastOrNull?.id.toUuidOrNull(),
      studio: retrieveCategories.studio,
      theme: retrieveCategories.theme,
      palette: retrieveCategories.palette,
      fonts: retrieveCategories.fonts,
      categories: retrieveCategories.otherCategories,
    );
  }
}

extension on BrandingPostDB {
  BrandingPost toDomain() {
    final retrieveCategories =
        _splitCategories(categories!.map((e) => e.toDomain()));

    return BrandingPost(
      id: id.toUuidOrNull()!,
      name: name!,
      description: description!,
      imageUrl: Uri.dataFromString(imageUrl!),
      parent: parent == null
          ? null
          : BrandingPostParent(
              id: parent!.id!.toUuidOrNull()!,
              name: parent!.name!,
              description: parent!.description!,
            ),
      studio: retrieveCategories.studio,
      theme: retrieveCategories.theme,
      palette: retrieveCategories.palette,
      fonts: retrieveCategories.fonts,
      categories: retrieveCategories.otherCategories,
    );
  }
}

({
  StudioCategory studio,
  ThemeCategory theme,
  List<ColorCategory> palette,
  List<FontCategory> fonts,
  List<Category> otherCategories
}) _splitCategories(Iterable<Category> categories) {
  final studio = categories.firstWhere(
    (element) => element.key == StudioCategory.keyName,
  ) as StudioCategory;

  final theme = categories.firstWhere(
    (element) => element.key == ThemeCategory.keyName,
  ) as ThemeCategory;

  final palette = categories
      .where((element) => element.key == ColorCategory.keyName)
      .map((e) => e as ColorCategory)
      .toList();

  final fonts = categories
      .where((element) => element.key == FontCategory.keyName)
      .map((e) => e as FontCategory)
      .toList();

  final otherCategories = categories.toList()
    ..removeWhere(
      (element) =>
          element.key == StudioCategory.keyName ||
          element.key == ThemeCategory.keyName ||
          element.key == ColorCategory.keyName ||
          element.key == FontCategory.keyName,
    );

  return (
    studio: studio,
    theme: theme,
    palette: palette,
    fonts: fonts,
    otherCategories: otherCategories,
  );
}

extension on PostCategoryDB {
  Category toDomain() {
    return Category(
      id: categoryDB!.id!.toUuidOrNull()!,
      key: categoryDB!.key!,
      value: categoryDB!.value!,
      properties: jsonDecode(categoryDB!.properties!),
    );
  }
}

extension on ProjectCategoryDB {
  Category toDomain() {
    return Category(
      id: categoryDB!.id!.toUuidOrNull()!,
      key: categoryDB!.key!,
      value: categoryDB!.value!,
      properties: jsonDecode(categoryDB!.properties!),
    );
  }
}

```

File: /packages/shared_backend/lib/infrastructure/managers/daily_link.dart
Content:
```
import 'package:shared_backend/domain.dart';
import 'package:shared_backend/infrastructure.dart';

final class DailyLinkManager {
  DailyLinkManager(this._client);

  final PrismaSharedClient _client;

  Future<List<Date>> getDates() async {
    final dates = await _client.dailyLinkDB.findMany(
      select: DailyLinkDBSelect(date: true),
      orderBy: $2(DailyLinkDBOrderByWithRelationInput(
        date: SortOrder.asc,
      )),
    );

    return dates.map((e) => Date.parse(e.date!)).toSet().toList();
  }

  Future<List<DailyLink>> getLinksByDate(Date date) async {
    final links = await _client.dailyLinkDB.findMany(
      where: DailyLinkDBWhereInput(date: $2('$date')),
    );

    return links.map((e) => e.toDomain()).toList();
  }

  Future<bool> existsDate(Date date) async {
    final link = await _client.dailyLinkDB.findFirst(
      where: DailyLinkDBWhereInput(date: $2('$date')),
    );

    return link != null;
  }

  Future<void> deleteByDate(Date date) {
    return _client.dailyLinkDB.delete(
      where: DailyLinkDBWhereUniqueInput(date: $2('$date')),
    );
  }

  Future<void> setLinksByDate(
    Date date,
    List<DailyLinkRequest> links,
  ) async {
    if (await existsDate(date)) {
      await deleteByDate(date);
      if (links.isEmpty) return Future.value();
    }

    await _client.dailyLinkDB.createMany(
      data: $2(links.map(
        (e) => DailyLinkDBCreateManyInput(
          title: e.title,
          url: e.url.toString(),
          previewImageUrl: $1(e.previewImageUrl.toString()),
          type: DailyLinkTypeDB.values.byName(e.type.name),
          date: '$date',
        ),
      )),
    );
  }
}

extension on DailyLinkDB {
  DailyLink toDomain() {
    return DailyLink(
      id: id.toUuidOrNull()!,
      title: title!,
      url: Uri.dataFromString(url!),
      previewImageUrl: Uri.dataFromString(previewImageUrl!),
      type: DailyLinkType.values.byName(type!.name),
      date: Date.parse(date!),
    );
  }
}

```

File: /packages/shared_backend/lib/infrastructure/extensions/request_context.dart
Content:
```
import 'dart:async';
import 'dart:convert';

import 'package:shared_backend/domain.dart';
import 'package:shared_backend/infrastructure.dart';

final class Required {
  const Required(this.type);
  final Type type;
}

extension ResponseExtension on RequestContext {
  Future<Response> getParametersFromQuery(
    List<String> parameters,
    List<dynamic> parameterTypes,
    Future<Response> Function(Map<String, dynamic>) callback,
  ) async {
    assert(parameters.length == parameterTypes.length);
    assert(parameterTypes.every((e) => e is Type || e is Required));

    final missingParameters = () {
      final missing = <String>[];
      for (var i = 0; i < parameters.length; i++) {
        if (parameterTypes[i] is Required) {
          final param = parameters[i];
          if (!request.uri.queryParameters.containsKey(param)) {
            missing.add(param);
          }
        }
      }
      return missing;
    }();

    final unknownParameters =
        request.uri.queryParameters.keys.where((p) => !parameters.contains(p));
    final invalidParameters = <String, Type>{};

    if (missingParameters.isNotEmpty) {
      return MissingParametersFailure(missingParameters).toResponse();
    } else if (unknownParameters.isNotEmpty) {
      return UnknownParametersFailure(unknownParameters).toResponse();
    } else {
      final parsedParameters = <String, dynamic>{};

      for (var i = 0; i < parameters.length; i++) {
        final param = parameters[i];
        final paramType = () {
          if (parameterTypes[i] is Required) {
            return (parameterTypes[i] as Required).type;
          } else {
            return parameterTypes[i];
          }
        }();

        final paramValue = request.uri.queryParameters[param];
        if (paramValue != null) {
          try {
            if (paramType == int) {
              parsedParameters[param] = int.parse(paramValue);
            } else if (paramType == double) {
              parsedParameters[param] = double.parse(paramValue);
            } else if (paramType == bool) {
              parsedParameters[param] = paramValue.toLowerCase() == 'true';
            } else if (paramType == DateTime) {
              parsedParameters[param] = DateTime.parse(paramValue);
            } else if (paramType == List || paramType == Map) {
              parsedParameters[param] = jsonDecode(paramValue);
            } else if (paramType == UuidValue) {
              parsedParameters[param] = paramValue.toUuidOrNull();
            } else if (paramType == List<UuidValue>) {
              parsedParameters[param] = paramValue
                  .split(',')
                  .map((e) => UuidValue.fromString(e))
                  .toList();
            } else {
              parsedParameters[param] = paramValue;
            }
          } catch (e) {
            invalidParameters[param] = paramType;
          }
        } else {
          if (paramType == List<UuidValue>) {
            parsedParameters[param] = <UuidValue>[];
          }
        }
      }

      if (invalidParameters.isNotEmpty) {
        return InvalidParameterTypesFailure(
          invalidParameters.keys,
          invalidParameters.values.map((e) => e.toString()),
        ).toResponse();
      }

      return callback(parsedParameters);
    }
  }

  Future<Response> getRequiredParametersFromBody(
    List<String> parameters,
    List<Type> paramenterTypes,
    Future<Response> Function(Map<String, dynamic>) callback,
  ) async {
    try {
      var body = await request.body();
      if (body.isEmpty) body = '{}';

      final json = jsonDecode(body) as Map<String, dynamic>;

      final missingParameters = parameters.where((p) => !json.containsKey(p));
      final unknownParameters = json.keys.where((p) => !parameters.contains(p));
      final invalidParameters = <String, Type>{};

      if (missingParameters.isNotEmpty) {
        return Future.value(
          MissingParametersFailure(missingParameters).toResponse(),
        );
      } else if (unknownParameters.isNotEmpty) {
        return Future.value(
          UnknownParametersFailure(unknownParameters).toResponse(),
        );
      } else {
        for (var i = 0; i < parameters.length; i++) {
          if (json[parameters[i]].runtimeType != paramenterTypes[i]) {
            invalidParameters[parameters[i]] = paramenterTypes[i];
          }
        }

        if (invalidParameters.isNotEmpty) {
          return Future.value(
            InvalidParameterTypesFailure(
              invalidParameters.keys,
              invalidParameters.values.map((e) => e.toString()),
            ).toResponse(),
          );
        }

        return callback(json);
      }
    } on FormatException catch (e) {
      return Future.value(
        InvalidBodyFormatFailure(e.toString().split(')').first + ')')
            .toResponse(),
      );
    }
  }

  T? readOrNull<T>() {
    try {
      return read<T>();
    } catch (_) {
      return null;
    }
  }
}

```

File: /packages/shared_backend/lib/infrastructure/extensions/data.dart
Content:
```
import 'dart:collection';
import 'dart:convert';
import 'package:shared_backend/domain.dart';

extension DataExtension<T> on DataOrFailure<T> {
  Response toResponse() {
    return when(
      success: (data) {
        try {
          if (data == null) return Response(statusCode: HttpStatus.ok);

          final json = switch (data) {
            ListBase() => data.map((e) {
                return (e as dynamic).toJson();
              }).toList(),
            _ => ((data as dynamic).toJson()) as Map<String, dynamic>,
          };

          final result = switch (data) {
            PaginatedList() => {
                'items': json,
                'next_cursor': data.nextCursor?.uuid,
              },
            List() => {'items': json},
            _ => {'data': json},
          };

          return Response(
            statusCode: HttpStatus.ok,
            body: jsonEncode(result),
          );
        } on NoSuchMethodError catch (e) {
          throw 'Data to response convertation error: ${e}';
        }
      },
      failure: (failure) {
        try {
          failure = failure as BackendFailure;

          return Response(
            statusCode: failure.statusCode,
            body: jsonEncode({'failure': failure.toJson()}),
          );
        } on NoSuchMethodError catch (_) {
          throw 'Failure to response convertation error: Failure is not BackendFailure';
        }
      },
    );
  }
}

extension FutureDataExtension<T> on Future<DataOrFailure<T>> {
  Future<Response> toResponse() async {
    return (await this).toResponse();
  }
}

extension BackendFailureToResponse on BackendFailure {
  Response toResponse() {
    return failed(this).toResponse();
  }
}

```

File: /packages/shared_backend/lib/infrastructure/extensions/enum.dart
Content:
```
import 'package:shared_backend/domain.dart';

extension ValidationByEnum on List<Enum> {
  bool containsAllAndNotNull(List<dynamic> values) {
    if (values.isEmpty) return false;
    return values.every((e) => this.map((e) => e.name).contains(e));
  }

  InvalidParameterValue getInvalidParameterValue(
    String parameterName,
    List<dynamic> parameterValue,
  ) {
    final unknownValues = parameterValue
        .where((e) => !this.map((e) => e.name).contains(e))
        .toList();

    return InvalidParameterValue(
      parameterName,
      unknownValues,
      this.map((e) => e.name).toList(),
    );
  }
}

```

File: /packages/shared_backend/lib/infrastructure/extensions/paginated_list.dart
Content:
```
import 'package:shared_backend/domain.dart';

extension ListToPaginatedListExtension<T> on Iterable<T> {
  PaginatedList<T> toPaginatedList(UuidValue? nextCursor) {
    return PaginatedList<T>(this.toList(), nextCursor);
  }
}

```

File: /packages/shared_backend/lib/infrastructure/exports.dart
Content:
```
export 'package:dart_frog/dart_frog.dart';

```

File: /packages/shared_backend/lib/domain/exports.dart
Content:
```
export 'package:shared/domain.dart';
export 'package:dart_frog/dart_frog.dart' show Response;

```

File: /packages/shared_app/pubspec.yaml
Content:
```
name: shared_app
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  auto_route: ^9.2.0
  cached_network_image: ^3.3.1
  flutter_svg: ^2.0.9
  intl: ^0.19.0
  dio: ^5.4.1
  simple_animations: ^5.0.2
  timeago_flutter: ^3.6.0
  hive: ^2.2.3
  path_provider: ^2.1.1
  provider: ^6.1.1
  logging: ^1.2.0
  shared:
  dino: ^1.0.0-pre.1
  font_awesome_flutter: ^10.7.0
  cross_file: ^0.3.4+1
  flutter_staggered_grid_view: ^0.7.0

dev_dependencies:
  auto_route_generator: ^9.0.0
  build_runner: ^2.4.7
  flutter_test:
    sdk: flutter

flutter:
  assets:
    - assets/images/
  uses-material-design: true

```

File: /packages/shared_app/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/extensions/data.dart';
export 'infrastructure/exports.dart';
export 'infrastructure/services/backend_client_service.dart';
export 'infrastructure/services/storage_service.dart';

```

File: /packages/shared_app/lib/presentation.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'presentation/viewmodels/logic.dart';
export 'presentation/viewmodels/data_notifier.dart';
export 'presentation/localizations/failure_localization.dart';
export 'presentation/extensions/failure.dart';
export 'presentation/extensions/date_time.dart';
export 'presentation/extensions/build_context.dart';
export 'presentation/extensions/category.dart';
export 'presentation/extensions/notifier.dart';
export 'presentation/extensions/daily_link_type.dart';
export 'presentation/extensions/widget.dart';
export 'presentation/exports.dart';
export 'presentation/services/scaffold_messenger_provider.dart';
export 'presentation/widgets/text_with_editing.dart';
export 'presentation/widgets/widget_with_logic.dart';
export 'presentation/widgets/animated_image.dart';
export 'presentation/widgets/disabling_decorator.dart';
export 'presentation/widgets/searched_posts_viewer.dart';
export 'presentation/widgets/collection_viewer.dart';
export 'presentation/widgets/smooth_list_view.dart';
export 'presentation/widgets/project_list_viewer.dart';
export 'presentation/widgets/clickable.dart';
export 'presentation/widgets/loading_decorator.dart';
export 'presentation/widgets/message_banner.dart';

```

File: /packages/shared_app/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/environment.dart';
export 'domain/exports.dart';
export 'domain/entities/failure.dart';

```

File: /packages/shared_app/lib/infrastructure/extensions/data.dart
Content:
```
import 'dart:convert';
import 'dart:io';

import 'package:shared_app/domain.dart';
import 'package:shared_app/infrastructure.dart';

extension SharedDataExtension on Future<Response> {
  Future<DataOrFailure<T>> toData<T>(
    T Function(dynamic response) map, {
    dynamic Function(dynamic response)? from,
  }) async {
    try {
      final response = await this;
      final result = map.call(
        from != null
            ? from(jsonDecode(response.data))
            : jsonDecode(response.data)?['data'] ?? {},
      );

      return successful(result);
    } catch (e) {
      final failure = switch (e) {
        DioException() => SharedBackendFailureHandler.toFailure(e),
        SocketException() => () {
            Logger.root.warning('Network failure');
            return NetworkFailure();
          }(),
        _ => () {
            Logger.root.severe('DOMAIN FAILURE: $e');
            return DomainFailure();
          }(),
      };

      return failed(failure);
    }
  }
}

extension DataExtension on Future<Response> {
  Future<PaginatedDataOrFailure<T>> toPaginatedData<T>(
    T Function(dynamic response) map,
  ) {
    return toData<PaginatedList<T>>(
      (response) => PaginatedList(
        (response['items'] as List).map(map).toList(),
        response['next_cursor'] == null
            ? null
            : UuidValue.fromString(response['next_cursor']),
      ),
      from: (response) => response,
    );
  }

  Future<ListDataOrFailure<T>> toListData<T>(
    T Function(dynamic response) map,
  ) {
    return toData<List<T>>(
      (response) => (response as List).map(map).toList(),
      from: (response) => response['items'],
    );
  }

  Future<SuccessOrFailure> toSuccess() async {
    return toData<void>((r) => null);
  }
}

final class SharedBackendFailureHandler {
  static Failure toFailure(DioException e) {
    if (e.type == DioExceptionType.connectionTimeout) return TimeoutFailure();

    if (e.response?.data != null) {
      try {
        final failure = BackendFailure.fromJson(
          (jsonDecode(e.response!.data) as Map<String, dynamic>)['failure']!,
        );

        Logger.root.warning('Failure: $failure');
        return failure;
      } catch (_) {
        return BackendFailure(e.response!.statusCode!);
      }
    } else if (e.response?.statusCode != null) {
      return BackendFailure(e.response!.statusCode!);
    } else {
      return NetworkFailure();
    }
  }
}

```

File: /packages/shared_app/lib/infrastructure/exports.dart
Content:
```
export 'package:dio/dio.dart';
export 'package:hive/hive.dart';
export 'package:path_provider/path_provider.dart';
export 'package:provider/provider.dart';
export 'package:logging/logging.dart';
export 'package:shared_app/infrastructure.dart';
export 'package:dino/dino.dart';

```

File: /packages/shared_app/lib/infrastructure/services/backend_client_service.dart
Content:
```
import 'dart:async';

import 'package:shared_app/domain.dart';
import 'package:shared_app/infrastructure.dart';

const _baseUrls = {
  Environment.development: 'localhost',
  Environment.production: 'localhost',
};
const _port = 8080;

final class BackendClientService implements Initializable, Disposable {
  BackendClientService(this._environment);

  final Environment _environment;

  late final _client = Dio(
    BaseOptions(baseUrl: 'http://${_baseUrls[_environment]}:$_port'),
  );

  @override
  Future<void> initialize() async {
    return _client.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          Logger.root.info('Request: ${options.method} ${options.path}');
          return handler.next(options);
        },
        onResponse: (response, handler) {
          Logger.root.info('Response: ${response.statusCode}');
          return handler.next(response);
        },
      ),
    );
  }

  @override
  Future<void> dispose() async {
    return _client.close();
  }

  Dio get client => _client;
}

```

File: /packages/shared_app/lib/infrastructure/services/storage_service.dart
Content:
```
import 'dart:async';
import 'dart:io';

import 'package:shared_app/domain.dart';
import 'package:shared_app/infrastructure.dart';
import 'package:flutter/foundation.dart';

const _preferencesKey = 'preferences';

final class StorageService implements Initializable, Disposable {
  StorageService(this._environment);

  final Environment _environment;

  late Directory? _directory;
  late Box _preferencesForAllAccounts;

  @override
  Future<void> initialize() async {
    _directory = kIsWeb ? null : await getApplicationDocumentsDirectory();
    _preferencesForAllAccounts = await Hive.openBox(
      '${_preferencesKey}_$_environment',
      path: _directory?.path,
    );
  }

  @override
  Future<void> dispose() {
    return _preferencesForAllAccounts.close();
  }

  Box get preferencesForAllAccounts => _preferencesForAllAccounts;
}

```

File: /packages/shared_app/lib/domain/environment.dart
Content:
```
enum Environment { production, development }

```

File: /packages/shared_app/lib/domain/exports.dart
Content:
```
export 'package:shared/domain.dart';

```

File: /packages/shared_app/lib/domain/entities/failure.dart
Content:
```
import 'package:shared_app/domain.dart';

final class TimeoutFailure extends Failure {}

final class NetworkFailure extends Failure {}

final class DomainFailure extends Failure {}

```

File: /packages/shared_app/lib/presentation/viewmodels/logic.dart
Content:
```
import 'dart:async';

import 'package:shared_app/infrastructure.dart';
import 'package:shared_app/presentation.dart';

abstract class Logic {
  const Logic(this.context);

  @protected
  final BuildContext context;

  @protected
  T getRequired<T>() => context.read<ServiceProvider>().getRequired<T>();

  FutureOr<void> initLogic() {}

  void disposeLogic() {}

  @protected
  ScaffoldMessengerState get scaffoldMessenger =>
      getRequired<ScaffoldMessengerProvider>().scaffoldMessenger;
}

```

File: /packages/shared_app/lib/presentation/viewmodels/data_notifier.dart
Content:
```
import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

typedef ListDataState<T> = DataState<List<T>>;

final class SeveralDataList {
  const SeveralDataList(this._dataList);

  final List _dataList;

  T get<T>() {
    try {
      return _dataList.whereType<T>().first;
    } catch (e) {
      throw Exception('Data type $T is not found');
    }
  }
}

extension SeveralDataNotifiers on List<DataNotifier> {
  // TODO: сделать виджеты
  Widget when({
    Widget Function()? initial,
    Widget Function()? loading,
    required Widget Function(SeveralDataList dataList) success,
    Widget Function(Failure failure)? failed,
  }) {
    List dataList = [];

    return _recursiveWhen(
      index: 0,
      initial: initial,
      loading: loading,
      success: success,
      failed: failed,
      dataList: dataList,
    );
  }

  Widget _recursiveWhen({
    required int index,
    Widget Function()? initial,
    Widget Function()? loading,
    required Widget Function(SeveralDataList dataList) success,
    Widget Function(Failure failure)? failed,
    required List dataList,
  }) {
    if (index == length) {
      if (dataList.isEmpty) {
        return initial?.call() ?? const DataStateInitial().stateToWidget(null);
      }

      return success(SeveralDataList(dataList));
    }

    return this[index].builder(
      builder: (context, state, child) {
        if (state.isFailed) {
          return failed?.call(state.asFailed!.failure) ??
              state.stateToWidget(context);
        } else if (state.isInitial && initial != null) {
          return initial();
        } else if (state.isLoading) {
          return loading?.call() ?? state.stateToWidget(context);
        } else if (state.isSuccess) {
          dataList.add(state.asSuccess!.data);
        } else if (state.isLoadingMore) {
          dataList.add(state.asLoadingMore!.data);
        }

        return _recursiveWhen(
          index: index + 1,
          initial: initial,
          loading: loading,
          success: success,
          failed: failed,
          dataList: dataList,
        );
      },
    );
  }
}

final class DataNotifier<T> extends ValueNotifier<DataState<T>> {
  DataNotifier([DataState<T> state = const DataStateInitial()]) : super(state);

  Widget when({
    Widget Function()? initial,
    Widget Function()? loading,
    required Widget Function(T data) success,
    Widget Function(Failure failure)? failed,
  }) {
    return ValueListenableBuilder<DataState<T>>(
      valueListenable: this,
      builder: (context, state, child) {
        if (state.isInitial) {
          return initial?.call() ?? state.stateToWidget(context);
        } else if (state.isLoading) {
          return loading?.call() ?? state.stateToWidget(context);
        } else if (state.isSuccess) {
          return success(state.asSuccess!.data);
        } else if (state.isLoadingMore) {
          return success(state.asLoadingMore!.data);
        } else if (state.isFailed) {
          return failed?.call(state.asFailed!.failure) ??
              state.stateToWidget(context);
        } else {
          throw UnsupportedError('Unsupported state: $state');
        }
      },
    );
  }

  Widget builder({
    required Widget Function(
      BuildContext context,
      DataState<T> state,
      Widget? child,
    ) builder,
    Widget? child,
  }) {
    return ValueListenableBuilder<DataState<T>>(
      valueListenable: this,
      builder: builder,
      child: child,
    );
  }

  Future<void> loadData(
    Future<DataOrFailure<T>> from, {
    T? cachedData,
    void Function(T data)? onSuccess,
    void Function(Failure failure)? onFailure,
  }) async {
    if (cachedData != null && value.isInitial) {
      value = DataStateSuccess(cachedData);
    } else {
      value = const DataStateLoading();
    }
    notifyListeners();

    final result = await from;
    result.when(
      success: (data) {
        value = DataStateSuccess(data);
        onSuccess?.call(data);
      },
      failure: (failure) {
        value = DataStateFailed(failure);
        onFailure?.call(failure);
      },
    );

    notifyListeners();
  }

  Future<void> loadMore(
    Future<DataOrFailure<T>> from, {
    void Function(T data)? onSuccess,
    void Function(Failure failure)? onFailure,
  }) async {
    if (!value.isSuccess) return;

    if (value.asSuccess?.data is! PaginatedList) {
      throw UnsupportedError(
          'Data type ${value.asSuccess?.data.runtimeType} is not PaginatedList');
    }

    final data = value.asSuccess?.data as PaginatedList;
    if (data.isEmpty || data.nextCursor == null) {
      return;
    }

    value = DataStateLoadingMore(data as T);
    notifyListeners();

    final result = await from;
    result.when(
      success: (data) {
        if (data is PaginatedList) {
          value = DataStateSuccess(
            (value.asLoadingMore?.data as PaginatedList).merge(data) as T,
          );
        } else {
          throw UnsupportedError('Data type $T is not PaginatedList');
        }
        onSuccess?.call(data);
      },
      failure: (failure) {
        value = DataStateFailed(failure);
        onFailure?.call(failure);
      },
    );
  }
}

sealed class DataState<T> {
  const DataState();

  bool get isInitial => this is DataStateInitial<T>;
  bool get isLoading => this is DataStateLoading<T>;
  bool get isSuccess => this is DataStateSuccess<T>;
  bool get isLoadingMore => this is DataStateLoadingMore<T>;
  bool get isFailed => this is DataStateFailed<T>;

  DataStateInitial<T>? get asInitial =>
      this is DataStateInitial<T> ? this as DataStateInitial<T> : null;
  DataStateLoading<T>? get asLoading =>
      this is DataStateLoading<T> ? this as DataStateLoading<T> : null;
  DataStateSuccess<T>? get asSuccess =>
      this is DataStateSuccess<T> ? this as DataStateSuccess<T> : null;
  DataStateLoadingMore<T>? get asLoadingMore =>
      this is DataStateLoadingMore<T> ? this as DataStateLoadingMore<T> : null;
  DataStateFailed<T>? get asFailed =>
      this is DataStateFailed<T> ? this as DataStateFailed<T> : null;

  Widget stateToWidget<T>(BuildContext? context) {
    switch (this) {
      case DataStateInitial<T>():
        return const SizedBox.shrink();
      case DataStateLoading<T>():
        return const Center(child: CircularProgressIndicator());
      case DataStateFailed<T>(failure: final failure):
        if (failure is NetworkFailure) {
          return Center(
            child: MessageBanner(
              message: context == null
                  ? failure.toString()
                  : failure.toLocalizedString(context),
              iconData: FontAwesomeIcons.server,
            ),
          );
        }
        return Center(
            child: Text(
          context == null
              ? failure.toString()
              : failure.toLocalizedString(context),
        ));
      default:
        throw UnsupportedError('Unsupported state: $this');
    }
  }

  A when<A>({
    required A Function() initial,
    required A Function() loading,
    required A Function(T data, Failure? failure) success,
    required A Function(T data) loadingMore,
    required A Function(Failure failure) failed,
  }) {
    switch (this) {
      case DataStateInitial<T>():
        return initial();
      case DataStateLoading<T>():
        return loading();
      case DataStateSuccess<T>(data: final data, failure: final failure):
        return success(data, failure);
      case DataStateLoadingMore<T>(data: final data):
        return loadingMore(data);
      case DataStateFailed<T>(failure: final failure):
        return failed(failure);
      default:
        throw UnsupportedError('Unsupported state: $this');
    }
  }

  A whenOrElse<A>({
    A Function()? initial,
    A Function()? loading,
    A Function(T data, Failure? failure)? success,
    A Function(T data)? loadingMore,
    A Function(Failure failure)? failed,
    required A Function() orElse,
  }) {
    switch (this) {
      case DataStateInitial<T>():
        return initial?.call() ?? orElse();
      case DataStateLoading<T>():
        return loading?.call() ?? orElse();
      case DataStateSuccess<T>(data: final data, failure: final failure):
        return success?.call(data, failure) ?? orElse();
      case DataStateLoadingMore<T>(data: final data):
        return loadingMore?.call(data) ?? orElse();
      case DataStateFailed<T>(failure: final failure):
        return failed?.call(failure) ?? orElse();
      default:
        throw UnsupportedError('Unsupported state: $this');
    }
  }

  A? whenOrNull<A>({
    A Function()? initial,
    A Function()? loading,
    A Function(T data, Failure? failure)? success,
    A Function(T data)? loadingMore,
    A Function(Failure failure)? failed,
  }) {
    switch (this) {
      case DataStateInitial<T>():
        return initial?.call();
      case DataStateLoading<T>():
        return loading?.call();
      case DataStateSuccess<T>(data: final data, failure: final failure):
        return success?.call(data, failure);
      case DataStateLoadingMore<T>(data: final data):
        return loadingMore?.call(data);
      case DataStateFailed<T>(failure: final failure):
        return failed?.call(failure);
      default:
        throw UnsupportedError('Unsupported state: $this');
    }
  }

  Widget whenOrDefault(
    BuildContext context, {
    Widget Function()? initial,
    Widget Function()? loading,
    Widget Function(T data, Failure? failure)? success,
    Widget Function(T data)? loadingMore,
    Widget Function(Failure failure)? failed,
  }) {
    switch (this) {
      case DataStateInitial<T>():
        return initial?.call() ?? stateToWidget(context);
      case DataStateLoading<T>():
        return loading?.call() ?? stateToWidget(context);
      case DataStateSuccess<T>(data: final data, failure: final failure):
        return success?.call(data, failure) ?? stateToWidget(context);
      case DataStateLoadingMore<T>(data: final data):
        return loadingMore?.call(data) ?? stateToWidget(context);
      case DataStateFailed<T>(failure: final failure):
        return failed?.call(failure) ?? stateToWidget(context);
      default:
        throw UnsupportedError('Unsupported state: $this');
    }
  }
}

final class DataStateInitial<T> extends DataState<T> {
  const DataStateInitial();
}

final class DataStateLoading<T> extends DataState<T> {
  const DataStateLoading();
}

final class DataStateSuccess<T> extends DataState<T> {
  const DataStateSuccess(this.data, [this.failure]);
  final T data;
  final Failure? failure;
}

final class DataStateLoadingMore<T> extends DataState<T> {
  const DataStateLoadingMore(this.data);
  final T data;
}

final class DataStateFailed<T> extends DataState<T> {
  const DataStateFailed(this.failure);
  final Failure failure;
}

```

File: /packages/shared_app/lib/presentation/localizations/localizations.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.
// ignore_for_file: library_private_types_in_public_api

import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

part 'ru.g.dart';
part 'en.g.dart';

abstract final class SharedAppLocalizationData {
  String get languageName;
  String get unknownServerError;
  String get networkError;
  String get unknownError;
  String get email;
  String get password;
  String get totpCode;
  String get authorization;
  String get signIn;
  String get signOut;
  String get fillAllFieldsError;
  String get dailyLinkTypeVideo;
  String get dailyLinkTypeStartup;
  String get dailyLinkTypeUtility;
  String get dailyLinkTypeSite;
  String get dailyLinkTypeArticle;
  String get dailyLinkTypeCases;
  String get dailyLinkTypeVideoMultiple;
  String get dailyLinkTypeStartupMultiple;
  String get dailyLinkTypeUtilityMultiple;
  String get dailyLinkTypeSiteMultiple;
  String get dailyLinkTypeArticleMultiple;
  String get dailyLinkTypeCasesMultiple;

  Map<String, String> get map;
}

final class SharedAppLocalizations {
  static const _SharedAppLocalizationsDelegate delegate =
      _SharedAppLocalizationsDelegate();

  static SharedAppLocalizationData of(BuildContext context) {
    return Localizations.of<SharedAppLocalizationData>(
      context,
      SharedAppLocalizationData,
    )!;
  }

  static const List<Locale> supportedLocales = [Locale('ru'), Locale('en')];

  static const List<LocalizationsDelegate> localizationsDelegates = [
    SharedAppLocalizations.delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];
}

final class _SharedAppLocalizationsDelegate
    extends LocalizationsDelegate<SharedAppLocalizationData> {
  const _SharedAppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) =>
      SharedAppLocalizations.supportedLocales.contains(locale);

  @override
  Future<SharedAppLocalizationData> load(Locale locale) async {
    switch (locale.languageCode) {
      case 'ru':
        return const RuSharedAppLocalizationData();
      case 'en':
        return const EnSharedAppLocalizationData();
      default:
        return const RuSharedAppLocalizationData();
    }
  }

  @override
  bool shouldReload(_SharedAppLocalizationsDelegate old) => false;
}

extension SharedAppLocalizationsExtension on BuildContext {
  SharedAppLocalizationData get sharedAppLocalizations =>
      SharedAppLocalizations.of(this);
}


```

File: /packages/shared_app/lib/presentation/localizations/ru.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class RuSharedAppLocalizationData implements SharedAppLocalizationData {
  const RuSharedAppLocalizationData();

  @override
  String get languageName => r'Русский';
  @override
  String get unknownServerError => r'Неизвестная ошибка сервера';
  @override
  String get networkError => r'Сервер недоступен';
  @override
  String get unknownError => r'Неизвестная ошибка';
  @override
  String get email => r'Электронная почта';
  @override
  String get password => r'Пароль';
  @override
  String get totpCode => r'TOTP-код';
  @override
  String get authorization => r'Авторизация';
  @override
  String get signIn => r'Войти';
  @override
  String get signOut => r'Выйти';
  @override
  String get fillAllFieldsError => r'Пожалуйста, заполните все поля.';
  @override
  String get dailyLinkTypeVideo => r'Видео';
  @override
  String get dailyLinkTypeStartup => r'Стартап';
  @override
  String get dailyLinkTypeUtility => r'Инструмент';
  @override
  String get dailyLinkTypeSite => r'Сайт';
  @override
  String get dailyLinkTypeArticle => r'Статья';
  @override
  String get dailyLinkTypeCases => r'Кейс';
  @override
  String get dailyLinkTypeVideoMultiple => r'Видео';
  @override
  String get dailyLinkTypeStartupMultiple => r'Стартапы';
  @override
  String get dailyLinkTypeUtilityMultiple => r'Инструменты';
  @override
  String get dailyLinkTypeSiteMultiple => r'Сайты';
  @override
  String get dailyLinkTypeArticleMultiple => r'Статьи';
  @override
  String get dailyLinkTypeCasesMultiple => r'Кейсы';

  @override
  Map<String, String> get map => {
        'language_name': r'Русский',
        'unknown_server_error': r'Неизвестная ошибка сервера',
        'network_error': r'Сервер недоступен',
        'unknown_error': r'Неизвестная ошибка',
        'email': r'Электронная почта',
        'password': r'Пароль',
        'totp_code': r'TOTP-код',
        'authorization': r'Авторизация',
        'sign_in': r'Войти',
        'sign_out': r'Выйти',
        'fill_all_fields_error': r'Пожалуйста, заполните все поля.',
        'daily_link_type_video': r'Видео',
        'daily_link_type_startup': r'Стартап',
        'daily_link_type_utility': r'Инструмент',
        'daily_link_type_site': r'Сайт',
        'daily_link_type_article': r'Статья',
        'daily_link_type_cases': r'Кейс',
        'daily_link_type_video_multiple': r'Видео',
        'daily_link_type_startup_multiple': r'Стартапы',
        'daily_link_type_utility_multiple': r'Инструменты',
        'daily_link_type_site_multiple': r'Сайты',
        'daily_link_type_article_multiple': r'Статьи',
        'daily_link_type_cases_multiple': r'Кейсы',
      };
}

```

File: /packages/shared_app/lib/presentation/localizations/failure_localization.dart
Content:
```
import 'package:shared_app/domain.dart';
import 'package:shared_app/infrastructure.dart';
import 'package:shared_app/presentation.dart';

final class SharedFailureLocalization {
  static String toLocalizedString(BuildContext context, Failure failure) {
    final localization = context.sharedAppLocalizations;

    if (failure is BackendFailure) {
      if (failure.toSnakeCase() != 'backend_failure') {
        return localization.map[failure.toSnakeCase()] ?? failure.toSnakeCase();
      } else {
        Logger.root.severe('Unknown backend failure: ${failure.statusCode}');
        return localization.unknownServerError;
      }
    } else if (failure is NetworkFailure) {
      return localization.networkError;
    } else if (failure is DomainFailure) {
      return localization.unknownError;
    } else {
      return localization.unknownError;
    }
  }
}

```

File: /packages/shared_app/lib/presentation/localizations/en.g.dart
Content:
```
// GENERATED FILE. DO NOT MODIFY.

part of 'localizations.g.dart';

final class EnSharedAppLocalizationData implements SharedAppLocalizationData {
  const EnSharedAppLocalizationData();

  @override
  String get languageName => r'English';
  @override
  String get unknownServerError => r'Unknown server error';
  @override
  String get networkError => r'Server is not available';
  @override
  String get unknownError => r'Unknown error';
  @override
  String get email => r'Email';
  @override
  String get password => r'Password';
  @override
  String get totpCode => r'TOTP code';
  @override
  String get authorization => r'Authorization';
  @override
  String get signIn => r'Sign In';
  @override
  String get signOut => r'Sign Out';
  @override
  String get fillAllFieldsError => r'Please fill all the fields.';
  @override
  String get dailyLinkTypeVideo => r'Video';
  @override
  String get dailyLinkTypeStartup => r'Startup';
  @override
  String get dailyLinkTypeUtility => r'Utility';
  @override
  String get dailyLinkTypeSite => r'Site';
  @override
  String get dailyLinkTypeArticle => r'Article';
  @override
  String get dailyLinkTypeCases => r'Case';
  @override
  String get dailyLinkTypeVideoMultiple => r'Videos';
  @override
  String get dailyLinkTypeStartupMultiple => r'Startups';
  @override
  String get dailyLinkTypeUtilityMultiple => r'Utilities';
  @override
  String get dailyLinkTypeSiteMultiple => r'Sites';
  @override
  String get dailyLinkTypeArticleMultiple => r'Articles';
  @override
  String get dailyLinkTypeCasesMultiple => r'Cases';

  @override
  Map<String, String> get map => {
        'language_name': r'English',
        'unknown_server_error': r'Unknown server error',
        'network_error': r'Server is not available',
        'unknown_error': r'Unknown error',
        'email': r'Email',
        'password': r'Password',
        'totp_code': r'TOTP code',
        'authorization': r'Authorization',
        'sign_in': r'Sign In',
        'sign_out': r'Sign Out',
        'fill_all_fields_error': r'Please fill all the fields.',
        'daily_link_type_video': r'Video',
        'daily_link_type_startup': r'Startup',
        'daily_link_type_utility': r'Utility',
        'daily_link_type_site': r'Site',
        'daily_link_type_article': r'Article',
        'daily_link_type_cases': r'Case',
        'daily_link_type_video_multiple': r'Videos',
        'daily_link_type_startup_multiple': r'Startups',
        'daily_link_type_utility_multiple': r'Utilities',
        'daily_link_type_site_multiple': r'Sites',
        'daily_link_type_article_multiple': r'Articles',
        'daily_link_type_cases_multiple': r'Cases',
      };
}

```

File: /packages/shared_app/lib/presentation/extensions/failure.dart
Content:
```
import 'package:shared/domain.dart';
import 'package:shared_app/presentation.dart';

extension FailureExtension on Failure {
  String toLocalizedString(BuildContext context) {
    return SharedFailureLocalization.toLocalizedString(context, this);
  }
}

```

File: /packages/shared_app/lib/presentation/extensions/date_time.dart
Content:
```
import 'package:shared_app/presentation.dart';

extension DateTimeExtension on DateTime {
  String format(BuildContext context, String format) {
    return DateFormat(format, context.locale.toString()).format(this);
  }
}

```

File: /packages/shared_app/lib/presentation/extensions/build_context.dart
Content:
```
import 'package:shared_app/infrastructure.dart';
import 'package:shared_app/presentation.dart';

extension BuildContextExtension on BuildContext {
  T? getRequired<T>() {
    return read<ServiceProvider>().getRequired();
  }

  Locale get locale => Localizations.localeOf(this);
}

```

File: /packages/shared_app/lib/presentation/extensions/category.dart
Content:
```
import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

extension CategoryExtension on Category {
  String translate(BuildContext context) {
    if (!value.startsWith('tr::')) return value;
    return SharedAppLocalizations.of(context)
        .map['category_${this.value.replaceFirst('tr::', '')}']!;
  }
}

```

File: /packages/shared_app/lib/presentation/extensions/notifier.dart
Content:
```
import 'package:flutter/widgets.dart';

extension NotifierExtension<T> on ValueNotifier<T> {
  Widget builder(
    Widget Function(BuildContext context, T value, Widget? child) builder, {
    Widget? child,
  }) {
    return ValueListenableBuilder<T>(
      valueListenable: this,
      builder: (context, value, child) {
        return builder(context, value, child);
      },
      child: child,
    );
  }
}

```

File: /packages/shared_app/lib/presentation/extensions/daily_link_type.dart
Content:
```
import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

extension DailyLinkTypeExtension on DailyLinkType {
  String translate(BuildContext context, bool isMultiple) {
    return SharedAppLocalizations.of(context)
        .map['daily_link_type_${name}${isMultiple ? '_multiple' : ''}']!;
  }
}

```

File: /packages/shared_app/lib/presentation/extensions/widget.dart
Content:
```
import 'package:shared_app/presentation.dart';

extension WidgetListExtension on List<Widget> {
  List<Widget> separated(Widget separator) {
    if (isEmpty) return this;
    return expand((element) => [element, separator]).toList()..removeLast();
  }
}

extension WidgetIterableExtension on Iterable<Widget> {
  List<Widget> separated(Widget separator) {
    if (isEmpty) return this.toList();
    return expand((element) => [element, separator]).toList()..removeLast();
  }
}

```

File: /packages/shared_app/lib/presentation/exports.dart
Content:
```
export 'package:auto_route/auto_route.dart';
export 'package:cached_network_image/cached_network_image.dart';
export 'package:flutter_svg/flutter_svg.dart';
export 'package:intl/intl.dart' hide TextDirection;
export 'package:simple_animations/simple_animations.dart';
export 'package:timeago_flutter/timeago_flutter.dart';
export 'package:provider/provider.dart';
export 'package:flutter/material.dart' hide Page;
export 'package:intl/date_symbol_data_local.dart';
export 'package:flutter/services.dart' show SystemChrome, SystemUiMode;
export 'package:flutter/foundation.dart' show SynchronousFuture;
export 'localizations/localizations.g.dart';
export 'package:font_awesome_flutter/font_awesome_flutter.dart';
export 'package:flutter_staggered_grid_view/flutter_staggered_grid_view.dart';

```

File: /packages/shared_app/lib/presentation/services/scaffold_messenger_provider.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class ScaffoldMessengerProvider {
  final scaffoldMessengerKey = GlobalKey<ScaffoldMessengerState>();
  ScaffoldMessengerState get scaffoldMessenger =>
      scaffoldMessengerKey.currentState!;
}

```

File: /packages/shared_app/lib/presentation/widgets/text_with_editing.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class TextWithEditing extends StatefulWidget {
  const TextWithEditing(
    this.content, {
    super.key,
    this.changingText,
    required this.onChanged,
    required this.style,
    required this.maxLines,
  });

  final String content;
  final String? changingText;
  final ValueChanged<String>? onChanged;
  final TextStyle style;
  final int maxLines;

  @override
  State<TextWithEditing> createState() => _TextWithEditingState();
}

final class _TextWithEditingState extends State<TextWithEditing> {
  var isEditable = false;
  final focusNode = FocusNode();
  final controller = TextEditingController();

  @override
  void initState() {
    super.initState();
    focusNode.addListener(() {
      setState(() => isEditable = focusNode.hasFocus);
    });
  }

  @override
  void dispose() {
    controller.dispose();
    focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(context) {
    if (isEditable) {
      return EditableText(
        focusNode: focusNode,
        controller: controller,
        style: widget.style,
        cursorColor: Colors.black,
        backgroundCursorColor: Colors.black,
        selectionColor: Colors.black12,
        minLines: 1,
        maxLines: widget.maxLines,
        onChanged: widget.onChanged,
      );
    } else {
      return Clickable(
        onTap: widget.onChanged == null
            ? null
            : () {
                controller.text = widget.changingText ?? widget.content;
                focusNode.requestFocus();

                setState(() => isEditable = true);
              },
        isDisabling: false,
        child: Text(
          widget.content,
          style: widget.style,
          overflow: TextOverflow.ellipsis,
          maxLines: widget.maxLines,
        ),
      );
    }
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/widget_with_logic.dart
Content:
```
import 'package:shared_app/presentation.dart';

abstract class WidgetWithLogic<T extends Logic> extends StatefulWidget {
  const WidgetWithLogic({super.key});

  T logicBuilder(BuildContext context);

  Widget build(BuildContext context, T logic);

  @override
  _WidgetWithLogicState<T> createState() => _WidgetWithLogicState<T>();
}

final class _WidgetWithLogicState<T extends Logic>
    extends State<WidgetWithLogic<T>> {
  late T logic;

  @override
  void initState() {
    super.initState();
    logic = widget.logicBuilder(context);
    logic.initLogic();
  }

  @override
  void dispose() {
    logic.disposeLogic();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Provider<T>.value(
      value: logic,
      child: widget.build(context, logic),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/animated_image.dart
Content:
```
import 'package:shared_app/presentation.dart';

enum AnimatedImageDirection {
  horizontal,
  vertical,
}

final class AnimatedNetworkImage extends StatefulWidget {
  const AnimatedNetworkImage(
    this.imageUrl, {
    Key? key,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
  }) : super(key: key);

  final Uri? imageUrl;
  final double? width;
  final double? height;
  final BoxFit fit;

  @override
  State<AnimatedNetworkImage> createState() => _AnimatedNetworkImageState();
}

final class _AnimatedNetworkImageState extends State<AnimatedNetworkImage> {
  bool _isVisible = false;

  @override
  void initState() {
    super.initState();
    _startFadeIn();
  }

  void _startFadeIn() async {
    await Future.delayed(const Duration(milliseconds: 100));
    if (mounted) {
      setState(() {
        _isVisible = true;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: _isVisible ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 100),
      child: AnimatedSize(
        curve: Curves.linearToEaseOut,
        duration: const Duration(milliseconds: 300),
        child: ConstrainedBox(
          constraints: BoxConstraints(
            minWidth: widget.width ?? 200,
            minHeight: widget.height ?? 200,
          ),
          child: CachedNetworkImage(
            fadeOutDuration: const Duration(milliseconds: 100),
            fadeInDuration: const Duration(milliseconds: 100),
            imageUrl: '${widget.imageUrl}',
            width: widget.width,
            height: widget.height,
            fit: widget.fit,
            errorWidget: (_, __, ___) {
              return Container(
                width: widget.width ?? 200,
                height: widget.height ?? 200,
                color: const Color(0xFFE0E0E0),
                child: const Icon(
                  Icons.image_not_supported,
                  color: Colors.grey,
                ),
              );
            },
            placeholder: (context, url) {
              return Container(
                width: widget.width ?? 200,
                height: widget.height ?? 200,
                color: const Color(0xFFE0E0E0),
              );
            },
          ),
        ),
      ),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/disabling_decorator.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class DisablingDecorator extends StatelessWidget {
  const DisablingDecorator({
    super.key,
    required this.isDisabled,
    required this.child,
  });
  final bool isDisabled;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      duration: const Duration(milliseconds: 200),
      curve: Curves.fastOutSlowIn,
      opacity: isDisabled ? 0.5 : 1,
      child: IgnorePointer(
        ignoring: isDisabled,
        child: child,
      ),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/searched_posts_viewer.dart
Content:
```
import 'dart:async';

import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

final class SearchedPostsViewer extends StatefulWidget {
  const SearchedPostsViewer(
    this.data, {
    this.onPostPressed,
    required this.onEndReached,
    required this.isHasMore,
  });

  final List<BrandingPost> data;
  final ValueChanged<BrandingPost>? onPostPressed;
  final VoidCallback onEndReached;
  final bool isHasMore;

  @override
  State<SearchedPostsViewer> createState() => _SearchedPostsViewerState();
}

final class _SearchedPostsViewerState extends State<SearchedPostsViewer> {
  late ScrollController _scrollController = ScrollController()
    ..addListener(_onScroll);
  Timer? _timer;
  bool _antispamEnabled = false;

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    _timer?.cancel();
    super.dispose();
  }

  void _antispam() {
    _antispamEnabled = true;
    _timer = Timer(const Duration(milliseconds: 200), () {
      _antispamEnabled = false;
    });
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 500 &&
        widget.isHasMore &&
        !_antispamEnabled) {
      _antispam();
      widget.onEndReached();
    }
  }

  @override
  Widget build(BuildContext context) {
    return MasonryGridView.count(
      padding: const EdgeInsets.only(
        left: 20,
        right: 20,
        top: 20,
        bottom: 20,
      ),
      crossAxisCount: 3,
      mainAxisSpacing: 20,
      crossAxisSpacing: 20,
      controller: _scrollController,
      itemCount: widget.data.length,
      itemBuilder: (context, index) {
        return _PostWidget(
          widget.data[index],
          onPressed: () => widget.onPostPressed?.call(widget.data[index]),
        );
      },
    );
  }
}

final class _PostWidget extends StatefulWidget {
  const _PostWidget(
    this.data, {
    required this.onPressed,
  });

  final BrandingPost data;
  final VoidCallback? onPressed;

  @override
  State<_PostWidget> createState() => _PostWidgetState();
}

final class _PostWidgetState extends State<_PostWidget> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: Clickable(
        onTap: widget.onPressed,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            AnimatedNetworkImage(
              widget.data.imageUrl,
              fit: BoxFit.cover,
            ),
            Text(
              '${widget.data.name} — ${widget.data.parent!.name}',
              style: const TextStyle(
                fontFamily: 'Cygre Medium',
                fontSize: 20,
                fontWeight: FontWeight.w500,
                height: 32.34 / 20,
              ),
            ),
            Text(
              widget.data.studio.name,
              style: const TextStyle(
                fontFamily: 'Cygre Medium',
                fontSize: 16,
                fontWeight: FontWeight.w500,
                height: 19.2 / 16,
                color: Color(0xFF646464),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/collection_viewer.dart
Content:
```
import 'dart:math';

import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

final class CollectionViewer extends StatefulWidget {
  const CollectionViewer(
    this.skeleton, {
    this.onPressed,
    this.onChangeImage,
    this.onChangeTitle,
    this.onChangeUrl,
    this.onSetPreviewFromUrl,
  });

  final List<List<DailyLinkModel>> skeleton;
  final void Function(DailyLinkModel link)? onPressed;
  final void Function(DailyLinkRequest link)? onChangeImage;
  final void Function(DailyLinkRequest link, String title)? onChangeTitle;
  final void Function(DailyLinkRequest link, String url)? onChangeUrl;
  final void Function(DailyLinkRequest link)? onSetPreviewFromUrl;

  @override
  State<CollectionViewer> createState() => _CollectionViewerState();
}

final class _CollectionViewerState extends State<CollectionViewer> {
  Map<int, bool>? isDoubleLines;

  @override
  Widget build(BuildContext context) {
    isDoubleLines = {
      for (int i = 0; i < widget.skeleton.length; i++) i: false,
    };

    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          for (int i = 0; i < widget.skeleton.length; i++) ...[
            if (widget.skeleton[i].length > 4)
              Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    widget.skeleton[i].first.type.translate(context, true),
                    style: const TextStyle(
                      fontFamily: 'Cygre',
                      fontSize: 26,
                      fontWeight: FontWeight.w500,
                      height: 42.04 / 26,
                    ),
                  ),
                  const SizedBox(height: 21),
                  GridView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 4,
                      crossAxisSpacing: 30,
                      mainAxisSpacing: 30,
                      childAspectRatio: 40 / 41,
                    ),
                    itemCount: widget.skeleton[i].length,
                    itemBuilder: (context, index) {
                      final link = widget.skeleton[i][index];
                      final request = link as DailyLinkRequest;

                      return _LinkWidget(
                        link,
                        aspectRatio: 40 / 41,
                        titleMaxLines: 1,
                        onPressed: widget.onPressed == null
                            ? null
                            : () => widget.onPressed!(link),
                        onChangeImage: widget.onChangeImage == null
                            ? null
                            : () => widget.onChangeImage!(request),
                        onChangeTitle: widget.onChangeTitle == null
                            ? null
                            : (title) => widget.onChangeTitle!(request, title),
                        onChangeUrl: widget.onChangeUrl == null
                            ? null
                            : (url) => widget.onChangeUrl!(request, url),
                        onSetPreviewFromUrl: widget.onSetPreviewFromUrl == null
                            ? null
                            : () => widget.onSetPreviewFromUrl!(request),
                      );
                    },
                  ),
                ],
              ),
            if (widget.skeleton[i].length <= 4)
              Row(
                children: [
                  for (int j = 0; j < max(widget.skeleton[i].length, 3); j++)
                    Builder(
                      builder: (context) {
                        if (j >= widget.skeleton[i].length) {
                          return const Expanded(child: SizedBox());
                        }

                        final link = widget.skeleton[i][j];

                        final linksWithCurrentType = widget.skeleton[i]
                            .where((e) => e.type == link.type);
                        final isFirst = linksWithCurrentType.first == link;

                        return Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                link.type.translate(
                                  context,
                                  linksWithCurrentType.length > 1,
                                ),
                                style: TextStyle(
                                  fontFamily: 'Cygre',
                                  fontSize: 26,
                                  fontWeight: FontWeight.w500,
                                  height: 42.04 / 26,
                                  color: isFirst
                                      ? Colors.black
                                      : Colors.transparent,
                                ),
                              ),
                              const SizedBox(height: 21),
                              LayoutBuilder(builder: (context, constraints) {
                                final linesInTextPainter = TextPainter(
                                  text: TextSpan(
                                    text: link.title,
                                    style: TextStyle(
                                      fontFamily: 'Cygre',
                                      fontSize: 26,
                                      fontWeight: FontWeight.w500,
                                      height: 42.04 / 26,
                                      color: isFirst
                                          ? Colors.black
                                          : Colors.transparent,
                                    ),
                                  ),
                                  textDirection: TextDirection.ltr,
                                )..layout(maxWidth: constraints.maxWidth + 90);

                                final linesCount = linesInTextPainter
                                    .computeLineMetrics()
                                    .length;

                                if (!isDoubleLines![i]!) {
                                  isDoubleLines![i] = linesCount > 1;
                                }

                                return _LinkWidget(
                                  link,
                                  aspectRatio: 165 / 136,
                                  titleMaxLines:
                                      widget.skeleton[i].length > 3 ||
                                              !isDoubleLines![i]!
                                          ? 1
                                          : 2,
                                  onPressed: widget.onPressed == null
                                      ? null
                                      : () => widget.onPressed!(link),
                                  onChangeImage: widget.onChangeImage == null
                                      ? null
                                      : () => widget.onChangeImage!(
                                          link as DailyLinkRequest),
                                  onChangeTitle: widget.onChangeTitle == null
                                      ? null
                                      : (title) => widget.onChangeTitle!(
                                          link as DailyLinkRequest, title),
                                  onChangeUrl: widget.onChangeUrl == null
                                      ? null
                                      : (url) => widget.onChangeUrl!(
                                          link as DailyLinkRequest, url),
                                  onSetPreviewFromUrl:
                                      widget.onSetPreviewFromUrl == null
                                          ? null
                                          : () => widget.onSetPreviewFromUrl!(
                                              link as DailyLinkRequest),
                                );
                              }),
                            ],
                          ),
                        );
                      },
                    ),
                ].separated(const SizedBox(width: 30)),
              ),
          ],
        ].separated(const SizedBox(height: 60)),
      ),
    );
  }
}

final class _LinkWidget extends StatefulWidget {
  const _LinkWidget(
    this.link, {
    required this.aspectRatio,
    required this.titleMaxLines,
    required this.onPressed,
    required this.onChangeImage,
    required this.onChangeTitle,
    required this.onChangeUrl,
    required this.onSetPreviewFromUrl,
  });

  final DailyLinkModel link;
  final double aspectRatio;
  final int titleMaxLines;
  final VoidCallback? onPressed;
  final VoidCallback? onChangeImage;
  final ValueChanged<String>? onChangeTitle;
  final ValueChanged<String>? onChangeUrl;
  final VoidCallback? onSetPreviewFromUrl;

  @override
  State<_LinkWidget> createState() => _LinkWidgetState();
}

final class _LinkWidgetState extends State<_LinkWidget> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: AspectRatio(
        aspectRatio: widget.aspectRatio,
        child: Clickable(
          onTap: widget.onPressed,
          isDisabling: false,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              Expanded(
                child: Clickable(
                  onTap: widget.onChangeImage,
                  isDisabling: false,
                  child: widget.link.previewImageUrl == null ||
                          widget.link.previewImageUrl!.toString().isEmpty
                      ? Container(
                          color: const Color(0xFFC3C3C3),
                          child: const Center(
                            child: Icon(
                              Icons.image_not_supported,
                              size: 80,
                              color: Colors.white,
                            ),
                          ),
                        )
                      : AnimatedNetworkImage(
                          widget.link.previewImageUrl,
                        ),
                ),
              ),
              Stack(
                children: [
                  SizedBox(
                    height: widget.titleMaxLines > 1 ? 85 : 66,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        const SizedBox(height: 12),
                        ConstrainedBox(
                          constraints: const BoxConstraints(maxHeight: 38),
                          child: TextWithEditing(
                            widget.link.title
                                .replaceAll(RegExp(_emojiRegular), '')
                                .trim(),
                            style: const TextStyle(
                              fontFamily: 'Cygre',
                              color: Color(0xFF000000),
                              fontSize: 16,
                              fontWeight: FontWeight.w500,
                              height: 19.12 / 16,
                            ),
                            maxLines: widget.titleMaxLines,
                            onChanged: widget.onChangeTitle,
                          ),
                        ),
                        const SizedBox(height: 6),
                        TextWithEditing(
                          widget.link.url.host.replaceAll('www.', ''),
                          changingText: '${widget.link.url}',
                          style: const TextStyle(
                            fontFamily: 'Cygre',
                            color: Color(0xFF747474),
                            fontSize: 15,
                            fontWeight: FontWeight.w500,
                            height: 18 / 15,
                          ),
                          maxLines: 1,
                          onChanged: widget.onChangeUrl,
                        ),
                        const SizedBox(height: 8),
                      ],
                    ),
                  ),
                  if (isHovered)
                    Positioned(
                      bottom: 12,
                      right: 15,
                      child: Row(
                        children: [
                          if (widget.onSetPreviewFromUrl != null)
                            Clickable(
                              onTap: widget.onSetPreviewFromUrl,
                              child: const Icon(
                                Icons.search,
                                size: 15,
                              ),
                            ),
                        ].separated(const SizedBox(width: 10)),
                      ),
                    ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

var _emojiRegular =
    '\[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)';

```

File: /packages/shared_app/lib/presentation/widgets/smooth_list_view.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class SmoothListView extends StatefulWidget {
  const SmoothListView({
    Key? key,
    required this.children,
  }) : super(key: key);

  final List<Widget> children;

  @override
  State<SmoothListView> createState() => _SmoothListViewState();
}

final class _SmoothListViewState extends State<SmoothListView> {
  final controller = ScrollController();

  @override
  void initState() {
    super.initState();
    controller.addListener(() {
      // ignore: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member
      final ScrollActivity? activity = controller.position.activity;
      if (activity is BallisticScrollActivity) {
        final Simulation? simulation =
            controller.position.physics.createBallisticSimulation(
          controller.position,
          activity.velocity,
        );
        if (simulation != null) {
          final double predictedPixels =
              simulation.x(100); // Adjust the duration as needed
          final double minPixels = controller.position.minScrollExtent;
          final double maxPixels = controller.position.maxScrollExtent;
          const double threshold = 20.0; // Adjust this threshold as needed
          final double velocity = activity.velocity.abs();
          final double distance = (predictedPixels - minPixels <= threshold)
              ? predictedPixels - minPixels
              : maxPixels - predictedPixels;
          final double duration =
              (distance / velocity) * 1000; // Convert to milliseconds
          if (predictedPixels - minPixels <= threshold) {
            controller.animateTo(
              minPixels,
              duration: Duration(milliseconds: duration.toInt()),
              curve: Curves.linearToEaseOut,
            );
          } else if (maxPixels - predictedPixels <= threshold) {
            controller.animateTo(
              maxPixels,
              duration: Duration(milliseconds: duration.toInt()),
              curve: Curves.linearToEaseOut,
            );
          }
        }
      }
    });
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ListView(
      // controller: controller,
      children: widget.children,
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/project_list_viewer.dart
Content:
```
import 'dart:async';

import 'package:shared_app/domain.dart';
import 'package:shared_app/presentation.dart';

final class ProjectListViewer extends StatefulWidget {
  const ProjectListViewer(
    this.data, {
    this.onProjectPressed,
    required this.onEndReached,
    required this.isHasMore,
  });

  final List<BrandingProject> data;
  final ValueChanged<BrandingProject>? onProjectPressed;
  final VoidCallback onEndReached;
  final bool isHasMore;

  @override
  State<ProjectListViewer> createState() => _ProjectListViewerState();
}

final class _ProjectListViewerState extends State<ProjectListViewer> {
  late ScrollController _scrollController = ScrollController()
    ..addListener(_onScroll);
  Timer? _timer;
  bool _antispamEnabled = false;

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    _timer?.cancel();
    super.dispose();
  }

  void _antispam() {
    _antispamEnabled = true;
    _timer = Timer(const Duration(milliseconds: 200), () {
      _antispamEnabled = false;
    });
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 500 &&
        widget.isHasMore &&
        !_antispamEnabled) {
      _antispam();
      widget.onEndReached();
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      controller: _scrollController,
      itemCount: widget.isHasMore ? widget.data.length + 1 : widget.data.length,
      itemBuilder: (context, index) {
        if (index == widget.data.length) {
          return const Padding(
            padding: EdgeInsets.symmetric(vertical: 16),
            child: Center(child: CircularProgressIndicator()),
          );
        }
        return _ProjectWidget(
          widget.data[index],
          onPressed: () => widget.onProjectPressed?.call(widget.data[index]),
        );
      },
      separatorBuilder: (_, __) => const SizedBox(
        height: 1,
        child: ColoredBox(
          color: Color(0xFFC9C9C9),
        ),
      ),
    );
  }
}

final class _ProjectWidget extends StatefulWidget {
  const _ProjectWidget(
    this.data, {
    required this.onPressed,
  });

  final BrandingProject data;
  final VoidCallback? onPressed;

  @override
  State<_ProjectWidget> createState() => _ProjectWidgetState();
}

final class _ProjectWidgetState extends State<_ProjectWidget> {
  bool isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => isHovered = true),
      onExit: (_) => setState(() => isHovered = false),
      child: Clickable(
        onTap: widget.onPressed,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.only(
                left: 20,
                right: 80,
                top: 10,
                bottom: 24,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.data.name,
                    style: const TextStyle(
                      fontFamily: 'Cygre Medium',
                      fontSize: 32,
                      fontWeight: FontWeight.w500,
                      height: 51.74 / 32,
                    ),
                  ),
                  Text(
                    widget.data.studio.name,
                    style: const TextStyle(
                      fontFamily: 'Cygre Medium',
                      fontSize: 18,
                      fontWeight: FontWeight.w500,
                      height: 29.11 / 18,
                      color: Color(0xFF646464),
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(
              height: 180,
              child: ListView.separated(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                scrollDirection: Axis.horizontal,
                itemCount: widget.data.children.length,
                itemBuilder: (context, index) => Hero(
                  tag: widget.data.children[index].id,
                  child: AnimatedNetworkImage(
                    widget.data.children[index].imageUrl,
                    height: 180,
                  ),
                ),
                separatorBuilder: (_, __) => const SizedBox(width: 12),
              ),
            ),
            const SizedBox(
              height: 29,
            ),
          ],
        ),
      ),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/clickable.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class Clickable extends StatefulWidget {
  const Clickable({
    Key? key,
    required this.child,
    required this.onTap,
    this.behavior = HitTestBehavior.opaque,
    this.isDisabling = true,
  }) : super(key: key);

  final Widget child;
  final VoidCallback? onTap;
  final HitTestBehavior behavior;
  final bool isDisabling;

  @override
  State<Clickable> createState() => _ClickableState();
}

final class _ClickableState extends State<Clickable> {
  bool isHovered = false;
  bool isPressed = false;

  @override
  Widget build(BuildContext context) {
    return DisablingDecorator(
      isDisabled: widget.isDisabling && widget.onTap == null,
      child: MouseRegion(
        onEnter: (_) => setState(() => isHovered = widget.onTap != null),
        onExit: (_) => setState(() => isHovered = false),
        cursor: SystemMouseCursors.click,
        child: GestureDetector(
          onTap: widget.onTap,
          onTapDown: (_) => setState(() => isPressed = true),
          onTapUp: (_) => setState(() => isPressed = false),
          onTapCancel: () => setState(() => isPressed = false),
          behavior: widget.behavior,
          child: AnimatedOpacity(
            duration: const Duration(milliseconds: 200),
            curve: Curves.fastOutSlowIn,
            opacity: isHovered ? 0.7 : 1,
            child: widget.child,
          ),
        ),
      ),
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/loading_decorator.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class LoadingDecorator extends StatelessWidget {
  const LoadingDecorator({
    super.key,
    required this.isLoading,
    required this.child,
  });
  final bool isLoading;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        IgnorePointer(
          ignoring: isLoading,
          child: child,
        ),
        if (isLoading)
          ColoredBox(
            color: Colors.white.withOpacity(0.5),
            child: const Center(
              child: CircularProgressIndicator(),
            ),
          ),
      ],
    );
  }
}

```

File: /packages/shared_app/lib/presentation/widgets/message_banner.dart
Content:
```
import 'package:shared_app/presentation.dart';

final class MessageBanner extends StatelessWidget {
  const MessageBanner({
    Key? key,
    required this.message,
    required this.iconData,
  }) : super(key: key);

  final String message;
  final IconData iconData;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          iconData,
          size: 40,
        ),
        const SizedBox(height: 20),
        Text(
          message,
          style: const TextStyle(
            fontFamily: 'Cygre',
            fontWeight: FontWeight.w500,
            fontSize: 18,
          ),
        ),
      ],
    );
  }
}

```

File: /packages/main_backend/main.dart
Content:
```
import 'dart:async';
import 'dart:io';
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

final _prismaSharedClient = PrismaSharedClient();
@protected
PrismaSharedClient get prismaSharedClient => _prismaSharedClient;

Future<HttpServer> run(Handler handler, InternetAddress ip, int port) async {
  final server = await serve(handler, ip, port);

  await _prismaSharedClient.$connect();

  print('Server started on ${server.address.address}:${server.port}');

  ProcessSignal.sigint.watch().listen((_) => _shutdown(server));
  ProcessSignal.sigterm.watch().listen((_) => _shutdown(server));

  return server;
}

Future<void> _shutdown(HttpServer server) async {
  print('Stopping server...');
  await server.close(force: true);

  await _prismaSharedClient.$disconnect();

  print('Server stopped');
  exit(0);
}

```

File: /packages/main_backend/pubspec.yaml
Content:
```
name: main_backend
version: 1.0.0+1
publish_to: none

environment:
  sdk: ">=3.4.4 <4.0.0"

dependencies:
  shared_main:
  shared_backend:
  dart_frog: ^1.0.0

dev_dependencies:
  test: ^1.25.2
  mocktail: ^1.0.3

```

File: /packages/main_backend/lib/infrastructure.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'infrastructure/endpoints/category.dart';
export 'infrastructure/endpoints/branding.dart';
export 'infrastructure/endpoints/collection_link.dart';
export 'infrastructure/exports.dart';
export 'infrastructure/environments.dart';

```

File: /packages/main_backend/lib/domain.dart
Content:
```
// GENERATED FILE: DO NOT MODIFY

export 'domain/exports.dart';

```

File: /packages/main_backend/lib/infrastructure/endpoints/category.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

final class CategoryEndpoint implements CategoryService {
  CategoryEndpoint(
    this._categoryManager,
  );

  final CategoryManager _categoryManager;

  @override
  Future<PaginatedDataOrFailure<Category>> getCategoriesByKey(
    String key, {
    UuidValue? cursor,
    required int limit,
  }) async {
    final data = await _categoryManager.getCategoriesByKey(
      key,
      cursor: cursor,
      limit: limit,
    );
    return successful(data);
  }
}

```

File: /packages/main_backend/lib/infrastructure/endpoints/branding.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

final class BrandingEndpoint implements BrandingService {
  BrandingEndpoint(
    this._brandingManager,
  );

  final BrandingManager _brandingManager;

  @override
  Future<PaginatedDataOrFailure<BrandingProject>> getProjects({
    UuidValue? cursor,
    required int limit,
    required int childrenLimit,
  }) async {
    final data = await _brandingManager.getProjects(
        cursor: cursor, limit: limit, childrenLimit: childrenLimit);
    return successful(data);
  }

  @override
  Future<PaginatedDataOrFailure<BrandingStudio>> getStudios({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) async {
    final data = await _brandingManager.getStudios(
      cursor: cursor,
      limit: limit,
      previewLimit: previewLimit,
    );
    return successful(data);
  }

  @override
  Future<PaginatedDataOrFailure<BrandingTheme>> getThemes({
    UuidValue? cursor,
    required int limit,
    required int previewLimit,
  }) async {
    final data = await _brandingManager.getThemes(
      cursor: cursor,
      limit: limit,
      previewLimit: previewLimit,
    );

    return successful(data);
  }

  @override
  Future<PaginatedDataOrFailure<BrandingPost>> getPosts({
    UuidValue? cursor,
    required int limit,
    UuidValue? byProject,
    List<UuidValue> byCategories = const [],
  }) async {
    final data = await _brandingManager.getPosts(
      cursor: cursor,
      limit: limit,
      byProject: byProject,
      byCategories: byCategories,
    );
    return successful(data);
  }

  @override
  Future<DataOrFailure<BrandingProject>> getProjectById(UuidValue id,
      {required int childrenLimit}) async {
    final data =
        await _brandingManager.getProjectById(id, childrenLimit: childrenLimit);
    return successful(data);
  }

  @override
  Future<DataOrFailure<BrandingPost>> getPostById(UuidValue id) async {
    final data = await _brandingManager.getPostById(id);
    return successful(data);
  }
}

```

File: /packages/main_backend/lib/infrastructure/endpoints/collection_link.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

final class CollectionLinkEndpoint implements CollectionLinkService {
  CollectionLinkEndpoint(
    this._collectionLinkManager,
  );

  final DailyLinkManager _collectionLinkManager;

  @override
  Future<ListDataOrFailure<Date>> getDates() async {
    final data = await _collectionLinkManager.getDates();
    return successful(
      data
          .where(
            (e) => e.isBefore(Date.now()),
          )
          .toList(),
    );
  }

  @override
  Future<ListDataOrFailure<DailyLink>> getLinksByDate(Date date) async {
    if (!await _collectionLinkManager.existsDate(date)) {
      return failed(DateNotFoundFailure());
    }

    return successful(await _collectionLinkManager.getLinksByDate(date));
  }
}

```

File: /packages/main_backend/lib/infrastructure/exports.dart
Content:
```
export 'package:shared_backend/infrastructure.dart';

```

File: /packages/main_backend/lib/infrastructure/environments.dart
Content:
```
import 'dart:io';

final class Environments {
  static String dbHost = Platform.environment['DB_HOST'] ?? 'localhost';
  static int dbPort =
      int.tryParse(Platform.environment['DB_PORT'] ?? '') ?? 5432;
  static String dbName = Platform.environment['DB_NAME'] ?? 'postgres';
  static String dbUsername = Platform.environment['DB_USERNAME'] ?? 'postgres';
  static String dbPassword =
      Platform.environment['DB_PASSWORD'] ?? 'testpassword';
}

```

File: /packages/main_backend/lib/domain/exports.dart
Content:
```
export 'package:shared_backend/domain.dart';

```

File: /packages/main_backend/routes/index.dart
Content:
```
import 'package:main_backend/infrastructure.dart';

Response onRequest(RequestContext context) {
  return Response(body: 'root route');
}

```

File: /packages/main_backend/routes/branding/themes.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.getParametersFromQuery(
    ['cursor', 'limit', 'preview_limit'],
    [UuidValue, const Required(int), const Required(int)],
    (map) => context
        .read<BrandingService>()
        .getThemes(
          cursor: map['cursor'],
          limit: map['limit'],
          previewLimit: map['preview_limit'],
        )
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/branding/post/[id].dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context, String id) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, id),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String id) async {
  return context
      .read<BrandingService>()
      .getPostById(UuidValue.fromString(id))
      .toResponse();
}

```

File: /packages/main_backend/routes/branding/projects.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.getParametersFromQuery(
    ['cursor', 'limit', 'children_limit'],
    [UuidValue, const Required(int), const Required(int)],
    (map) => context
        .read<BrandingService>()
        .getProjects(
          cursor: map['cursor'],
          limit: map['limit'],
          childrenLimit: map['children_limit'],
        )
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/branding/posts.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.getParametersFromQuery(
    ['cursor', 'limit', 'by_project', 'by_categories'],
    [UuidValue, const Required(int), UuidValue, List<UuidValue>],
    (map) => context
        .read<BrandingService>()
        .getPosts(
          cursor: map['cursor'],
          limit: map['limit'],
          byProject: map['by_project'],
          byCategories: map['by_categories'],
        )
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/branding/project/[id].dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context, String id) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, id),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String id) async {
  return context.getParametersFromQuery(
    ['children_limit'],
    [const Required(int)],
    (map) => context
        .read<BrandingService>()
        .getProjectById(UuidValue.fromString(id),
            childrenLimit: map['children_limit'])
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/branding/_middleware.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<BrandingService>(
          () => BrandingEndpoint(
            context.read<BrandingManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/main_backend/routes/branding/studios.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.getParametersFromQuery(
    ['cursor', 'limit', 'preview_limit'],
    [UuidValue, const Required(int), const Required(int)],
    (map) => context
        .read<BrandingService>()
        .getStudios(
          cursor: map['cursor'],
          limit: map['limit'],
          previewLimit: map['preview_limit'],
        )
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/daily/links/[date].dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context, String date) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, date),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String date) async {
  return context
      .read<CollectionLinkService>()
      .getLinksByDate(Date.parse(date))
      .toResponse();
}

```

File: /packages/main_backend/routes/daily/_middleware.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<CollectionLinkService>(
          () => CollectionLinkEndpoint(
            context.read<DailyLinkManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/main_backend/routes/daily/dates.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context) async {
  return context.read<CollectionLinkService>().getDates().toResponse();
}

```

File: /packages/main_backend/routes/_middleware.dart
Content:
```
import 'package:main_backend/infrastructure.dart';
import 'package:shelf_cors_headers/shelf_cors_headers.dart' as shelf;

import '../main.dart' as main;

Handler middleware(Handler handler) {
  return handler
      .use(_provideManagers())
      .use(_providePrisma())
      .use(
        fromShelfMiddleware(
          shelf.corsHeaders(
            headers: {
              shelf.ACCESS_CONTROL_ALLOW_ORIGIN: '*',
              shelf.ACCESS_CONTROL_ALLOW_METHODS:
                  'GET,PUT,POST,PATCH,DELETE,OPTIONS',
              shelf.ACCESS_CONTROL_ALLOW_HEADERS:
                  'Origin, Content-Type, Accept, Authorization',
            },
          ),
        ),
      )
      .use(requestLogger());
}

Middleware _providePrisma() {
  return (handler) {
    return (context) async {
      return handler(
        context.provide(() => main.prismaSharedClient),
      );
    };
  };
}

Middleware _provideManagers() {
  return (handler) {
    return (context) async {
      final categoryManager =
          CategoryManager(context.read<PrismaSharedClient>());
      final brandingManager = BrandingManager(
        context.read<PrismaSharedClient>(),
        categoryManager,
      );

      return handler(context
          .provide(() => DailyLinkManager(context.read<PrismaSharedClient>()))
          .provide(() => brandingManager)
          .provide(() => categoryManager));
    };
  };
}

```

File: /packages/main_backend/routes/categories/[key].dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Future<Response> onRequest(RequestContext context, String key) {
  return switch (context.request.method) {
    HttpMethod.get => _get(context, key),
    _ => Future.value(Response(statusCode: HttpStatus.methodNotAllowed)),
  };
}

Future<Response> _get(RequestContext context, String key) async {
  return context.getParametersFromQuery(
    ['cursor', 'limit'],
    [UuidValue, const Required(int)],
    (map) => context
        .read<CategoryService>()
        .getCategoriesByKey(
          key,
          cursor: map['cursor'],
          limit: map['limit'],
        )
        .toResponse(),
  );
}

```

File: /packages/main_backend/routes/categories/_middleware.dart
Content:
```
import 'package:main_backend/domain.dart';
import 'package:main_backend/infrastructure.dart';

Handler middleware(Handler handler) {
  return handler.use(
    (handler) => (context) async {
      return handler(
        context.provide<CategoryService>(
          () => CategoryEndpoint(
            context.read<CategoryManager>(),
          ),
        ),
      );
    },
  );
}

```

File: /packages/main_backend/.dart_frog/server.dart
Content:
```
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, implicit_dynamic_list_literal

import 'dart:io';

import 'package:dart_frog/dart_frog.dart';

import '../main.dart' as entrypoint;
import '../routes/index.dart' as index;
import '../routes/daily/dates.dart' as daily_dates;
import '../routes/daily/links/[date].dart' as daily_links_$date;
import '../routes/categories/[key].dart' as categories_$key;
import '../routes/branding/themes.dart' as branding_themes;
import '../routes/branding/studios.dart' as branding_studios;
import '../routes/branding/projects.dart' as branding_projects;
import '../routes/branding/posts.dart' as branding_posts;
import '../routes/branding/project/[id].dart' as branding_project_$id;
import '../routes/branding/post/[id].dart' as branding_post_$id;

import '../routes/_middleware.dart' as middleware;
import '../routes/daily/_middleware.dart' as daily_middleware;
import '../routes/categories/_middleware.dart' as categories_middleware;
import '../routes/branding/_middleware.dart' as branding_middleware;

void main() async {
  final address = InternetAddress.tryParse('') ?? InternetAddress.anyIPv6;
  final port = int.tryParse(Platform.environment['PORT'] ?? '8080') ?? 8080;
  hotReload(() => createServer(address, port));
}

Future<HttpServer> createServer(InternetAddress address, int port) {
  final handler = Cascade().add(buildRootHandler()).handler;
  return entrypoint.run(handler, address, port);
}

Handler buildRootHandler() {
  final pipeline = const Pipeline().addMiddleware(middleware.middleware);
  final router = Router()
    ..mount('/branding/post', (context) => buildBrandingPostHandler()(context))
    ..mount('/branding/project', (context) => buildBrandingProjectHandler()(context))
    ..mount('/branding', (context) => buildBrandingHandler()(context))
    ..mount('/categories', (context) => buildCategoriesHandler()(context))
    ..mount('/daily/links', (context) => buildDailyLinksHandler()(context))
    ..mount('/daily', (context) => buildDailyHandler()(context))
    ..mount('/', (context) => buildHandler()(context));
  return pipeline.addHandler(router);
}

Handler buildBrandingPostHandler() {
  final pipeline = const Pipeline().addMiddleware(branding_middleware.middleware);
  final router = Router()
    ..all('/<id>', (context,id,) => branding_post_$id.onRequest(context,id,));
  return pipeline.addHandler(router);
}

Handler buildBrandingProjectHandler() {
  final pipeline = const Pipeline().addMiddleware(branding_middleware.middleware);
  final router = Router()
    ..all('/<id>', (context,id,) => branding_project_$id.onRequest(context,id,));
  return pipeline.addHandler(router);
}

Handler buildBrandingHandler() {
  final pipeline = const Pipeline().addMiddleware(branding_middleware.middleware);
  final router = Router()
    ..all('/themes', (context) => branding_themes.onRequest(context,))..all('/studios', (context) => branding_studios.onRequest(context,))..all('/projects', (context) => branding_projects.onRequest(context,))..all('/posts', (context) => branding_posts.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildCategoriesHandler() {
  final pipeline = const Pipeline().addMiddleware(categories_middleware.middleware);
  final router = Router()
    ..all('/<key>', (context,key,) => categories_$key.onRequest(context,key,));
  return pipeline.addHandler(router);
}

Handler buildDailyLinksHandler() {
  final pipeline = const Pipeline().addMiddleware(daily_middleware.middleware);
  final router = Router()
    ..all('/<date>', (context,date,) => daily_links_$date.onRequest(context,date,));
  return pipeline.addHandler(router);
}

Handler buildDailyHandler() {
  final pipeline = const Pipeline().addMiddleware(daily_middleware.middleware);
  final router = Router()
    ..all('/dates', (context) => daily_dates.onRequest(context,));
  return pipeline.addHandler(router);
}

Handler buildHandler() {
  final pipeline = const Pipeline();
  final router = Router()
    ..all('/', (context) => index.onRequest(context,));
  return pipeline.addHandler(router);
}


```

